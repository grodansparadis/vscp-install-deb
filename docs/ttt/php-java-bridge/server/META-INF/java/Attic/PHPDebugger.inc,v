head	1.14;
access;
symbols
	Release_7-0-0:1.13.0.4
	Root_Release_7-0-0:1.13
	Release-6-2-2:1.13.0.2
	Release-6-1-2-3:1.12
	Root_Release-6-1-2-3:1.12
	Release-6-1-2-2:1.12.0.6
	Root_Release-6-1-2-2:1.12
	debian_version_6_1_2_1-1:1.12
	upstream_version_6_1_2_1:1.12
	Release-6-1-2-1_new:1.12.0.4
	Root_Release-6-1-2-1_new:1.12
	Release-6-1-2-1:1.12.0.2
	Root_Release-6-1-2-1:1.12
	upstream_version_6_1_2:1.3
	debian_version_6_1_2-1:1.4
	Release-6-1-2:1.3.0.2
	Root_Release-6-1-2:1.3;
locks; strict;
comment	@# @;


1.14
date	2017.02.25.16.29.46;	author jost_boekemeier;	state dead;
branches;
next	1.13;

1.13
date	2017.01.30.22.28.58;	author jost_boekemeier;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.02.11.49.36;	author jost_boekemeier;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.28.17.00.56;	author jost_boekemeier;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.28.03.18.31;	author jost_boekemeier;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.26.16.48.32;	author jost_boekemeier;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.25.20.08.59;	author jost_boekemeier;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.25.11.27.14;	author jost_boekemeier;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.25.07.16.26;	author jost_boekemeier;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.24.14.19.59;	author jost_boekemeier;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.19.19.43.09;	author jost_boekemeier;	state Exp;
branches;
next	1.3;

1.3
date	2010.04.18.21.05.27;	author jost_boekemeier;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.17.18.31.00;	author jost_boekemeier;	state Exp;
branches;
next	1.1;

1.1
date	2010.04.17.18.15.48;	author jost_boekemeier;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Version 7.0.0 for PHP 7 released
@
text
@<?php /*-*- mode: php; tab-width:4 -*-*/

  /**
   * PHPDebugger.inc -- A PHP debugger for Eclipse for PHP Developers
   *
   * Copyright (C) 2009,2010 Jost Boekemeier.
   *
   * Permission is hereby granted, free of charge, to any person
   * obtaining a copy of this file (the "Software"), to deal in the
   * Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute,
   * sublicense, and/or sell copies of the Software, and to permit
   * persons to whom the Software is furnished to do so, subject to the
   * following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
   *
   * Installation:
   *
   * Install "Eclipse for PHP Developers" version >= 3.5.2
   * 
   * - Open your project in PHP explorer and drag and drop this file to the PHP project folder.
   *
   * - Activate the PHPDebugger in your php.ini file. For example open Menu/Project/Properties, open "PHP Debug", select "Enable Project specific settings", select "Zend Debugger" if not already selected, click on "PHP executables ...", then "Edit" and select  a php.ini file with at least the following content:
   *
   *<code>
   * ;; activate the PHPDebugger in the php.ini
   * auto_prepend_file=PHPDebugger.inc
   *</code>
   *
   * - Debug your PHP scripts as usual. 
   *
   *
   * @@category   java
   * @@package    pdb
   * @@author     Jost Boekemeier
   * @@license    MIT
   * @@version    1.0
   * @@link       http://php-java-bridge.sf.net/phpdebugger
   * @@see        PHPDebugger.php
   */


/** @@access private */
define ("PDB_DEBUG", 0);
set_time_limit (0);

if (!class_exists("pdb_Parser")) {
  /**
   * The PHP parser
   * @@access private
   */
  class pdb_Parser {
	const BLOCK = 1;
	const STATEMENT = 2;
	const EXPRESSION = 3;
	const FUNCTION_BLOCK = 4; // BLOCK w/ STEP() as last statement

	private $scriptName, $content;
	private $code;
	private $output;
	private $line, $currentLine;
	private $beginStatement, $inPhp, $inDQuote;
 
	/**
	 * Create a new PHP parser
	 * @@param string the script name
	 * @@param string the script content
	 * @@access private
	 */
	public function __construct($scriptName, $content) {
	  $this->scriptName = $scriptName;
	  $this->content = $content;
	  $this->code = token_get_all($content);
	  $this->output = "";
	  $this->line = $this->currentLine = 0;
	  $this->beginStatement = $this->inPhp = $this->inDQuote = false;
	}

	private function toggleDQuote($chr) {
	  if ($chr == '"') $this->inDQuote = !$this->inDQuote;
	}

	private function each() {
	  $next = each ($this->code);
	  if ($next) {
		$cur = current($this->code);
		if (is_array($cur)) {
		  $this->currentLine = $cur[2] + ($cur[1][0] == "\n" ? substr_count($cur[1], "\n") : 0);
		  if ($this->isWhitespace($cur)) {
			$this->write($cur[1]);
			return $this->each();
		  }
		}
		else 
		  $this->toggleDQuote($cur);
	  }
	  return $next;
	}

	private function write($code) {
	  //echo "write:::".$code."\n";
	  $this->output.=$code;
	}

	private function writeInclude($once) {
	  $name = "";
	  while(1) {
		if (!$this->each()) die("parse error");
		$val = current($this->code);
		if (is_array($val)) {
		  $name.=$val[1];
		} else {
		  if ($val==';') break;
		  $name.=$val;
		}
	  }
	  if (PDB_DEBUG == 2) 
		$this->write("EVAL($name);");
	  else
		$this->write("eval('?>'.pdb_startInclude($name, $once)); pdb_endInclude();");
	}

	private function writeCall() {
	  while(1) {
		if (!$this->each()) die("parse error");
		$val = current($this->code);
		if (is_array($val)) {
		  $this->write($val[1]);
		} else {
		  $this->write($val);
		  if ($val=='{') break;
		}
	  }
	  $scriptName = addslashes($this->scriptName);
	  $this->write("\$__pdb_CurrentFrame=pdb_startCall(\"$scriptName\", {$this->currentLine});");
	}

	private function writeStep($pLevel) {
	  $token = current($this->code);
	  if ($this->inPhp && !$pLevel && !$this->inDQuote && $this->beginStatement && !$this->isWhitespace($token) && ($this->line != $this->currentLine)) {
		$line = $this->line = $this->currentLine;
		$scriptName = addslashes($this->scriptName);
		if (PDB_DEBUG == 2)
		  $this->write(";STEP($line);");
		else
		  $this->write(";pdb_step(\"$scriptName\", $line, pdb_getDefinedVars(get_defined_vars(), (isset(\$this) ? \$this : NULL)));");
	  }
	}

	private function writeNext() {
	  $this->next();
	  $token = current($this->code);
	  if (is_array($token)) $token = $token[1];
	  $this->write($token);
	}

	private function nextIs($chr) {
	  $i = 0;
	  while(each($this->code)) {
		$cur = current($this->code);
		$i++;
		if (is_array($cur)) {
		  switch ($cur[0]) {
		  case T_COMMENT:
		  case T_DOC_COMMENT:
		  case T_WHITESPACE:
			break;	/* skip */
		  default: 
			while($i--) prev($this->code);
			return false;	/* not found */
		  }
		} else {
		  while($i--) prev($this->code);
		  return $cur == $chr;	/* found */
		}
	  }
	  while($i--) prev($this->code);
	  return false;	/* not found */
	}

	private function nextTokenIs($ar) {
	  $i = 0;
	  while(each($this->code)) {
		$cur = current($this->code);
		$i++;
		if (is_array($cur)) {
		  switch ($cur[0]) {
		  case T_COMMENT:
		  case T_DOC_COMMENT:
		  case T_WHITESPACE:
			break;	/* skip */
		  default: 
			while($i--) prev($this->code);
			return (in_array($cur[0], $ar));
		  }
		} else {
		  break; /* not found */
		}
	  }
	  while($i--) prev($this->code);
	  return false;	/* not found */
	}

	private function isWhitespace($token) {
	  $isWhitespace = false;
	  switch($token[0]) {
	  case T_COMMENT:
	  case T_DOC_COMMENT:
	  case T_WHITESPACE:
		$isWhitespace = true;
		break;
	  }
	  return $isWhitespace;
	}
	private function next() {
	  if (!$this->each()) trigger_error("parse error", E_USER_ERROR);
	}

	private function parseBlock () {
	  $this->parse(self::BLOCK);
	}
	private function parseFunction () {
	  $this->parse(self::FUNCTION_BLOCK);
	}
	private function parseStatement () {
	  $this->parse(self::STATEMENT);
	}
	private function parseExpression () {
	  $this->parse(self::EXPRESSION);
	}

	private function parse ($type) {
	  pdb_Logger::debug("parse:::$type");

	  $this->beginStatement = true;
	  $pLevel = 0;

	  do {
		$token = current($this->code);
		if (!is_array($token)) {
		  pdb_Logger::debug(":::".$token);
		  if (!$pLevel && $type==self::FUNCTION_BLOCK && $token=='}') $this->writeStep($pLevel);
		  $this->write($token);
		  if ($this->inPhp && !$this->inDQuote) {
			$this->beginStatement = false; 
			switch($token) {
			case '(': 
			  $pLevel++;
			  break;
			case ')':
			  if (!--$pLevel && $type==self::EXPRESSION) return;
			  break;
			case '{': 
			  $this->next();
			  $this->parseBlock(); 
			  break;
			case '}': 
			  if (!$pLevel) return;
			  break;
			case ';':
			  if (!$pLevel) {
				if ($type==self::STATEMENT) return;
				$this->beginStatement = true; 
			  }
			  break;
			}
		  }
		} else {
		  pdb_Logger::debug(":::".$token[1].":(".token_name($token[0]).')');

		  if ($this->inDQuote) {
			$this->write($token[1]);
			continue;
		  }

		  switch($token[0]) {

		  case T_OPEN_TAG: 
		  case T_START_HEREDOC:
		  case T_OPEN_TAG_WITH_ECHO: 
			$this->beginStatement = $this->inPhp = true;
			$this->write($token[1]);
			break;

		  case T_END_HEREDOC:
		  case T_CLOSE_TAG: 
			$this->writeStep($pLevel);

			$this->write($token[1]);
			$this->beginStatement = $this->inPhp = false; 
			break;

		  case T_FUNCTION:
			$this->write($token[1]);
			$this->writeCall();
			$this->next();
			$this->parseFunction();
			$this->beginStatement = true;
			break;

		  case T_ELSE:
			$this->write($token[1]);
			if ($this->nextIs('{')) {
			  $this->writeNext();
			  $this->next();

			  $this->parseBlock();
			} else {
			  $this->next();

			  /* create an artificial block */
			  $this->write('{');
			  $this->beginStatement = true;
			  $this->writeStep($pLevel);
			  $this->parseStatement();
			  $this->write('}');

			}
			if ($type==self::STATEMENT) return;

			$this->beginStatement = true;
			break;

		  case T_DO:
			$this->writeStep($pLevel);
			$this->write($token[1]);
			if ($this->nextIs('{')) {
			  $this->writeNext();
			  $this->next();

			  $this->parseBlock();
			  $this->next();

			} else {
			  $this->next();

			  /* create an artificial block */
			  $this->write('{');
			  $this->beginStatement = true;
			  $this->writeStep($pLevel);
			  $this->parseStatement();
			  $this->next();
			  $this->write('}');
			}
			$token = current($this->code);
			$this->write($token[1]);

			if ($token[0]!=T_WHILE) trigger_error("parse error", E_USER_ERROR);
			$this->next();
			$this->parseExpression();

			if ($type==self::STATEMENT) return;

			$this->beginStatement = true;
			break;

		  case T_CATCH:
		  case T_IF:
		  case T_ELSEIF:
		  case T_FOR:
		  case T_FOREACH:
		  case T_WHILE:
			$this->writeStep($pLevel);

			$this->write($token[1]);
			$this->next();

			$this->parseExpression();

			if ($this->nextIs('{')) {
			  $this->writeNext();
			  $this->next();

			  $this->parseBlock();


			} else {
			  $this->next();
			  /* create an artificial block */
			  $this->write('{');
			  $this->beginStatement = true;
			  $this->writeStep($pLevel);
			  $this->parseStatement();
			  $this->write('}');
			}

			if ($this->nextTokenIs(array(T_ELSE, T_ELSEIF, T_CATCH))) {
			  $this->beginStatement = false;
			} else {
			  if ($type==self::STATEMENT) return;
			  $this->beginStatement = true;
			}
			break;

		  case T_REQUIRE_ONCE:
		  case T_INCLUDE_ONCE: 
		  case T_INCLUDE: 
		  case T_REQUIRE: 
			$this->writeStep($pLevel);
			$this->writeInclude((($token[0]==T_REQUIRE_ONCE) || ($token[0]==T_INCLUDE_ONCE)) ? 1 : 0);

			if ($type==self::STATEMENT) return;

			$this->beginStatement = true;
			break;

		  case T_CLASS:
			$this->write($token[1]);
			$this->writeNext();
			if ($this->nextIs('{')) {
			  $this->writeNext();
			  $this->next();
			  $this->parseBlock(); 
			  $this->beginStatement = true;
			} else {
			  $this->writeNext();
			  $this->beginStatement = false;
			}
			break;

		  case T_CASE:
		  case T_DEFAULT:
		  case T_PUBLIC:
		  case T_PRIVATE:
		  case T_PROTECTED:
		  case T_STATIC:
		  case T_CONST:
		  case T_GLOBAL:
		  case T_ABSTRACT:
			$this->write($token[1]);
			$this->beginStatement = false;
			break;

		  default:
			$this->writeStep($pLevel);
			$this->write($token[1]);
			$this->beginStatement = false;
			break;
	
		  }
		}
	  } while($this->each());
	}

	/**
	 * parse the given PHP script
	 * @@return the parsed PHP script
	 * @@access private
	 */
	public function parseScript() {
	  do {
		$this->parseBlock();
	  } while($this->each());

	  return $this->output;
	}
  }
}

/**
 * @@access private
 */
class pdb_Logger {
  const FATAL = 1;
  const INFO = 2;
  const VERBOSE = 3;
  const DEBUG = 4;

  private static $logLevel = 0;
  private static $logFileName;

  private static function println($msg, $level) {
	if (!self::$logLevel) self::$logLevel=PDB_DEBUG?self::DEBUG:self::INFO;
	if ($level <= self::$logLevel) {
	  static $file = null;
	  if(!isset(self::$logFileName)) {
		self::$logFileName = $_SERVER['HOME'].DIRECTORY_SEPARATOR."pdb_PHPDebugger.inc.log";
	  }
	  if (!$file) $file = fopen(self::$logFileName, "ab") or die("fopen");
	  fwrite($file, time().": ");
	  fwrite($file, $msg."\n");
	  fflush($file);
	}
  }

  public static function logFatal($msg) {
	self::println($msg, self::FATAL);
  }
  public static function logInfo($msg) {
	self::println($msg, self::INFO);
  }
  public static function logMessage($msg) {
	self::println($msg, self::VERBOSE);
  }
  public static function logDebug($msg) {
	self::println($msg, self::DEBUG);
  }
  public static function debug($msg) {
	self::logDebug($msg);
  }
  public static function log($msg) {
	self::logMessage($msg);
  }
  public static function setLogLevel($level) {
	self::$logLevel=$level;
  }
  public static function setLogFileName($name) {
	self::$logFileName = $name;
  }
}

/**
 * @@access private
 */
class pdb_Environment {
  public $filename, $stepNext;
  public $vars, $line, $firstLine;
  public $parent;

  public function __construct($parent, $filename, $stepNext, $firstLine) {
	$this->parent = $parent;
    $this->filename = $filename;
    $this->stepNext = $stepNext;
	$this->firstLine = $firstLine;
    $this->line = -1;
  }

  public function update ($line, &$vars) {
    $this->line = $line;
    $this->vars = &$vars;
  }
  public function __toString() {
	return "pdb_Environment: {$this->filename}, {$this->firstLine} - {$this->line}";
  }
}

/**
 * @@access private
 */
abstract class pdb_Message {
  public $session;

  public abstract function getType();

  public function __construct($session) {
    $this->session = $session;
  }

  public function serialize() {
    $this->session->out->writeShort($this->getType());
  }

  private static $messages = array();
  public static function register($message) {
    pdb_Message::$messages[$message->getType()] = $message;
  }
  public function getMessageById($id) {
    $message = pdb_Message::$messages[$id];
    return $message;
  }
  public function getMessage() {
    $id = $this->session->in->readShort();
    $message = $this->getMessageById($id);
    if (!$message) trigger_error("invalid message: $id", E_USER_ERROR);
    $message->deserialize();
    return $message;
  }

  protected function handleContinueProcessFile($message) {
	$code = $this->session->parseCode($this->currentFrame->filename, file_get_contents($this->currentFrame->filename));
	if (PDB_DEBUG) pdb_Logger::debug( "parse file:::" . $code ."\n");
	if (!PDB_DEBUG) ob_start();
	self::doEval ($code);
	$output = $this->getMessageById(pdb_OutputNotification::TYPE);
	if(!PDB_DEBUG) $output->setOutput(ob_get_contents());
	if(!PDB_DEBUG) ob_end_clean();
	$output->serialize();
	$this->status = 42; //FIXME
	$this->getMessageById(pdb_DebugScriptEndedNotification::TYPE)->serialize();
    return true;
  }
  private static function doEval($__pdb_Code) {
    return  eval ("?>".$__pdb_Code);
  }
  protected function handleStep($message) {
    return false;
  }
  protected function handleGo($message) {
    foreach ($this->session->allFrames as $frame) {
      $frame->stepNext = false;
    }
    return true; // exit
  }
  public function handleRequests () {
	$this->ignoreInterrupt = false;

    $this->serialize();
    while(1) {
      $message = $this->getMessage();
      switch ($message->getType()) {
      case pdb_SetProtocolRequest::TYPE:
		$message->ack();
		break;
      case pdb_StartRequest::TYPE:
		$message->ack();
		$this->getMessageById(pdb_StartProcessFileNotification::TYPE)->serialize();
		break;
      case pdb_ContinueProcessFileNotification::TYPE:
		if ($this->handleContinueProcessFile($message)) return pdb_ContinueProcessFileNotification::TYPE;
		break;
      case pdb_AddBreakpointRequest::TYPE:
		$message->ack();
		break;
      case pdb_RemoveBreakpointRequest::TYPE:
		$message->ack();
		break;
      case pdb_RemoveAllBreakpointsRequest::TYPE:
		$message->ack();
		break;
      case pdb_GetCallStackRequest::TYPE:
		$message->ack();
		break;
      case pdb_GetCWDRequest::TYPE:
		$message->ack();
		break;
      case pdb_GetVariableValueRequest::TYPE:
		$message->ack();
		break;
      case pdb_GoRequest::TYPE:
		$message->ack();
		if ($this->handleGo($message)) return pdb_GoRequest::TYPE;
		break;
      case pdb_StepOverRequest::TYPE:
		$message->ack();
		if ($this->handleStep($message)) return pdb_StepOverRequest::TYPE;
		break;
      case pdb_StepIntoRequest::TYPE:
		$message->ack();
		if ($this->handleStep($message)) return pdb_StepIntoRequest::TYPE;
		break;
      case pdb_StepOutRequest::TYPE:
		$message->ack();
		if ($this->handleStep($message)) return pdb_StepOutRequest::TYPE;
		break;
      case pdb_End::TYPE:
		$this->session->end();
      default: trigger_error("protocol error: $message", E_USER_ERROR);
      }
    }
  }
}
/**
 * @@access private
 */
abstract class pdb_MessageRequest extends pdb_Message {
  public abstract function ack();
}

/**
 * @@access private
 */
class pdb_Serializer {
  private $serial;
  private $depth;

  private function doSerialize ($o, $depth) {
    $serial = &$this->serial;

    switch(gettype($o)) {
    case 'object':
      $serial.="O:";
      $serial.=strlen(get_class($o));
      $serial.=":\"";
      $serial.=get_class($o);
      $serial.="\":";
      $serial.=count((array)$o);

	  if ($depth <= $this->depth) {
		$serial.=":{";
		foreach((array)$o as $k=>$v) {
		  $serial.=serialize($k);
		  $this->doSerialize($v, $depth+1);
		}
		$serial.="}";
	  } else {
		$serial .= ";";
	  }
      break;

    case 'array':
      $serial.="a:";
      $serial.=count($o);

	  if ($depth <= $this->depth) {
		$serial.=":{";
		foreach($o as $k=>$v) {
		  $serial.=serialize($k);
		  $this->doSerialize($v, $depth+1);
		}
		$serial.="}";
	  } else {
		$serial.=";";
	  }
      break;
    default:
      $serial.=serialize($o);
      break;
    }
  }

  public function serialize ($obj, $depth) {
    $this->serial = "";
	$this->depth = $depth;

    $this->doSerialize ($obj, 1);

    return $this->serial;
  }
}

/**
 * @@access private
 */
class pdb_DebugSessionStart extends pdb_Message {
  const TYPE = 2005;

  public $status;
  public $end;

  private $breakFirstLine;
  private $enable;
  public $uri;
  public $query;
  public $options;
  
  public $in, $out;
  private $outputNotification;

  public $lines;
  public $breakpoints;

  public $currentTopLevelFrame, $currentFrame;
  public $allFrames; // should be a weak map so that frames could be gc'ed

  public $ignoreInterrupt; 

  public $serializer;

  public $includedScripts;

  public function getType() {
    return self::TYPE;
  }
  public function __construct($options) {
    parent::__construct($this);
	$this->end = true;
	if (isset($_SERVER["PATH_INFO"]) && isset($_SERVER["QUERY_STRING"])&&!extension_loaded("Zend Debugger")) {
	  $filename = $uri = $_SERVER["PATH_INFO"];
	  $queryStr = $_SERVER["QUERY_STRING"];
	} else {
	  $this->enable = false;
	  return;
	}

	$params = explode('&', $queryStr);
	$args = array();
	for ($i=0; $i<count($params); $i++) {
	  $arg=explode( '=', $params[$i]);
	  $args[$arg[0]] = $arg[1];
	}
	$this->enable = $args["start_debug"];
	$this->breakFirstLine = isset($args["debug_stop"]) ? $args["debug_stop"] : 0;
    $this->uri = $uri;
    $this->query = $queryStr;
    $this->options = $options;
    $this->breakpoints = $this->lines = array();

	$this->serializer = new pdb_Serializer();

	$this->currentTopLevelFrame = $this->currentFrame = new pdb_Environment(null, $filename, false, 1);
	$this->allFrames[] = $this->currentFrame;
	$this->ignoreInterrupt = false;
	$this->includedScripts = array();

    $errno = 0; $errstr = "";
    $io = fsockopen($args["debug_host"], $args['debug_port'], $errno, $errstr, 5) or trigger_error("fsockopen", E_USER_ERROR);
	$this->end = false;

    $this->in =new pdb_In($io, $this);
    $this->out=new pdb_Out($io, $this);
  }
  public function end() {
	$this->end = true;
	if (PDB_DEBUG) pdb_Logger::debug( "end() called");
	exit(0);
  }
  /**
   * @@access private
   */
  public function flushOutput() {
	if (!isset($this->outputNotification))
	  $this->outputNotification = $this->getMessageById(pdb_OutputNotification::TYPE);

	$this->outputNotification->setOutput(ob_get_contents());
	if (!PDB_DEBUG) ob_clean();
	$this->outputNotification->serialize();
  }

  /**
   * @@access private
   */
  public function resolveIncludePath($scriptName) {
	if (file_exists($scriptName)) return realpath($scriptName);
	$paths = explode(PATH_SEPARATOR, get_include_path());
	$name = $scriptName;
	foreach ($paths as $path) {
	  $scriptName = realpath("${path}${name}");
	  if ($scriptName) return $scriptName;
	}
	trigger_error("file $scriptName not found", E_USER_ERROR);
  }

  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt(2004102501);
    $out->writeString($this->currentFrame->filename);
    $out->writeString($this->uri);
    $out->writeString($this->query);
    $out->writeString($this->options);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function handleRequests () {
	if ($this->enable) { 
	  set_error_handler("pdb_error_handler");
	  register_shutdown_function("pdb_shutdown");
	  parent::handleRequests(); 
	  if (PDB_DEBUG) pdb_Logger::debug( "exit({$this->status})");
	  exit ($this->status); }
  }
  public function hasBreakpoint($scriptName, $line) {
	if ($this->breakFirstLine) {$this->breakFirstLine = false; return true;}

    if ($this->currentFrame->stepNext) return true;

    foreach ($this->breakpoints as $breakpoint) {
      if($breakpoint->type==1) {
		if ($breakpoint->file==$scriptName&&$breakpoint->line==$line) return true;
      }
    }

    return false;
  }
  function parseCode($filename, $contents) {
	$parser = new pdb_Parser($filename, $contents);
	return $parser->parseScript();
  }

  public function __toString() {
    return "pdb_DebugSessionStart: {$this->currentFrame->filename}";
  }
}


/**
 * @@access private
 */
class pdb_HeaderOutputNotification extends pdb_Message {
  const TYPE = 2008;
  private $out;

  public function setOutput($out) {
    $this->out = $out;
  }
  protected function getAsciiOutput() {
    return $this->out;
  }
  protected function getEncodedOutput () {
    return $this->out; //FIXME
  }
  protected function getOutput() {
    return $this->getAsciiOutput();
  }
  public function getType() {
    return self::TYPE;
  }

  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeString($this->getOutput());
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_HeaderOutputNotification: ".$this->getOutput();
  }
}

/**
 * @@access private
 */
class pdb_OutputNotification extends pdb_HeaderOutputNotification {
  const TYPE = 2004;

  public function getType() {
    return self::TYPE;
  }
  protected function getOutput() {
    return $this->getEncodedOutput();
  }
  public function __toString () {
    return "pdb_OutputNotification: ".$this->getAsciiOutput();
  }
}

/**
 * @@access private
 */
class pdb_ErrorNotification extends pdb_Message {
  const TYPE = 2006;
  private $type, $filename, $lineno, $error;

  public function getType() {
    return self::TYPE;
  }
  public function setError($type, $filename, $lineno, $error) {
	$this->type = $type;
	$this->filename = $filename;
	$this->lineno = $lineno;
	$this->error = $error;
  }

  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt($this->type);
	$out->writeString($this->filename);
	$out->writeInt($this->lineno);
	$out->writeString($this->error);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_ErrorNotification: {$this->error} at {$this->filename} line {$this->lineno}";
  }
}

/**
 * @@access private
 */
class pdb_DebugScriptEndedNotification extends pdb_Message {
  const TYPE = 2002;

  public function getType() {
    return self::TYPE;
  }

  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeShort($this->session->status);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_DebugScriptEndedNotification: {$this->session->status}";
  }
}


/**
 * @@access private
 */
class pdb_ReadyNotification extends pdb_Message {
  const TYPE = 2003;
  
  public function getType() {
    return self::TYPE;
  }

  protected function handleStep($message) {
    return true;
  }

  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeString($this->session->currentFrame->filename);
    $out->writeInt($this->session->currentFrame->line);
    $out->writeInt(0);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_ReadyNotification: {$this->session->currentFrame->filename}, {$this->session->currentFrame->line}";
  }
}

/**
 * @@access private
 */
class pdb_SetProtocolRequest extends pdb_MessageRequest {
  const TYPE = 10000;
  public $id;
  public $protocolId;
  
  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    $in = $this->session->in;
    $this->id = $in->readInt();
    $this->protocolId = $in->readInt();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function ack() {
    $res = new pdb_SetProtocolResponse($this);
    $res->serialize();
  }
  public function __toString () {
    return "pdb_SetProtocolRequest: ". $this->protocolId;
  }
}

/**
 * @@access private
 */
class pdb_SetProtocolResponse extends pdb_Message {
  const TYPE = 11000;
  private $req;
  
  public function __construct ($req) {
    parent::__construct($req->session);
    $this->req = $req;
  }

  public function getType() {
    return self::TYPE;
  }
  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt($this->req->id);

    // use fixed id instead of $out->writeInt($this->req->protocolId);
	$out->writeInt(2006040705);

    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_SetProtocolResponse: ";
  }
}

/**
 * @@access private
 */
class pdb_StartRequest extends pdb_MessageRequest {
  const TYPE = 1;
  public $id;
  public $protocolId;
  
  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    $in = $this->session->in;
    $this->id = $in->readInt();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }

  public function ack() {
    $res = new pdb_StartResponse($this);
    $res->serialize();
  }
  public function __toString () {
    return "pdb_StartRequest: ";
  }
}

/**
 * @@access private
 */
class pdb_StartResponse extends pdb_Message {
  const TYPE = 1001;
  private $req;
  
  public function __construct ($req) {
    parent::__construct($req->session);
    $this->req = $req;
  }

  public function getType() {
    return self::TYPE;
  }
  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt($this->req->id);
    $out->writeInt(0);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_StartResponse: ";
  }
}
/**
 * @@access private
 */
class pdb_StartProcessFileNotification extends pdb_Message {
  const TYPE = 2009;
  public function __construct ($session) {
    parent::__construct($session);
  }
  protected function handleContinueProcessFile($message) {
    return true; // next
  }
  public function getType() {
    return self::TYPE;
  }
  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeString($this->session->currentFrame->filename);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_StartProcessFileNotification: {$this->session->currentFrame->filename}";
  }
}

/**
 * @@access private
 */
class pdb_ContinueProcessFileNotification extends pdb_Message {
  const TYPE = 2010;
  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_ContinueProcessFileNotification: ";
  }
}

/**
 * @@access private
 */
class pdb_Breakpoint {
  public $type, $lifeTime, $file, $line, $condition;
  private $id;

  public function __construct($type, $lifeTime, $file, $line, $condition, $id) {
    $this->type = $type;
    $this->lifeTime = $lifeTime;
    $this->file = $file;
    $this->line = $line;
    $this->condition = $condition;
    $this->id = $id;
  }
  public function __toString () {
    return "pdb_Breakpoint: ";
  }
}
/**
 * @@access private
 */
class pdb_AddBreakpointResponse extends pdb_Message {
  const TYPE = 1021;
  private $req;
  private $id;

  private static function getId() {
    static $id = 0;
    return ++$id;
  }

  public function __construct($req) {
    parent::__construct($req->session);
    $this->req = $req;
    $this->id = self::getId();
    $this->session->breakpoints[$this->id] = new pdb_Breakpoint($req->type, $req->lifeTime, $req->file, $req->line, $req->condition, $this->id);
  }

  public function getType() {
    return self::TYPE;
  }
  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt($this->req->id);
    $out->writeInt(0);
    $out->writeInt($this->id);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_AddBreakpointResponse: {$this->id}";
  }
}

/**
 * @@access private
 */
class pdb_RemoveBreakpointResponse extends pdb_Message {
  const TYPE = 1022;
  private $req;
  private $id;
  private $failure;

  public function __construct($req) {
    parent::__construct($req->session);
    $this->req = $req;

	$this->remove();
  }

  protected function remove() {
	if (isset($this->session->breakpoints[$this->req->bpId])) {
	  unset($this->session->breakpoints[$this->req->bpId]);
	  $this->failure = 0;
	} else {
	  $this->failure = -1;
	}
  }

  public function getType() {
    return self::TYPE;
  }
  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt($this->req->id);
    $out->writeInt($this->failure);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_RemoveBreakpointResponse: {$this->id}";
  }
}
/**
 * @@access private
 */
class pdb_RemoveAllBreakpointsResponse extends pdb_RemoveBreakpointResponse {
  const TYPE = 1023;
  public function __construct($req) {
    parent::__construct($req);
  }

  protected function remove() {
	$keys = array_keys($this->session->breakpoints);
	foreach($keys as $key)
	  unset($this->session->breakpoints[$key]);
	
	$this->failure = 0;
  }

  public function getType() {
    return self::TYPE;
  }

  public function __toString () {
    return "pdb_RemoveAllBreakpoinstResponse: {$this->id}";
  }
}

/**
 * @@access private
 */
class pdb_AddBreakpointRequest extends pdb_MessageRequest {
  const TYPE = 21;
  public $id;
  public $type;
  public $lifeTime;

  public $file;
  public $line;

  public $condition;

  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    $in = $this->session->in;
    $this->id = $in->readInt();
    $this->type = $in->readShort();
    $this->lifeType = $in->readShort();
    switch($this->type) {
    case 1: 
      $this->file = $in->readString();
      $this->line = $in->readInt();
      break;
    case 2:
      $this->condition = $in->readString();
      break;
    default: 
      trigger_error("invalid breakpoint", E_USER_ERROR);
    }
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function ack() {
    $res = new pdb_AddBreakpointResponse ($this);
    $res->serialize();
  }
  public function __toString () {
    if ($this->type == 1) 
      return "pdb_AddBreakpointRequest: {$this->file}, {$this->line}";
    else
      return "pdb_AddBreakpointRequest: {$this->condition}";
  }
}
/**
 * @@access private
 */
class pdb_RemoveAllBreakpointsRequest extends pdb_MessageRequest {
  const TYPE = 23;
  public $id;

  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    $in = $this->session->in;
    $this->id = $in->readInt();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function ack() {
    $res = new pdb_RemoveAllBreakpointsResponse ($this);
    $res->serialize();
  }
  public function __toString () {
	return "pdb_RemoveAllBreakpointsRequest ";
  }
}
/**
 * @@access private
 */
class pdb_RemoveBreakpointRequest extends pdb_RemoveAllBreakpointsRequest {
  const TYPE = 22;
  public $bpId;

  public function getType() {
    return self::TYPE;
  }

  public function deserialize() {
	parent::deserialize();
    $in = $this->session->in;
    $this->bpId = $in->readInt();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function ack() {
    $res = new pdb_RemoveBreakpointResponse ($this);
    $res->serialize();
  }
  public function __toString () {
	return "pdb_RemoveBreakpointRequest: {$this->bpId}";
  }
}

/**
 * @@access private
 */
class pdb_GetCallStackResponse extends pdb_Message {
  const TYPE = 1034;
  private $req;

  public function __construct($req) {
    parent::__construct($req->session);
    $this->req = $req;
  }

  public function getType() {
    return self::TYPE;
  }
  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt($this->req->id);
	for($frame=$this->session->currentFrame; $frame; $frame=$frame->parent)
	  $environments[] = $frame;

	$environments = array_reverse($environments);
    $n = count($environments);

    $out->writeInt($n);
    $out->writeInt(0);
    $out->writeInt(-1);
    $out->writeInt(0);

    for ($i=0; $i<$n; $i++) {
      if ($i>0) {
		$env = $environments[$i-1];
		$out->writeString($env->filename);
		$out->writeInt($env->line);
		$out->writeInt(0);
      }
	  $env = $environments[$i];
      $out->writeString($env->filename);
      $out->writeInt($env->firstLine);
      $out->writeInt(0);
	  
      $out->writeInt(0);
    }
	$out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_GetCallStackResponse: ";
  }
}
/**
 * @@access private
 */
class pdb_GetCallStackRequest extends pdb_MessageRequest {
  const TYPE = 34;
  public $id;
	
  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    $in = $this->session->in;
    $this->id = $in->readInt();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function ack() {
    $res = new pdb_GetCallStackResponse ($this);
    $res->serialize();
  }
  public function __toString () {
    return "pdb_GetCallStackRequest: ";
  }
}


/**
 * @@access private
 */
class pdb_GetCWDResponse extends pdb_Message {
  const TYPE = 1036;
  private $req;

  public function __construct ($req) {
    parent::__construct($req->session);
    $this->req = $req;
  }

  public function getType() {
    return self::TYPE;
  }
  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt($this->req->id);
    $out->writeInt(0);
    $out->writeString(getcwd());    
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_GetCWDResponse: ";
  }
}

/**
 * @@access private
 */
class pdb_GetCWDRequest extends pdb_MessageRequest {
  const TYPE = 36;
  public $id;

  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    $in = $this->session->in;
    $this->id = $in->readInt();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function ack() {
    $res = new pdb_GetCWDResponse($this);
    $res->serialize();
  }
  public function __toString () {
    return "pdb_GetCWDRequest: ";
  }
}

/**
 * @@access private
 */
class pdb_GetVariableValueResponse extends pdb_Message {
  const TYPE = 1032;
  private $req;

  public function __construct ($req) {
    parent::__construct($req->session);
    $this->req = $req;
  }

  public function getType() {
    return self::TYPE;
  }

  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt($this->req->id);
    if (PDB_DEBUG) pdb_Logger::debug( "evalcode:::".$this->req->code."\n");
	$error = 0;
    if ($this->req->code[0]=='$') {

	  $this->session->end = true;
	  $key = substr($this->req->code, 1);
	  if (isset($this->session->currentFrame->vars[$key])) {
		$var = $this->session->currentFrame->vars[$key];
		$paths = $this->req->paths;
		foreach ($paths as $path) {
		  if (is_object($var)) {
			$var = $var->$path;
		  } else {
			$var = $var[$path];
		  }
		}
	  } else {
		$var = "${key} not found!";
		$error = -1;
	  }
	  $ser = $this->session->serializer->serialize($var, $this->req->depth);
	  $this->session->end = false;

	  $out->writeInt($error);
      $out->writeString($ser);
	  if (PDB_DEBUG) pdb_Logger::debug("pdb_GetVariableValueResponse: ".print_r($var, true).": ${ser}, error: ${error}");
    } else {
	  if (PDB_DEBUG) pdb_Logger::debug(print_r($this->session->currentFrame->vars, true));

	  $this->session->end = true;
	  $vars = $this->session->currentFrame->vars;
	  $ser = $this->session->serializer->serialize($vars, $this->req->depth);
	  $this->session->end = false;

	  $out->writeInt($error);
	  $out->writeString($ser);
	  if (PDB_DEBUG) pdb_Logger::debug("pdb_GetVariableValueResponse: ".print_r($vars, true).": ${ser}, error: ${error}");
	}
    $out->flush();
  }
  public function __toString () {
    return "pdb_GetVariableValueResponse: ";
  }
}

/**
 * @@access private
 */
class pdb_GetVariableValueRequest extends pdb_MessageRequest {
  const TYPE = 32;
  public $id;
  public $code;
  public $depth;
  public $paths;

  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    $in = $this->session->in;
    $this->id = $in->readInt();
    $this->code = $in->readString();
    $this->depth = $in->readInt();

    $this->paths = array();
    $length = $in->readInt();
    while($length--) {
      $this->paths[] = $in->readString();
    }
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function ack() {
    $res = new pdb_GetVariableValueResponse($this);
    $res->serialize();
  }
  public function __toString () {
    return "pdb_GetVariableValueRequest: {$this->code}, {$this->depth}, paths::".print_r($this->paths, true);
  }
}

/**
 * @@access private
 */
class pdb_StepOverResponse extends pdb_Message {
  const TYPE = 1012;
  private $req;

  public function __construct($req) {
    parent::__construct($req->session);
    $this->req = $req;
  }

  public function getType() {
    return self::TYPE;
  }
  public function serialize() {
    $out = $this->req->session->out;
    parent::serialize();
    $out->writeInt($this->req->id);
    $out->writeInt(0);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_StepOverResponse: ";
  }
}

/**
 * @@access private
 */
class pdb_StepOverRequest extends pdb_MessageRequest {
  const TYPE = 12;
  public $id;
  
  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    $in = $this->session->in;
    $this->id = $in->readInt();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function ack() {
    $res = new pdb_StepOverResponse($this);
    $res->serialize();
  }
  public function __toString () {
    return "pdb_StepOverRequest: ";
  }
}

/**
 * @@access private
 */
class pdb_StepIntoResponse extends pdb_StepOverResponse {
  const TYPE = 1011;
  public function getType() {
    return self::TYPE;
  }
  public function __toString () {
    return "pdb_StepIntoResponse: ";
  }
}

/**
 * @@access private
 */
class pdb_StepIntoRequest extends pdb_StepOverRequest {
  const TYPE = 11;
  public function getType() {
    return self::TYPE;
  }
  public function ack() {
    $res = new pdb_StepIntoResponse($this);
    $res->serialize();
  }
  public function __toString () {
    return "pdb_StepIntoRequest: ";
  }
}

/**
 * @@access private
 */
class pdb_StepOutResponse extends pdb_StepOverResponse {
  const TYPE = 1013;
  public function getType() {
    return self::TYPE;
  }
  public function __toString () {
    return "pdb_StepOutResponse: ";
  }
}

/**
 * @@access private
 */
class pdb_StepOutRequest extends pdb_StepOverRequest {
  const TYPE = 13;
  public function getType() {
    return self::TYPE;
  }
  public function ack() {
    $res = new pdb_StepOutResponse($this);
    $res->serialize();
  }
  public function __toString () {
    return "pdb_OutIntoRequest: ";
  }
}

/**
 * @@access private
 */
class pdb_GoResponse extends pdb_Message {
  const TYPE = 1014;
  private $req;

  public function __construct ($req) {
    parent::__construct($req->session);
    $this->req = $req;
  }

  public function getType() {
    return self::TYPE;
  }
  public function serialize() {
    $out = $this->session->out;
    parent::serialize();
    $out->writeInt($this->req->id);
    $out->writeInt(0);
    $out->flush();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_GoResponse: ";
  }
}

/**
 * @@access private
 */
class pdb_GoRequest extends pdb_MessageRequest {
  const TYPE = 14;
  public $id;
 
  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    $in = $this->session->in;
    $this->id = $in->readInt();
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function ack() {
    $res = new pdb_GoResponse($this);
    $res->serialize();
  }
  public function __toString () {
    return "pdb_GoRequest: ";
  }
}
/**
 * @@access private
 */
class pdb_End extends pdb_Message {
  const TYPE = 3;
  public $id;
 
  public function getType() {
    return self::TYPE;
  }
  public function deserialize() {
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
  }
  public function __toString () {
    return "pdb_End: ";
  }
}

/**
 * @@access private
 */
class pdb_In {
  private $in;
  private $len;
  private $session;

  public function __construct($in, $session) {
    $this->in = $in;
    $this->len = 0;
	$this->session = $session;
  }
  private function readBytes($n) {
    $str = "";
    while ($n) {
      $s = fread($this->in, $n);
	  if (feof($this->in)) $this->session->end();

      $n -= strlen($s);

      $str.=$s;
    }
    return $str;
  }
  public function read() {
    if(!$this->len) {
      $str = $this->readBytes(4);
      $lenDesc = unpack("N", $str);
      $this->len = array_pop($lenDesc);
    }
  }
  public function readShort() {
    $this->read();

    $this->len-=2;
    $str = $this->readBytes(2);
    $lenDesc = unpack("n", $str);
    return array_pop($lenDesc);
  }
  public function readInt() {
    $this->read();

    $this->len-=4;
    $str = $this->readBytes(4);
    $lenDesc = unpack("N", $str);
    return array_pop($lenDesc);
  }
  public function readString() {
    $this->read();

    $length = $this->readInt();
    $this->len-=$length;
    return $this->readBytes($length);
  }
  public function __toString () {
    return "pdb_In: ";
  }
}
/**
 * @@access private
 */
class pdb_Out {
  private $out;
  private $buf;
  private $session;
  
  public function __construct($out, $session) {
    $this->out = $out;
    $this->buf = "";
	$this->session = $session;
  }

  public function writeShort($val) {
    $this->buf.=pack("n", $val);
  }
  public function writeInt($val) {
    $this->buf.=pack("N", $val);
  }
  public function writeString($str) {
    $length = strlen($str);
    $this->writeInt($length);
    $this->buf.=$str;
  }
  public function writeUTFString($str) {
    $this->writeString(urlencode($str));
  }
  public function flush() {
    $length = strlen($this->buf);
    $this->buf = pack("N", $length).$this->buf;
    fwrite($this->out, $this->buf);
	if (feof($this->out)) $this->session->end();
    $this->buf = "";
  }
  public function __toString () {
    return "pdb_Out: ";
  }
}
$pdb_dbg = new pdb_DebugSessionStart("&debug_fastfile=1");
pdb_Message::register(new pdb_SetProtocolRequest($pdb_dbg));
pdb_Message::register(new pdb_StartRequest($pdb_dbg));
pdb_Message::register(new pdb_ContinueProcessFileNotification($pdb_dbg));
pdb_Message::register(new pdb_AddBreakpointRequest($pdb_dbg));
pdb_Message::register(new pdb_RemoveBreakpointRequest($pdb_dbg));
pdb_Message::register(new pdb_RemoveAllBreakpointsRequest($pdb_dbg));
pdb_Message::register(new pdb_GetCallStackRequest($pdb_dbg));
pdb_Message::register(new pdb_GetCWDRequest($pdb_dbg));
pdb_Message::register(new pdb_GetVariableValueRequest($pdb_dbg));
pdb_Message::register(new pdb_StepOverRequest($pdb_dbg));
pdb_Message::register(new pdb_StepIntoRequest($pdb_dbg));
pdb_Message::register(new pdb_StepOutRequest($pdb_dbg));
pdb_Message::register(new pdb_GoRequest($pdb_dbg));
pdb_Message::register(new pdb_End($pdb_dbg));

pdb_Message::register(new pdb_StartProcessFileNotification($pdb_dbg));
pdb_Message::register(new pdb_ReadyNotification($pdb_dbg));
pdb_Message::register(new pdb_DebugScriptEndedNotification($pdb_dbg));
pdb_Message::register(new pdb_HeaderOutputNotification($pdb_dbg));
pdb_Message::register(new pdb_OutputNotification($pdb_dbg));
pdb_Message::register(new pdb_ErrorNotification($pdb_dbg));

/**
 * @@access private
 */
function pdb_getDefinedVars($vars1, $vars2) {
  //if(isset($vars2)) $vars1['pbd_This'] = $vars2;

  unset($vars1['__pdb_Code']);	     // see pdb_Message::doEval()

  return $vars1;   
}
/**
 * @@access private
 */
function pdb_startCall($scriptName, $line) {
  global $pdb_dbg;

  $stepNext = $pdb_dbg->currentFrame->stepNext == pdb_StepIntoRequest::TYPE ? pdb_StepIntoRequest::TYPE : false;

  pdb_Logger::debug("startCall::$scriptName, $stepNext");

  $env = new pdb_Environment($pdb_dbg->currentFrame, $scriptName, $stepNext, $line);
  $pdb_dbg->allFrames[] = $env;

  return $env;
}

/**
 * @@access private
 */
function pdb_startInclude($scriptName, $once) {
  global $pdb_dbg;

  $scriptName = $pdb_dbg->resolveIncludePath($scriptName);

  // include only from a top-level environment
  // initial line# and vars may be wrong due to a side-effect in step
  $pdb_dbg->session->currentFrame = $pdb_dbg->session->currentTopLevelFrame;

  $stepNext = $pdb_dbg->currentFrame->stepNext == pdb_StepIntoRequest::TYPE ? pdb_StepIntoRequest::TYPE : false;
  $pdb_dbg->currentFrame = new pdb_Environment($pdb_dbg->currentFrame, $scriptName, $stepNext, 1);
  $pdb_dbg->allFrames[] = $pdb_dbg->currentFrame;

  /* BEGIN: StartProcessFileNotification */
  $pdb_dbg->getMessageById(pdb_StartProcessFileNotification::TYPE)->handleRequests();
  /* ...  set breakpoints ... */
  /* END: ContinueProcessFileNotification */

  if ($once && isset($pdb_dbg->includedScripts[$scriptName]))
	$code = "<?php ?>";
  else
	$code = $pdb_dbg->parseCode(realpath($scriptName), file_get_contents($scriptName));

  $pdb_dbg->currentTopLevelFrame = $pdb_dbg->currentFrame;

  if (PDB_DEBUG) pdb_Logger::debug("include:::$code");

  if ($once) $pdb_dbg->includedScripts[$scriptName] = true;
  return $code; // eval -> pdb_step/MSG_READY or pdb_endInclude/MSG_READY OR FINISH
}
/**
 * @@access private
 */
function pdb_endInclude() {
  global $pdb_dbg;

  $pdb_dbg->currentFrame = $pdb_dbg->currentTopLevelFrame = $pdb_dbg->currentTopLevelFrame->parent;
}


/**
 * @@access private
 */
function pdb_step($filename, $line, $vars) {
  global $pdb_dbg;
  if ($pdb_dbg->ignoreInterrupt) return;

  $pdb_dbg->ignoreInterrupt = true;

  // pull the current frame from the stack or the top-level environment
  $pdb_dbg->currentFrame = (isset($vars['__pdb_CurrentFrame'])) ? $vars['__pdb_CurrentFrame'] : $pdb_dbg->currentTopLevelFrame;
  unset($vars['__pdb_CurrentFrame']);

  $pdb_dbg->currentFrame->update($line, $vars);

  if ($pdb_dbg->hasBreakpoint($filename, $line)) {
	$pdb_dbg->flushOutput();
	$stepNext = $pdb_dbg->getMessageById(pdb_ReadyNotification::TYPE)->handleRequests();
	pdb_Logger::logDebug("continue");
	/* clear all dynamic breakpoints */
	foreach ($pdb_dbg->allFrames as $currentFrame)
	  $currentFrame->stepNext = false;

	/* set new dynamic breakpoint */
	if ($stepNext != pdb_GoRequest::TYPE) {
	  $currentFrame = $pdb_dbg->currentFrame;

	  /* break in current frame or frame below */
	  if ($stepNext != pdb_StepOutRequest::TYPE)
		$currentFrame->stepNext = $stepNext;

	  /* or break in any parent */
	  while ($currentFrame = $currentFrame->parent) {
		$currentFrame->stepNext = $stepNext;
	  }
	}
  }
  $pdb_dbg->ignoreInterrupt = false;
}

/**
 * @@access private
 */
function pdb_error_handler($errno, $errstr, $errfile, $errline) {
  global $pdb_dbg;
  if (PDB_DEBUG) pdb_Logger::debug("PHP error $errno: $errstr in $errfile line $errline");
  if ($pdb_dbg->end) return false;

  $msg = $pdb_dbg->getMessageById(pdb_ErrorNotification::TYPE);
  $msg->setError($errno, $errfile, $errline, $errstr);
  $msg->serialize();
  return true;
}

/**
 * @@access private
 */
function pdb_shutdown() {
  global $pdb_dbg;
  if (PDB_DEBUG) pdb_Logger::debug("PHP error: ".print_r(error_get_last(), true));
  if ($pdb_dbg->end) return;

  $error = error_get_last();
  if ($error) {
	$msg = $pdb_dbg->getMessageById(pdb_ErrorNotification::TYPE);
	$msg->setError($error['type'], $error['file'], $error['line'], $error['message']);
	$msg->serialize();
  }
}

$pdb_dbg->handleRequests();

?>
@


1.13
log
@php 7
@
text
@@


1.12
log
@Release-6-1-2-1
@
text
@d80 1
a80 1
	public function pdb_Parser($scriptName, $content) {
d530 1
a530 1
  public function pdb_Environment($parent, $filename, $stepNext, $firstLine) {
d555 1
a555 1
  public function pdb_Message($session) {
d764 2
a765 2
  public function pdb_DebugSessionStart($options) {
    parent::pdb_Message($this);
d1044 2
a1045 2
  public function pdb_SetProtocolResponse ($req) {
    parent::pdb_Message($req->session);
d1101 2
a1102 2
  public function pdb_StartResponse ($req) {
    parent::pdb_Message($req->session);
d1126 2
a1127 2
  public function pdb_StartProcessFileNotification ($session) {
    parent::pdb_Message($session);
d1170 1
a1170 1
  public function pdb_Breakpoint($type, $lifeTime, $file, $line, $condition, $id) {
d1195 2
a1196 2
  public function pdb_AddBreakpointResponse($req) {
    parent::pdb_Message($req->session);
d1228 2
a1229 2
  public function pdb_RemoveBreakpointResponse($req) {
    parent::pdb_Message($req->session);
d1264 2
a1265 2
  public function pdb_RemoveAllBreakpointsResponse($req) {
    parent::pdb_RemoveBreakpointResponse($req);
d1387 2
a1388 2
  public function pdb_GetCallStackResponse($req) {
    parent::pdb_Message($req->session);
d1463 2
a1464 2
  public function pdb_GetCWDResponse ($req) {
    parent::pdb_Message($req->session);
d1516 2
a1517 2
  public function pdb_GetVariableValueResponse ($req) {
    parent::pdb_Message($req->session);
d1616 2
a1617 2
  public function pdb_StepOverResponse($req) {
    parent::pdb_Message($req->session);
d1728 2
a1729 2
  public function pdb_GoResponse ($req) {
    parent::pdb_Message($req->session);
d1798 1
a1798 1
  public function pdb_In($in, $session) {
d1857 1
a1857 1
  public function pdb_Out($out, $session) {
@


1.11
log
@Release-6-1-2-1
@
text
@d3 2
a4 2
  /*
   * PHPDebugger.inc version 1.0 -- A PHP debugger for Eclipse for PHP Developers
d26 2
a27 8
   */


set_time_limit (0);
define ("PDB_DEBUG", 0);

  /**
   * Quick Installation:
d31 1
a31 2
   * 1. Open your project in PHP explorer and drag and drop this file
   * to the PHP project folder.
d33 1
a33 5
   * 2. Activate the PHPDebugger in your php.ini file. For example:
   * Open Menu/Project/Properties, open "PHP Debug", select "Enable
   * Project specific settings", select "Zend Debugger" if not already
   * selected, click on "PHP executables ...", then "Edit" and select
   * a php.ini file with at least the following content:
d35 2
a36 1
   * ;; activate the PHPDebugger in the php.ini file
d38 1
d40 1
a41 1
   * 3. Debug your PHP scripts as usual. 
d43 7
d52 5
d367 1
d371 1
a388 1

d397 1
a397 1
			if ($this->nextTokenIs(array(T_ELSE, T_ELSEIF))) {
a419 1
			$this->writeNext();
d421 2
d426 1
d480 1
a480 1
  private static $logFileName = "/tmp/pdb_PHPDebugger.inc.log";
d486 3
@


1.10
log
@Release-6-1-2-1
@
text
@d750 1
a750 1
  private $includedScripts;
d1931 1
a1931 1
function pdb_startInclude($filename, $once) {
d1934 1
a1934 1
  $filename = $pdb_dbg->resolveIncludePath($filename);
d1938 1
a1938 1
  $this->session->currentFrame = $this->session->currentTopLevelFrame;
d1941 1
a1941 1
  $pdb_dbg->currentFrame = new pdb_Environment($pdb_dbg->currentFrame, $filename, $stepNext, 1);
d1949 1
a1949 1
  if ($once && isset($this->includedScripts[$scriptName]))
d1952 1
a1952 1
	$code = $pdb_dbg->parseCode(realpath($filename), file_get_contents($filename));
d1958 1
a1958 1
  if ($once) $this->includedScripts[$scriptName] = true;
@


1.9
log
@Release-6-1-2-1
@
text
@d63 1
d112 1
a112 1
	private function writeInclude() {
d127 1
a127 1
		$this->write("eval('?>'.pdb_startInclude($name)); pdb_endInclude();");
d142 1
a142 1
	  $this->write("\$__pdb_CurrentFrame=pdb_startCall(\"$scriptName\", $this->currentLine);");
d229 3
d249 1
a249 1
		  if (!$pLevel && $type==self::BLOCK && $token=='}') $this->writeStep($pLevel);
d304 1
a304 1
			$this->parseBlock();
d401 2
a403 1
		  case T_INCLUDE_ONCE: 
a404 1
		  case T_REQUIRE_ONCE: // FIXME: implement require and _once
d406 1
a406 1
			$this->writeInclude();
d750 2
d784 1
d1931 1
a1931 1
function pdb_startInclude($filename) {
d1935 5
d1949 4
a1952 1
  $code = $pdb_dbg->parseCode(realpath($filename), file_get_contents($filename));
d1957 2
@


1.8
log
@Release-6-1-2-1
@
text
@d94 1
a94 1
		  $this->currentLine = $cur[2];
d152 1
a152 1
		  $this->write(";pdb_step(\"$scriptName\", $line, pdb_getDefinedVars(get_defined_vars()));");
d245 1
d299 2
d1898 2
a1899 1
function pdb_getDefinedVars($vars1) {
@


1.7
log
@Release-6-1-2-1
@
text
@d407 11
a657 1
  private $visited;
a659 13
  private function serializeRef(&$r) {
    $serial = &$this->serial;

    foreach($this->visited as $k=>$v) {
      if ($v===$r) {
		$serial.="r:";
		$serial.=$k+1;
		$serial.=";";
		return true;
      }
    }
    die("ref not found");
  }
a664 5
      if (in_array($o, $this->visited)) {
		$this->serializeRef($o);
		return;
      }

a670 1
      $this->visited[] = $o;
a706 1
    $this->visited = array();
a1496 2
  private $visited;

a1512 1
	  if (PDB_DEBUG) pdb_Logger::debug(print_r($this->session->currentFrame->vars, true));
d1518 8
d1535 1
d1546 1
a1548 1
    if (PDB_DEBUG) pdb_Logger::debug( "$this");
d1574 1
a1574 1
    $paths = array();
@


1.6
log
@Release-6-1-2-1
@
text
@d38 1
a38 1
   * to PHP project folder.
d141 1
a141 1
	  $this->write("\$__pdb_CurrentFrame=pdb_startCall(\"$scriptName\");");
d147 1
a147 1
		$lastLine = $this->line = $this->currentLine;
d150 1
a150 1
		  $this->write(";STEP($lastLine);");
d152 1
a152 1
		  $this->write(";pdb_step(\"$scriptName\", $lastLine, pdb_getDefinedVars(get_defined_vars()));");
d500 1
a500 1
  public $vars, $line;
d503 1
a503 1
  public function pdb_Environment($parent, $filename, $stepNext) {
d507 1
d516 1
a516 1
	return "pdb_Environment: {$this->filename}, {$this->line}";
d782 1
a782 1
	$this->currentTopLevelFrame = $this->currentFrame = new pdb_Environment(null, $filename, false);
d1403 3
a1405 2
		$out->writeString($environments[$i-1]->filename);
		$out->writeInt($environments[$i-1]->line); //FIXME
d1408 3
a1410 2
      $out->writeString($environments[$i]->filename);
      $out->writeInt($environments[$i]->line); //FIXME
d1908 1
a1908 1
function pdb_startCall($scriptName) {
d1915 1
a1915 1
  $env = new pdb_Environment($pdb_dbg->currentFrame, $scriptName, $stepNext);
d1929 1
a1929 1
  $pdb_dbg->currentFrame = new pdb_Environment($pdb_dbg->currentFrame, $filename, $stepNext);
@


1.5
log
@Release-6-1-2-1
@
text
@d32 21
a52 20
/**
 * Quick Installation:
 *
 * Install "Eclipse for PHP Developers" version >= 3.5.2
 * 
 * 1. Open your project in PHP explorer and drag and drop this file to the
 * "PHP Include Path"
 *
 * 2. Open Menu/Project/Properties, open "PHP Debug", select "Enable
 * Project specific settings", select "Zend Debugger" if not already
 * selected, click on "PHP executables ...", then "Edit" and select
 * a php.ini file with at least the following content:
 *
 * ;; activate the PHPDebugger in the php.ini file
 * auto_prepend_file=PHPDebugger.inc
 *
 *
 * 3. Debug your PHP scripts as usual. 
 *
 */
d140 1
a140 1
	  $scriptName = $this->scriptName;
d148 1
a148 1
		$scriptName = $this->scriptName;
a1896 1
  //  if(isset($vars2)) $vars1['pbd_This'] = $vars2;
@


1.4
log
@fix for windows
@
text
@d29 1
d32 20
a51 21
  /**
   * Quick Installation:
   *
   * Install "Eclipse for PHP Developers" version >= 3.5.2
   * 
   * 1. Open your project in PHP explorer and drag and drop this file
   * to PHP project folder.
   *
   * 2. Activate the PHPDebugger in your php.ini file. For example:
   * Open Menu/Project/Properties, open "PHP Debug", select "Enable
   * Project specific settings", select "Zend Debugger" if not already
   * selected, click on "PHP executables ...", then "Edit" and select
   * a php.ini file with at least the following content:
   *
   * ;; activate the PHPDebugger in the php.ini file
   * auto_prepend_file=PHPDebugger.inc
   *
   *
   * 3. Debug your PHP scripts as usual. 
   *
   */
d139 1
a139 1
	  $scriptName = addslashes($this->scriptName);
d147 1
a147 1
		$scriptName = addslashes($this->scriptName);
d151 1
a151 1
		  $this->write(";pdb_step(\"$scriptName\", $lastLine, pdb_getDefinedVars(get_defined_vars(), (isset(\$this) ? \$this : NULL)));");
d643 83
d730 1
a730 1
  public $eof;
d749 2
d756 1
a756 1
	$this->eof = true;
d778 2
d786 1
a786 1
	$this->eof = false;
d792 2
a793 1
	$this->eof = true;
d838 1
d996 1
a996 1
    return "pdb_ReadyNotification: ";
d1503 2
d1513 1
a1517 1
    $out->writeInt(0);
d1519 28
a1546 4
    if ($this->req->code[0]=='$') 
      $out->writeString(serialize($this->session->currentFrame->vars[substr($this->req->code, 1)]));
    else
      $out->writeString(serialize($this->session->currentFrame->vars));
d1586 1
a1586 1
    return "pdb_GetVariableValueRequest: ";
d1788 1
a1788 1
	  if (feof($this->in)) $session->end();
d1862 1
a1862 1
	if (feof($this->out)) $session->end();
d1895 2
a1896 2
function pdb_getDefinedVars($vars1, $vars2) {
  if(isset($vars2)) $vars1['pbd_This'] = $vars2;
d1997 1
a1997 1
  if ($pdb_dbg->eof) return false;
d2011 1
a2011 1
  if ($pdb_dbg->eof) return;
@


1.3
log
@Release-6-1-2
@
text
@d31 21
a51 20
/**
 * Quick Installation:
 *
 * Install "Eclipse for PHP Developers" version >= 3.5.2
 * 
 * 1. Open your project in PHP explorer and drag and drop this file to the
 * "PHP Include Path"
 *
 * 2. Open Menu/Project/Properties, open "PHP Debug", select "Enable
 * Project specific settings", select "Zend Debugger" if not already
 * selected, click on "PHP executables ...", then "Edit" and select
 * a php.ini file with at least the following content:
 *
 * ;; activate the PHPDebugger in the php.ini file
 * auto_prepend_file=PHPDebugger.inc
 *
 *
 * 3. Debug your PHP scripts as usual. 
 *
 */
d139 1
a139 1
	  $scriptName = $this->scriptName;
d147 1
a147 1
		$scriptName = $this->scriptName;
@


1.2
log
@Release-6-1-2
@
text
@d3 2
a4 35
/*
 * PHPDebugger.inc version 1.0 -- A PHP debugger for Eclipse for PHP Developers
 *
 * Copyright (C) 2009,2010 Jost Boekemeier.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this file (the "Software"), to deal in the
 * Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


define ("PDB_DEBUG", 0);

  /**
   * Quick Installation:
   *
   * Install "Eclipse for PHP Developers" version >= 3.5.2
   * 
   * 1. Open your project in PHP explorer and drag and drop this file to the
   * PHP project
d6 1
a6 5
   * 2. Activate the PHPDebugger in your php.ini file:
   * Open Menu/Project/Properties, open "PHP Debug", select "Enable
   * Project specific settings", select "Zend Debugger" if not already
   * selected, click on "PHP executables ...", then "Edit" and select
   * a php.ini file with at least the following content:
d8 7
a14 2
   * ;; activate the PHPDebugger in the php.ini file
   * auto_prepend_file=PHPDebugger.inc
d16 2
d19 7
a25 2
   * 3. Debug your PHP scripts as usual. 
   *
d28 3
a30 1
if (!class_exists("pdb_Parser")) {
d32 18
a49 2
 * The PHP parser
 * @@access private
d51 2
a52 11
class pdb_Parser {
  const BLOCK = 1;
  const STATEMENT = 2;
  const EXPRESSION = 3;

  private $scriptName, $content;
  private $code;
  private $output;
  private $line, $currentLine;
  private $beginStatement, $inPhp, $inDQuote;
 
d54 1
a54 3
   * Create a new PHP parser
   * @@param string the script name
   * @@param string the script content
d57 62
a118 22
  public function pdb_Parser($scriptName, $content) {
	$this->scriptName = $scriptName;
	$this->content = $content;
	$this->code = token_get_all($content);
	$this->output = "";
	$this->line = $this->currentLine = 0;
	$this->beginStatement = $this->inPhp = $this->inDQuote = false;
  }

  private function toggleDQuote($chr) {
	if ($chr == '"') $this->inDQuote = !$this->inDQuote;
  }

  private function each() {
	$next = each ($this->code);
	if ($next) {
	  $cur = current($this->code);
	  if (is_array($cur)) {
		$this->currentLine = $cur[2];
		if ($this->isWhitespace($cur)) {
		  $this->write($cur[1]);
		  return $this->each();
d121 4
a124 2
	  else 
		$this->toggleDQuote($cur);
a125 2
	return $next;
  }
d127 10
a136 15
  private function write($code) {
	//echo "write:::".$code."\n";
	$this->output.=$code;
  }

  private function writeInclude() {
	$name = "";
	while(1) {
	  if (!$this->each()) die("parse error");
	  $val = current($this->code);
	  if (is_array($val)) {
		$name.=$val[1];
	  } else {
		if ($val==';') break;
		$name.=$val;
d138 2
a140 5
	if (PDB_DEBUG == 2) 
	  $this->write("EVAL($name);");
	else
	  $this->write("eval('?>'.pdb_startInclude($name)); pdb_endInclude();");
  }
d142 9
a150 9
  private function writeCall() {
	while(1) {
	  if (!$this->each()) die("parse error");
	  $val = current($this->code);
	  if (is_array($val)) {
		$this->write($val[1]);
	  } else {
		$this->write($val);
		if ($val=='{') break;
a152 3
	$scriptName = $this->scriptName;
	$this->write("\$__pdb_CurrentFrame=pdb_startCall(\"$scriptName\");");
  }
d154 5
a158 9
  private function writeStep($pLevel) {
	$token = current($this->code);
	if ($this->inPhp && !$pLevel && !$this->inDQuote && $this->beginStatement && !$this->isWhitespace($token) && ($this->line != $this->currentLine)) {
	  $lastLine = $this->line = $this->currentLine;
	  $scriptName = $this->scriptName;
	  if (PDB_DEBUG == 2)
		$this->write(";STEP($lastLine);");
	  else
		$this->write(";pdb_step(\"$scriptName\", $lastLine, pdb_getDefinedVars(get_defined_vars(), (isset(\$this) ? \$this : NULL)));");
a159 1
  }
d161 16
a176 19
  private function writeNext() {
	$this->next();
	$token = current($this->code);
	if (is_array($token)) $token = $token[1];
	$this->write($token);
  }

  private function nextIs($chr) {
	$i = 0;
	while(each($this->code)) {
	  $cur = current($this->code);
	  $i++;
	  if (is_array($cur)) {
		switch ($cur[0]) {
		case T_COMMENT:
		case T_DOC_COMMENT:
		case T_WHITESPACE:
		  break;	/* skip */
		default: 
d178 1
a178 1
		  return false;	/* not found */
a179 3
	  } else {
		while($i--) prev($this->code);
		return $cur == $chr;	/* found */
d181 2
a183 3
	while($i--) prev($this->code);
	return false;	/* not found */
  }
d185 17
a201 14
  private function nextTokenIs($ar) {
	$i = 0;
	while(each($this->code)) {
	  $cur = current($this->code);
	  $i++;
	  if (is_array($cur)) {
		switch ($cur[0]) {
		case T_COMMENT:
		case T_DOC_COMMENT:
		case T_WHITESPACE:
		  break;	/* skip */
		default: 
		  while($i--) prev($this->code);
		  return (in_array($cur[0], $ar));
a202 2
	  } else {
		break; /* not found */
d204 2
a206 3
	while($i--) prev($this->code);
	return false;	/* not found */
  }
d208 13
a220 8
  private function isWhitespace($token) {
	$isWhitespace = false;
	switch($token[0]) {
	case T_COMMENT:
	case T_DOC_COMMENT:
	case T_WHITESPACE:
	  $isWhitespace = true;
	  break;
a221 5
	return $isWhitespace;
  }
  private function next() {
	if (!$this->each()) trigger_error("parse error", E_USER_ERROR);
  }
d223 9
a231 9
  private function parseBlock () {
	$this->parse(self::BLOCK);
  }
  private function parseStatement () {
	$this->parse(self::STATEMENT);
  }
  private function parseExpression () {
	$this->parse(self::EXPRESSION);
  }
d233 2
a234 2
  private function parse ($type) {
	pdb_Logger::debug("parse:::$type");
d236 2
a237 2
	$this->beginStatement = true;
	$pLevel = 0;
d239 27
a265 25
	do {
	  $token = current($this->code);
	  if (!is_array($token)) {
		pdb_Logger::debug(":::".$token);
		$this->write($token);
		if ($this->inPhp && !$this->inDQuote) {
		  $this->beginStatement = false; 
		  switch($token) {
		  case '(': 
			$pLevel++;
			break;
		  case ')':
			if (!--$pLevel && $type==self::EXPRESSION) return;
			break;
		  case '{': 
			$this->next();
			$this->parseBlock(); 
			break;
		  case '}': 
			if (!$pLevel) return;
			break;
		  case ';':
			if (!$pLevel) {
			  if ($type==self::STATEMENT) return;
			  $this->beginStatement = true; 
a266 1
			break;
d268 2
a269 3
		}
	  } else {
		pdb_Logger::debug(":::".$token[1].":(".token_name($token[0]).')');
d271 4
a274 4
		if ($this->inDQuote) {
		  $this->write($token[1]);
		  continue;
		}
d276 1
a276 1
		switch($token[0]) {
d278 10
a287 26
		case T_OPEN_TAG: 
		case T_START_HEREDOC:
		case T_OPEN_TAG_WITH_ECHO: 
		  $this->beginStatement = $this->inPhp = true;
		  $this->write($token[1]);
		  break;

		case T_END_HEREDOC:
		case T_CLOSE_TAG: 
		  $this->writeStep($pLevel);

		  $this->write($token[1]);
		  $this->beginStatement = $this->inPhp = false; 
		  break;

		case T_FUNCTION:
		  $this->write($token[1]);
		  $this->writeCall();
		  $this->beginStatement = true;
		  break;

		case T_ELSE:
		  $this->write($token[1]);
		  if ($this->nextIs('{')) {
			$this->writeNext();
			$this->next();
d289 3
a291 3
			$this->parseBlock();
		  } else {
			$this->next();
d293 3
a295 2
			/* create an artificial block */
			$this->write('{');
d297 18
a314 3
			$this->writeStep($pLevel);
			$this->parseStatement();
			$this->write('}');
d316 2
a317 2
		  }
		  if ($type==self::STATEMENT) return;
d319 2
a320 2
		  $this->beginStatement = true;
		  break;
d322 23
a344 6
		case T_DO:
		  $this->writeStep($pLevel);
		  $this->write($token[1]);
		  if ($this->nextIs('{')) {
			$this->writeNext();
			$this->next();
d346 1
a346 1
			$this->parseBlock();
d348 1
d350 1
a350 2
		  } else {
			$this->next();
a351 2
			/* create an artificial block */
			$this->write('{');
d353 6
d360 2
a361 1
			$this->parseStatement();
a362 4
			$this->write('}');
		  }
		  $token = current($this->code);
		  $this->write($token[1]);
d364 1
a364 3
		  if ($token[0]!=T_WHILE) trigger_error("parse error", E_USER_ERROR);
		  $this->next();
		  $this->parseExpression();
d366 3
a368 1
		  if ($type==self::STATEMENT) return;
d370 1
a370 2
		  $this->beginStatement = true;
		  break;
a371 5
		case T_IF:
		case T_ELSEIF:
		case T_FOR:
		case T_WHILE:
		  $this->writeStep($pLevel);
d373 2
a374 2
		  $this->write($token[1]);
		  $this->next();
d376 7
a382 1
		  $this->parseExpression();
d384 7
a390 3
		  if ($this->nextIs('{')) {
			$this->writeNext();
			$this->next();
d392 6
a397 1
			$this->parseBlock();
d399 1
a400 5
		  } else {
			$this->next();

			/* create an artificial block */
			$this->write('{');
d402 1
a402 4
			$this->writeStep($pLevel);
			$this->parseStatement();
			$this->write('}');
		  }
d404 11
a414 1
		  if ($this->nextTokenIs(array(T_ELSE, T_ELSEIF))) {
d416 1
a416 5
		  } else {
			if ($type==self::STATEMENT) return;
			$this->beginStatement = true;
		  }
		  break;
d418 5
a422 31
		case T_INCLUDE: 
		case T_INCLUDE_ONCE: 
		case T_REQUIRE: 
		case T_REQUIRE_ONCE: // FIXME: implement require and _once
		  $this->writeStep($pLevel);
		  $this->writeInclude();

		  if ($type==self::STATEMENT) return;

		  $this->beginStatement = true;
		  break;

		case T_CLASS:
		case T_CASE:
		case T_DEFAULT:
		case T_PUBLIC:
		case T_PRIVATE:
		case T_PROTECTED:
		case T_STATIC:
		case T_CONST:
		case T_GLOBAL:
		case T_ABSTRACT:
		  $this->write($token[1]);
		  $this->beginStatement = false;
		  break;

		default:
		  $this->writeStep($pLevel);
		  $this->write($token[1]);
		  $this->beginStatement = false;
		  break;
d424 1
d426 2
a427 3
	  }
	} while($this->each());
  }
d429 9
a437 9
  /**
   * parse the given PHP script
   * @@return the parsed PHP script
   * @@access private
   */
  public function parseScript() {
	do {
	  $this->parseBlock();
	} while($this->each());
d439 2
a440 1
	return $this->output;
a442 1
}
d582 2
a583 2
	$message->ack();
	break;
d585 3
a587 3
	$message->ack();
	$this->getMessageById(pdb_StartProcessFileNotification::TYPE)->serialize();
	break;
d589 2
a590 2
	if ($this->handleContinueProcessFile($message)) return pdb_ContinueProcessFileNotification::TYPE;
	break;
d592 8
a599 2
	$message->ack();
	break;
d601 2
a602 2
	$message->ack();
	break;
d604 2
a605 2
	$message->ack();
	break;
d607 2
a608 2
	$message->ack();
	break;
d610 3
a612 3
	$message->ack();
	if ($this->handleGo($message)) return pdb_GoRequest::TYPE;
	break;
d614 3
a616 3
	$message->ack();
	if ($this->handleStep($message)) return pdb_StepOverRequest::TYPE;
	break;
d618 3
a620 3
	$message->ack();
	if ($this->handleStep($message)) return pdb_StepIntoRequest::TYPE;
	break;
d622 5
a626 3
	$message->ack();
	if ($this->handleStep($message)) return pdb_StepOutRequest::TYPE;
	break;
d646 1
d670 1
d698 8
a705 2
    $this->in =new pdb_In($io);
    $this->out=new pdb_Out($io);
a706 1

d715 1
a715 1
	ob_clean();
d1098 1
a1098 1
    $this->session->breakpoints[] = new pdb_Breakpoint($req->type, $req->lifeTime, $req->file, $req->line, $req->condition, $this->id);
d1121 66
d1230 48
d1312 1
a1312 1
		$out->writeInt(/*$environments[$i-1]->line*/1); //FIXME
d1316 1
a1316 1
      $out->writeInt(/*$environments[$i]->line*/1); //FIXME
d1661 1
d1663 1
a1663 1
  public function pdb_In($in) {
d1666 1
d1671 2
a1672 1
      if (feof($this->in)) trigger_error("read", E_USER_ERROR);
a1673 1
      $s = fread($this->in, $n);
d1720 1
d1722 1
a1722 1
  public function pdb_Out($out) {
d1725 1
d1746 1
d1758 2
d1820 2
d1860 1
a1860 1
		$currentFrame = $pdb_dbg->currentFrame;
d1862 8
a1869 8
		/* break in current frame or frame below */
		if ($stepNext != pdb_StepOutRequest::TYPE)
		  $currentFrame->stepNext = $stepNext;

		/* or break in any parent */
		while ($currentFrame = $currentFrame->parent) {
		  $currentFrame->stepNext = $stepNext;
		}
d1880 3
d1894 3
@


1.1
log
@Release-6-1-2
@
text
@d37 1
a37 1
   * "PHP Include Path"
d39 2
a40 1
   * 2. Open Menu/Project/Properties, open "PHP Debug", select "Enable
@

