head	1.62;
access;
symbols
	Release-5-5-4-1:1.61.0.8
	Root_Release-5-5-4-1:1.61
	Release-5-5-4:1.61.0.6
	Root_Release-5-5-4:1.61
	Release-5-5-3:1.61.0.4
	ROOT_Release-5-5-3:1.61
	Release-5-5-2:1.61.0.2
	Root_Release-5-5-2:1.61
	debian_version_5_5_1-1:1.61
	Release-5-5-1:1.60.0.60
	upstream_version_5_5_1:1.60
	ROOT_Release-5-5-1:1.60
	debian_version_5_5-1:1.60
	upstream_version_5_5:1.60
	ROOT_Release-5-5:1.60
	Release-5-5:1.60.0.62
	debian_version_5_4_4_2-3:1.60
	Release-5-4-4-2-1:1.60.0.56
	debian_version_5_4_4_2-2:1.60
	debian_version_5_4_4_2-1:1.60
	upstream_version_5_4_4_2:1.60
	debian_version_5_4_4_1-1:1.60
	upstream_version_5_4_4_1:1.60
	debian_version_5_4_4-1:1.60
	upstream_version_5_4_4:1.60
	Release-5-4-4:1.60.0.58
	Root_Release-5-4-4:1.60
	debian_version_5_4_3_2-1:1.60
	upstream_version_5_4_3_2:1.60
	Release_5-4-3-2:1.60.0.54
	Root_Release_5-4-3-2:1.60
	upstream_version_5_4_3_1:1.60
	debian_version_5_4_3_1-1:1.60
	Release-5-4-3:1.60.0.52
	Root_Release-5-4-3:1.60
	Root_Release-5-4-1:1.60
	Release-5-4-1:1.60.0.50
	Root_Release-5-4:1.60
	Release-5-4:1.60.0.48
	upstream_version_5_3_4:1.60
	debian_version_5_3_4-1:1.60
	ROOT_Release-5-3-4:1.60
	Release-5-3-4:1.60.0.46
	ROOT_Release-5-3-3:1.60
	Release-5-3-3:1.60.0.42
	debian_version_5_3_2_1_2-1:1.60
	upstream_version_5_3_2_1_2:1.60
	debian_version_5_3_2_1_1-1:1.60
	debian_version_5_3_2_1_1:1.60
	upstream_version_5_3_2_1_1:1.60
	Root_Release-5-3-2-1:1.60
	Release-5-3-2-1:1.60
	ROOT_RELEASE-5-3-2-1:1.60
	RELEASE-5-3-2-1:1.60.0.44
	Release-5-3-2:1.60.0.40
	Root_Release-5-3-2:1.60
	Root_Release-5-3-1:1.60
	Release-5-3-1:1.60.0.38
	Release-5-2-3-1:1.60.0.36
	Root_Release-5-2-3-1:1.60
	Release-5-2-2-4:1.60.0.34
	Root_Release-5-2-2-4:1.60
	Release-5-2-2-1:1.60.0.32
	Root_Release-5-2-2-1:1.60
	upstream_version_5_2_2:1.60
	debian_version_5_2_2-1:1.60
	Release-5-2-2:1.60.0.30
	ROOT_Release-5-2-2:1.60
	ROOT_Release-5-2-1:1.60
	Release-5-2-1:1.60.0.28
	Release-5-2-0:1.60.0.26
	ROOT_Release-5-2-0:1.60
	ROOT_Release-5-1-2:1.60
	Release-5-1-2:1.60.0.24
	Version-5-1-1:1.60.0.22
	ROOT_Version-5-1-1:1.60
	debian_version_5_1_0-1:1.60
	upstream_version_5_1_0:1.60
	ROOT_Release-5-1-0:1.60
	Release-5-1-0:1.60.0.20
	ROOT_Release-5-0-0:1.60
	Release-5-0-0:1.60.0.18
	Release-4-3-3:1.60.0.16
	ROOT_Release-4-3-3:1.60
	upstream_version_4_3_2:1.60
	debian_version_4_3_2-1:1.60
	ROOT_Release-4-3-2:1.60
	Release-4-3-2:1.60.0.14
	Release-4-3-1:1.60.0.12
	ROOT_Release-4-3-1:1.60
	debian_version_4_3_0-1:1.60
	upstream_version_4_3_0:1.60
	ROOT_Release-4-3-0:1.60
	Release-4-3-0:1.60.0.10
	debian_version_3_2_1b-2:1.59
	debian_version_4_2_2-1:1.60
	upstream_version_4_2_2:1.60
	debian_version_3_2_1b-1:1.59
	upstream_version_3_2_1b:1.59
	Release-4-1-2:1.60.0.8
	Release-4-0-8:1.60.0.6
	debian_version_4_0_8a-1:1.60
	upstream_version_4_0_8a:1.60
	jostb-debian-ubuntu-patch:1.60.0.4
	debian_version_4_0_8-1:1.60
	upstream_version_4_0_8:1.60
	debian_version_4_0_7-1:1.60
	upstream_version_4_0_7:1.60
	debian_version_4_0_6-1:1.60
	upstream_version_4_0_6:1.60
	debian_version_4_0_2-1:1.60
	upstream_version_4_0_2:1.60
	Release-4-0-2_Root:1.60
	Release-4-0-2:1.60.0.2
	upstream_version_4_0_1:1.60
	debian_version_4_0_1-2:1.60
	Release-3-2-1:1.59.0.2
	Release-3-1-8:1.58.0.2
	Release-3-0-8_root:1.52
	Release-3-0-8_Root:1.52
	Release-3-0-8:1.52.0.2
	Release-2-0-8:1.48.0.6
	Release-2-0-7_Root:1.48
	Release-2-0-7:1.48.0.2
	Release-2-0-6-branch:1.47.0.2
	Version-1:1.43.0.6
	Version-2:1.43.0.4
	Release-2:1.43.0.2
	PHP-5:1.23.0.4
	Release-1-0-6:1.25.0.2
	sparc-64-test:1.14.0.2
	V-2004-08-28:1.1.1.1
	PHP-JAVA-BRIDGE:1.1.1;
locks; strict;
comment	@ * @;
expand	@k@;


1.62
date	2010.02.18.17.25.32;	author jost_boekemeier;	state dead;
branches;
next	1.61;

1.61
date	2009.08.28.15.45.49;	author jost_boekemeier;	state Exp;
branches;
next	1.60;

1.60
date	2007.03.09.20.28.11;	author andremachado;	state Exp;
branches;
next	1.59;

1.59
date	2006.11.25.17.00.33;	author jost2345;	state Exp;
branches;
next	1.58;

1.58
date	2006.09.10.17.31.12;	author jost2345;	state Exp;
branches;
next	1.57;

1.57
date	2006.08.21.17.41.52;	author jost2345;	state Exp;
branches;
next	1.56;

1.56
date	2006.08.08.17.20.45;	author jost2345;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.23.20.32.47;	author jost2345;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.21.19.53.10;	author jost2345;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.19.20.37.19;	author jost2345;	state Exp;
branches;
next	1.52;

1.52
date	2006.02.05.18.47.00;	author jost2345;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.30.19.39.54;	author jost2345;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.11.22.24.41;	author jost2345;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.05.13.11.19;	author jost2345;	state Exp;
branches;
next	1.48;

1.48
date	2005.06.25.12.16.10;	author jost2345;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.05.14.55.43;	author jost2345;	state Exp;
branches;
next	1.46;

1.46
date	2005.02.20.12.19.45;	author jost2345;	state Exp;
branches;
next	1.45;

1.45
date	2005.02.15.19.10.32;	author jost2345;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.13.21.43.29;	author jost2345;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.03.16.56.08;	author jost2345;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.01.20.01.29;	author jost2345;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.28.16.32.55;	author jost2345;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.07.16.27.15;	author jost2345;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.06.17.09.34;	author jost2345;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.03.17.14.18;	author jost2345;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.20.20.04.44;	author jost2345;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.12.09.57.26;	author jost2345;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.03.18.35.22;	author jost2345;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.01.20.29.58;	author jost2345;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.28.21.12.59;	author jost2345;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.26.21.13.40;	author jost2345;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.24.23.18.18;	author jost2345;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.21.14.44.56;	author jost2345;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.19.16.54.34;	author jost2345;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.18.21.39.55;	author jost2345;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.16.23.28.18;	author jost2345;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.11.18.36.01;	author jost2345;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.31.12.48.34;	author jost2345;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.30.15.37.16;	author jost2345;	state Exp;
branches;
next	1.23;

1.23
date	2004.10.27.19.53.27;	author jost2345;	state Exp;
branches;
next	1.22;

1.22
date	2004.10.24.10.58.48;	author jost2345;	state Exp;
branches;
next	1.21;

1.21
date	2004.10.23.15.57.36;	author jost2345;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.18.17.54.28;	author jost2345;	state Exp;
branches;
next	1.19;

1.19
date	2004.10.18.17.37.49;	author jost2345;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.18.15.39.10;	author jost2345;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.14.16.32.12;	author jost2345;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.12.17.07.16;	author jost2345;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.11.18.11.53;	author jost2345;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.07.11.19.47;	author jost2345;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2004.10.06.16.26.11;	author jost2345;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.05.21.51.58;	author jost2345;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.04.16.38.30;	author jost2345;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.27.17.40.53;	author jost2345;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.26.13.32.42;	author jost2345;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.23.13.12.45;	author jost2345;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.22.19.17.49;	author jost2345;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.21.12.21.30;	author jost2345;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.19.18.45.14;	author jost2345;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.17.17.32.36;	author jost2345;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.12.19.23.34;	author jost2345;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.29.15.24.31;	author jost2345;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.28.06.06.25;	author jost2345;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.08.28.06.06.25;	author jost2345;	state Exp;
branches;
next	;

1.14.2.1
date	2004.10.09.21.57.20;	author jost2345;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Release-6-0-0
@
text
@/*-*- mode: C; tab-width:4 -*-*/

/*
  Copyright (C) 2003-2007 Jost Boekemeier

  This file is part of the PHP/Java Bridge.

  The PHP/Java Bridge ("the library") is free software; you can
  redistribute it and/or modify it under the terms of the GNU General
  Public License as published by the Free Software Foundation; either
  version 2, or (at your option) any later version.

  The library is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with the PHP/Java Bridge; see the file COPYING.  If not, write to the
  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307 USA.

  Linking this file statically or dynamically with other modules is
  making a combined work based on this library.  Thus, the terms and
  conditions of the GNU General Public License cover the whole
  combination.

  As a special exception, the copyright holders of this library give you
  permission to link this library with independent modules to produce an
  executable, regardless of the license terms of these independent
  modules, and to copy and distribute the resulting executable under
  terms of your choice, provided that you also meet, for each linked
  independent module, the terms and conditions of the license of that
  module.  An independent module is a module which is not derived from
  or based on this library.  If you modify this library, you may extend
  this exception to your version of the library, but you are not
  obligated to do so.  If you do not wish to do so, delete this
  exception statement from your version. 
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/* disable unix domain sockets if jni is not available */
#ifndef HAVE_JNI
# ifndef CFG_JAVA_SOCKET_INET
#  define CFG_JAVA_SOCKET_INET
# endif
#endif

/* socket */
#include <stddef.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef __MINGW32__
# include <winsock2.h>
#else
# include <sys/socket.h>
# ifdef CFG_JAVA_SOCKET_INET
#  include <netinet/in.h>
# else
#  include <sys/un.h>
#  ifdef HAVE_CONFIG_H
#  if !HAVE_DECL_AF_LOCAL
#   define AF_LOCAL AF_UNIX
#  endif
#  endif
#  ifdef HAVE_CONFIG_H
#  if !HAVE_DECL_PF_LOCAL
#   define PF_LOCAL PF_UNIX
#  endif
#  endif
# endif
#endif

#define N_SARGS N_JAVA_SARGS
#define N_SENV N_JAVA_SENV

/* strings */
#include <string.h>
/* setenv */
#include <stdlib.h>
/*signal*/
#include <signal.h>

/* miscellaneous */
#include <stdio.h>
#include <errno.h>
#include <unistd.h>

#ifdef __MINGW32__
# ifndef HAVE_BROKEN_STDIO
# define HAVE_BROKEN_STDIO
# endif
# ifndef CFG_JAVA_SOCKET_INET
# define CFG_JAVA_SOCKET_INET
# endif
#endif

#undef NDEBUG
#ifndef JAVA_COMPILE_DEBUG
#define NDEBUG
#endif
#include <assert.h>
#include "protocol.h"

#include "jni.h"

static jint logLevel=3;
static jclass bridge=NULL;

static char*sockname=NULL;

static void doLog (JNIEnv *jenv, char *msg, jmethodID logMessageID) {
  jstring str;
  if(!logMessageID) { fputs(msg, stderr); fputs("\n", stderr); fflush(stderr); return; }
  str = (*jenv)->NewStringUTF(jenv, msg);
  if(!str) { fputs(msg, stderr); fputs("\n", stderr); fflush(stderr); return; }
  (*jenv)->CallStaticVoidMethod(jenv, bridge, logMessageID, str);
  (*jenv)->DeleteLocalRef(jenv, str);
}
static void logFatal(JNIEnv *jenv, char *msg) {
  static jmethodID logMessageID=NULL;
  assert(bridge);
  if(logLevel<=0 || !bridge) return;
  if(!logMessageID)
	logMessageID = (*jenv)->GetStaticMethodID(jenv, bridge, "logFatal", "(Ljava/lang/String;)V");
  doLog(jenv, msg, logMessageID);
}
static void logSysFatal(JNIEnv *jenv, char *msg) {
  char s[512];
  sprintf(s, "system error: %s: %s", msg, strerror(errno));
  logFatal(jenv, s);
}

static void atexit_bridge() {
  if(sockname) {
#ifndef __MINGW32__
# if !defined(HAVE_ABSTRACT_NAMESPACE) && !defined(CFG_JAVA_SOCKET_INET)
  unlink(sockname);
# endif
#endif
  free(sockname);
  sockname=NULL;
  }
}

static void initGlobals(JNIEnv *env) {
  // FIXME: set uid and gid 
  /*
  jmethodID initGlobals;
  jstring arg;

  initGlobals = (*env)->GetStaticMethodID(env, bridge, "initGlobals", "(Ljava/lang/String;)V");
  arg = (*env)->NewStringUTF(env, EXTENSION_DIR);
  (*env)->CallStaticVoidMethod(env, bridge, initGlobals, arg);
  (*env)->DeleteLocalRef(env, arg);
  */
  atexit(atexit_bridge);
}

#ifdef HAVE_STRUCT_UCRED

/* Prepare the socket to receive auth information directly from the
   kernel. 
 */
static int prep_cred(int sock) {
  static const int is_true = 1;
  int ret = setsockopt(sock, SOL_SOCKET, SO_PASSCRED, (void*)&is_true, sizeof is_true);
  return ret;
}

/* Receive authentification information (enforced by the BSD or Linux
   kernel). It is impossible to fake the auth information.
 */
static int recv_cred(int sock, int *uid, int *gid) {
  struct ucred ucred;
  socklen_t so_len = sizeof ucred;
  int n = getsockopt(sock, SOL_SOCKET, SO_PEERCRED, &ucred, &so_len);
  int ret = (n==-1 || so_len!=sizeof ucred) ? -1 : 0;
  if(ret!=-1) {
	*uid=ucred.uid;
	*gid=ucred.gid;
  }  
  return ret;
}
#else  /* struct ucred missing */
#define prep_cred(a) 0
#define recv_cred(a, b, c) 0
#endif

JNIEXPORT jboolean JNICALL Java_php_java_bridge_JavaBridge_openLog
  (JNIEnv *env, jclass self, jstring _logfile)
{
#ifndef __MINGW__
  char*logfile=NULL;

  assert(_logfile);

  if(_logfile!=NULL) {
	jboolean isCopy;
	const char*sname = (*env)->GetStringUTFChars(env, _logfile, &isCopy);
	if(sname) logfile=strdup(sname);
	(*env)->ReleaseStringUTFChars(env, _logfile, sname);
  } else {
	logfile = strdup(LOGFILE);
  }
  if(logfile) {
	int fd;
	if(!*logfile) {	/* java.log_file="": direct everything to stderr */
	  jboolean ret = JNI_TRUE;
	  if(dup2(2,1)==-1) ret = JNI_FALSE;
	  free(logfile);
	  return ret;
	}
	fd = open(logfile, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	free(logfile);
	if(fd==-1) return JNI_FALSE;
	if(fd!=-1) { 
	  if(dup2(fd,1)==-1) return JNI_FALSE;
	  if(dup2(fd,2)==-1) return JNI_FALSE;
	}
	return JNI_TRUE;
  }
#endif
  return JNI_FALSE;
}

JNIEXPORT jint JNICALL Java_php_java_bridge_JavaBridge_sread
  (JNIEnv *env, jclass self, jint peer, jbyteArray _buffer, jint nmemb)
{
  int socket = (int)peer;
  jbyte *buffer = (*env)->GetByteArrayElements(env, _buffer, JNI_FALSE);
  ssize_t n;
  assert(nmemb);
 res: errno=0;
  n=recv(socket, buffer, nmemb, 0);
  if(!n && errno==EINTR) goto res; // Solaris, see INN FAQ
  (*env)->ReleaseByteArrayElements(env, _buffer, buffer, 0);
  return n;
}
JNIEXPORT jint JNICALL Java_php_java_bridge_JavaBridge_swrite
  (JNIEnv *env, jclass self, jint peer, jbyteArray _buffer, jint nmemb)
{
  int socket = (int)peer;
  jbyte *buffer = (*env)->GetByteArrayElements(env, _buffer, JNI_FALSE);
  size_t s=0, size = (size_t) nmemb;
  ssize_t n = 0;
  assert(nmemb);

 res: errno=0;
  while((size>s)&&((n=send(socket, buffer+s, size-s, 0)) > 0))
	s+=n;
  if(size>s && !n && errno==EINTR) goto res; // Solaris, see INN FAQ

  (*env)->ReleaseByteArrayElements(env, _buffer, buffer, 0);
  return n;
}
JNIEXPORT void JNICALL Java_php_java_bridge_JavaBridge_sclose
  (JNIEnv *env, jclass self, jint peer)
{
  int socket=(int)peer;
  close(socket);
}

JNIEXPORT jint JNICALL Java_php_java_bridge_JavaBridge_startNative
(JNIEnv *env, jclass self, jint _logLevel,jint _backlog, jstring _sockname) {
#ifndef CFG_JAVA_SOCKET_INET
  struct sockaddr_un saddr;
#else
  struct sockaddr_in saddr;
#endif
  int sock, n;
  size_t len;

  logLevel = _logLevel;
  bridge = self;

  if(_sockname!=NULL) {
	jboolean isCopy;
	const char*sname = (*env)->GetStringUTFChars(env, _sockname, &isCopy);
	sockname=strdup(sname);
	(*env)->ReleaseStringUTFChars(env, _sockname, sname);
  } else {
	char *s = SOCKNAME;
	sockname = strdup(s);
  }
  /* socket */
#ifndef CFG_JAVA_SOCKET_INET
  saddr.sun_family = AF_LOCAL;
  memset(saddr.sun_path, 0, sizeof saddr.sun_path);
  strncpy(saddr.sun_path, sockname, sizeof (saddr.sun_path)-1);
  len = strlen(saddr.sun_path); 
  if (len >= sizeof (saddr.sun_path)) len = sizeof (saddr.sun_path)-1;
# ifndef HAVE_ABSTRACT_NAMESPACE
  len = offsetof (struct sockaddr_un, sun_path) + len + 1;
  unlink(sockname);
# else
  len = offsetof (struct sockaddr_un, sun_path) + len;
  *saddr.sun_path=0;
# endif
  sock = socket (PF_LOCAL, SOCK_STREAM, 0);
  if(!sock) {logSysFatal(env, "could not create socket"); return 0;}
  if (-1==prep_cred(sock)) logSysFatal(env, "socket cannot receive credentials");
#else
  saddr.sin_family = AF_INET;
  saddr.sin_port=htons(atoi(sockname));
  saddr.sin_addr.s_addr = inet_addr( "127.0.0.1" );
  sock = socket (PF_INET, SOCK_STREAM, 0);
  if(!sock) {logSysFatal(env, "could not create socket"); return 0;}
  len = sizeof (saddr);
#endif
  n = bind(sock,(struct sockaddr*)&saddr, len);
  if(n==-1) {logSysFatal(env, "could not bind socket"); return 0;}
#if !defined(HAVE_ABSTRACT_NAMESPACE) && !defined(CFG_JAVA_SOCKET_INET)
  chmod(sockname, 0666); // the childs usually run as "nobody"
#endif
  n = listen(sock, 20);
  if(n==-1) {logSysFatal(env, "could not listen to socket"); return 0;}

  initGlobals(env);

  return sock;
}

JNIEXPORT jint JNICALL Java_php_java_bridge_JavaBridge_accept
  (JNIEnv *env, jclass self, jint _sock)
{
  int sock=(int)_sock, socket;

 res:errno=0; 
  socket = accept(sock, NULL, 0); 
  if(socket==-1) {
	if(errno==EINTR) goto res; // Solaris, see INN FAQ
	
	logSysFatal(env, "socket accept failed"); 
	return 0;
  }
  //if(-1==recv_cred(socket, &uid, &gid)) logSysFatal(env, "could not get credentials");
  return socket;
}

#ifdef HAVE_JVM
JNINativeMethod javabridge[]={
  {"startNative", "(IILjava/lang/String;)I", Java_php_java_bridge_JavaBridge_startNative},
  {"openLog", "(Ljava/lang/String;)Z", Java_php_java_bridge_JavaBridge_openLog},

  {"swrite", "(I[BI)I", Java_php_java_bridge_JavaBridge_swrite},
  {"sread", "(I[BI)I", Java_php_java_bridge_JavaBridge_sread},
  {"sclose", "(I)V", Java_php_java_bridge_JavaBridge_sclose},
};

static struct NativeMethods {
  char*class;
  JNINativeMethod*meth;
  int n;
} meths[]={
  {"php/java/bridge/JavaBridge", javabridge, (sizeof javabridge)/(sizeof *javabridge)},
};

static void jniRegisterNatives (JNIEnv *env)
{
  int i;
  jint r;
  jclass k;

  for(i=0; i<((sizeof meths)/(sizeof*meths)); i++) {
	k = (*env)->FindClass (env, meths[i].class);
	assert(k); if(!k) exit(9);
	r = (*env)->RegisterNatives (env, k, meths[i].meth, meths[i].n);
	assert(r==JNI_OK); if(r!=JNI_OK) exit(9);
  }
}

void java_bridge_main(int argc, char**argv) 
{
  JavaVMOption options[5];
  const int off = N_SARGS-3-1; /* PORT, LEVEL, LOG_FILE */
  JavaVM *jvm;
  JNIEnv *jenv;
  JavaVMInitArgs vm_args; /* JDK 1.2 VM initialization arguments */
  jclass reflectClass, stringClass;
  jobjectArray arr;
  jmethodID init;
  int i, err;

  vm_args.version = JNI_VERSION_1_2; /* New in 1.1.2: VM version */
  /* Get the default initialization arguments and set the class 
   * path */
  JNI_GetDefaultJavaVMInitArgs(&vm_args);
  vm_args.nOptions=0;
  vm_args.options=options;
  /* library path */
  if(argv[1]) vm_args.options[vm_args.nOptions++].optionString=argv[1];
  /* class path */
  if(argv[2]) vm_args.options[vm_args.nOptions++].optionString=argv[2];
  /* policy or java.awt.headless */
  if(argv[3]) vm_args.options[vm_args.nOptions++].optionString=argv[3];
  /* base  */
  if(argv[4]) vm_args.options[vm_args.nOptions++].optionString=argv[4];
  vm_args.ignoreUnrecognized=JNI_TRUE;

  /* load and initialize a Java VM, return a JNI interface 
   * pointer in env */
  err=JNI_CreateJavaVM(&jvm, (void*)&jenv, &vm_args);
  assert(!err); if(err) exit(9);
  jniRegisterNatives(jenv);
  reflectClass = (*jenv)->FindClass(jenv, "php/java/bridge/JavaBridge");
  assert(reflectClass); if(!reflectClass) exit(9);
  init = (*jenv)->GetStaticMethodID(jenv, reflectClass, "init", "([Ljava/lang/String;)V");
  assert(init); if(!init) exit(9);
  stringClass = (*jenv)->FindClass(jenv, "java/lang/String");
  assert(stringClass); if(!stringClass) exit(9);
  arr = (*jenv)->NewObjectArray(jenv, 3, stringClass, 0);
  assert(arr); if(!arr) exit(9);

  for (i=0; i<3; i++) {
	jstring arg;
	if(!argv[i+off]) break;
    arg = (*jenv)->NewStringUTF(jenv, argv[i+off]);
	assert(arg); if(!arg) exit(9);
    (*jenv)->SetObjectArrayElement(jenv, arr, i, arg);
  }
  (*jenv)->CallStaticVoidMethod(jenv, reflectClass, init, arr);
  (*jvm)->DestroyJavaVM(jvm);

  exit(1);
}

void java_bridge_main_gcj(int argc, char**_argv) 
{
  char **argv;
  /* someone should really fix this bug in gcj */
  meths[0].meth[0].signature="(IILjava.lang.String;)I";
  meths[0].meth[1].signature="(Ljava.lang.String;)Z";

  if(!_argv) exit(6);
  if(argc==4) {
	argv=calloc(N_SARGS, sizeof*argv);
	argv[N_SARGS-4]=_argv[1];			/* socketname */
	argv[N_SARGS-3]=_argv[2];			/* logLevel */
	argv[N_SARGS-2]=_argv[3];			/* logFile */
	argv[N_SARGS-1]=0;					/* last arg */
  } else {
	argv=_argv;
  }
  java_bridge_main(N_SARGS, argv);
}
#endif /* HAVE_JVM */
@


1.61
log
@Fedora 11 SEL updates
@
text
@@


1.60
log
@Files update 3.2.2 to 4.0.1. Extracted from the src.tar.gz downloaded from sf.net, uploaded by Jost Boekemeier. Update to repository by Andre Felipe Machado.
@
text
@d53 1
d276 1
d294 3
a296 1
  strcpy(saddr.sun_path, sockname);
d298 1
d301 1
d313 1
d315 1
a315 1
  n = bind(sock,(struct sockaddr*)&saddr, sizeof saddr);
@


1.59
log
@Release-3-2-1
@
text
@d4 1
a4 1
  Copyright (C) 2003, 2006 Jost Boekemeier
@


1.58
log
@Release-3-1-8
@
text
@d338 1
d444 1
@


1.57
log
@Release-3-1-8devel1
@
text
@d421 1
a421 3
  assert(0);
  while(1)			  /* DestroyJavaVM should already block forever */
	sleep(65535);
@


1.56
log
@Release-3-1-7
@
text
@d3 38
@


1.55
log
@Release-3-1-6
@
text
@a13 3
/* longjump */
#include <setjmp.h>

a15 1
#include <sys/types.h>
d72 1
a72 15
#define ID(peer, name) \
if(logLevel>=LOG_DEBUG) logDebug(env, "send: "/**/#name); \
id(peer, name);

#define ASSERTM(expr) \
if(!expr) { \
  logMemoryError(env, __FILE__, __LINE__); \
  exit(9); \
}

#ifndef EXTENSION_DIR
#error EXTENSION_DIR must point to the PHP extension directory
#endif

static jint logLevel=4;
a84 16
static void logDebug(JNIEnv *jenv, char *msg) {
  static jmethodID logMessageID=NULL;
  assert(bridge);
  if(logLevel<=3 || !bridge) return;
  if(!logMessageID)
	logMessageID = (*jenv)->GetStaticMethodID(jenv, bridge, "logDebug", "(Ljava/lang/String;)V");
  doLog(jenv, msg, logMessageID);
}
static void logError(JNIEnv *jenv, char *msg) {
  static jmethodID logMessageID=NULL;
  assert(bridge);
  if(logLevel<=1 || !bridge) return;
  if(!logMessageID)
	logMessageID = (*jenv)->GetStaticMethodID(jenv, bridge, "logError", "(Ljava/lang/String;)V");
  doLog(jenv, msg, logMessageID);
}
a92 5
static void logSysError(JNIEnv *jenv, char *msg) {
  char s[512];
  sprintf(s, "system error: %s: %s", msg, strerror(errno));
  logError(jenv, s);
}
a97 18
static void logMemoryError(JNIEnv *jenv, char *file, int pos) {
  static char s[512];
  sprintf(s, "system error: out of memory error in: %s, line: %d", file, pos);
  logFatal(jenv, s);
  exit(9);
}

static void logRcv(JNIEnv*env, char c) {
  char*s;
  if(logLevel<=3) return;

  s=malloc(20);
  assert(s);
  if(!s) return;
  sprintf(s, "recv: %i", (unsigned int)c);
  logDebug(env, s);
  free(s);
}
d131 2
a132 2
  static const int true = 1;
  int ret = setsockopt(sock, SOL_SOCKET, SO_PASSCRED, (void*)&true, sizeof true);
@


1.54
log
@Release-3-1-2
@
text
@d229 1
a229 3
	int fd, null;
	null = open("/dev/null", O_RDONLY);
	if(null!=-1) dup2 (null,0); 
@


1.53
log
@Release-3-1-0
@
text
@d238 1
a238 1
	fd = open(logfile, O_WRONLY | O_CREAT | O_APPEND | O_TRUNC, 0644);
@


1.52
log
@Release-3.0.7
@
text
@d392 2
a393 1
  JavaVMOption options[3];
d400 2
a401 1
  int i, err, off;
d408 1
d410 1
d412 1
d414 2
d429 1
a429 1
  arr = (*jenv)->NewObjectArray(jenv, argc-6, stringClass, 0);
d432 1
a432 2
  off = N_SARGS-4;
  for (i=0; (i+6)<argc; i++) {
@


1.51
log
@Release-3.0.7
@
text
@d223 1
a223 1
	if(sname && strlen(sname)) logfile=strdup(sname);
d226 1
a226 2
	char *s = LOGFILE;
	if(s && strlen(s)>0) logfile = strdup(s);
a227 1
  
d230 8
d239 1
a240 2
	null = open("/dev/null", O_RDONLY);
	if(null!=-1) dup2 (null,0); 
@


1.50
log
@Release-3-0-2
@
text
@d7 7
@


1.49
log
@Version-3.0(pre)
@
text
@d36 3
@


1.48
log
@Shut down servlet connection
@
text
@d407 1
a407 1
  arr = (*jenv)->NewObjectArray(jenv, argc, stringClass, 0);
@


1.47
log
@Release 2.0
@
text
@d159 2
d168 1
@


1.46
log
@Release-2.0-beta
@
text
@d238 1
a238 1
  size_t n;
d242 1
a242 1
  if(errno==EINTR) goto res; // Solaris, see INN FAQ
d251 2
a252 1
  size_t n;
d254 1
d256 4
a259 2
  n=send(socket, buffer, nmemb, 0);
  if(errno==EINTR) goto res; // Solaris, see INN FAQ
@


1.45
log
@Replaced JNI with XML protocol
@
text
@d338 1
a338 1
  {"startNative", "(ILjava/lang/String;)V", Java_php_java_bridge_JavaBridge_startNative},
d341 3
a343 3
  {"swrite", "(I[BII)I", Java_php_java_bridge_JavaBridge_swrite},
  {"sread", "(I[BII)I", Java_php_java_bridge_JavaBridge_sread},
  {"sclose", "(i)V", Java_php_java_bridge_JavaBridge_sclose},
d351 1
a351 1
  {"JavaBridge", javabridge, (sizeof javabridge)/(sizeof *javabridge)},
d394 1
a394 1
  reflectClass = (*jenv)->FindClass(jenv, "JavaBridge");
d423 1
a423 1
  meths[0].meth[0].signature="(ILjava.lang.String;)V";
@


1.44
log
@Replaced JNI with XML protocol
@
text
@d1 437
@


1.43
log
@Release-1.0.8
@
text
@a0 1254
/*-*- mode: C; tab-width:4 -*-*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/* longjump */
#include <setjmp.h>

/* socket */
#include <sys/types.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef __MINGW32__
# include <winsock2.h>
#else
# include <sys/socket.h>
# ifdef CFG_JAVA_SOCKET_INET
#  include <netinet/in.h>
# else
#  include <sys/un.h>
#  ifdef HAVE_CONFIG_H
#  if !HAVE_DECL_AF_LOCAL
#   define AF_LOCAL AF_UNIX
#  endif
#  endif
#  ifdef HAVE_CONFIG_H
#  if !HAVE_DECL_PF_LOCAL
#   define PF_LOCAL PF_UNIX
#  endif
#  endif
# endif
#endif

/* strings */
#include <string.h>
/* setenv */
#include <stdlib.h>
/*signal*/
#include <signal.h>

/* posix threads implementation */
#ifndef __MINGW32__
# include <pthread.h>
# include <semaphore.h>
#endif

/* miscellaneous */
#include <stdio.h>
#include <errno.h>
#include <unistd.h>

#ifdef __MINGW32__
# ifndef HAVE_BROKEN_STDIO
# define HAVE_BROKEN_STDIO
# endif
# ifndef CFG_JAVA_SOCKET_INET
# define CFG_JAVA_SOCKET_INET
# endif
#endif

#undef NDEBUG
#ifndef JAVA_COMPILE_DEBUG
#define NDEBUG
#endif
#include <assert.h>
#include "protocol.h"
#include "sio.c"

#define ID(peer, name) \
if(logLevel>=LOG_DEBUG) logDebug(env, "send: "/**/#name); \
id(peer, name);

#define ASSERTM(expr) \
if(!expr) { \
  logMemoryError(env, __FILE__, __LINE__); \
  exit(9); \
}

#ifndef EXTENSION_DIR
#error EXTENSION_DIR must point to the PHP extension directory
#endif


static jclass exceptionClass=NULL;

static jclass enumClass=NULL;
static jclass hashClass=NULL;
static jmethodID init=NULL;

static jmethodID hashPut=NULL;
static jmethodID hashRemove=NULL;
static jmethodID hashKeys=NULL;

static jmethodID enumMore=NULL;
static jmethodID enumNext=NULL;

static jmethodID handleRequests=NULL;
static jmethodID handleRequest=NULL;
static jmethodID trampoline=NULL;

static jclass longClass=NULL;
static jmethodID longCtor=NULL;
static jmethodID longValue=NULL;

static jmethodID getClass=NULL;

static jint logLevel=4;
static jclass bridge=NULL;

static char*sockname=NULL;

#ifndef __MINGW32__
static pthread_attr_t attr;
static pthread_mutex_t mutex;
static int count=0;
static pthread_cond_t cond;
static volatile sem_t cond_sig;
static volatile short bridge_shutdown = 0;
#endif

struct peer {
  jmp_buf env;					/* exit from the loop */
  jmp_buf savepoint;			/* jump back to java */
  JNIEnv *jenv;
  short tran;					/* if we must return to java first */
  SFILE*stream;
  jobject objectHash;
  jobject globalRef;
};
static void doLog (JNIEnv *jenv, char *msg, jmethodID logMessageID) {
  jstring str;
  if(!logMessageID) { fputs(msg, stderr); fputs("\n", stderr); fflush(stderr); return; }
  str = (*jenv)->NewStringUTF(jenv, msg);
  if(!str) { fputs(msg, stderr); fputs("\n", stderr); fflush(stderr); return; }
  (*jenv)->CallStaticVoidMethod(jenv, bridge, logMessageID, str);
  (*jenv)->DeleteLocalRef(jenv, str);
}
static void logDebug(JNIEnv *jenv, char *msg) {
  static jmethodID logMessageID=NULL;
  assert(bridge);
  if(logLevel<=3 || !bridge) return;
  if(!logMessageID)
	logMessageID = (*jenv)->GetStaticMethodID(jenv, bridge, "logDebug", "(Ljava/lang/String;)V");
  doLog(jenv, msg, logMessageID);
}
static void logError(JNIEnv *jenv, char *msg) {
  static jmethodID logMessageID=NULL;
  assert(bridge);
  if(logLevel<=1 || !bridge) return;
  if(!logMessageID)
	logMessageID = (*jenv)->GetStaticMethodID(jenv, bridge, "logError", "(Ljava/lang/String;)V");
  doLog(jenv, msg, logMessageID);
}
static void logFatal(JNIEnv *jenv, char *msg) {
  static jmethodID logMessageID=NULL;
  assert(bridge);
  if(logLevel<=0 || !bridge) return;
  if(!logMessageID)
	logMessageID = (*jenv)->GetStaticMethodID(jenv, bridge, "logFatal", "(Ljava/lang/String;)V");
  doLog(jenv, msg, logMessageID);
}
static void logSysError(JNIEnv *jenv, char *msg) {
  char s[512];
  sprintf(s, "system error: %s: %s", msg, strerror(errno));
  logError(jenv, s);
}
static void logSysFatal(JNIEnv *jenv, char *msg) {
  char s[512];
  sprintf(s, "system error: %s: %s", msg, strerror(errno));
  logFatal(jenv, s);
}
static void logMemoryError(JNIEnv *jenv, char *file, int pos) {
  static char s[512];
  sprintf(s, "system error: out of memory error in: %s, line: %d", file, pos);
  logFatal(jenv, s);
  exit(9);
}

static void swrite(const  void  *ptr,  size_t  size,  size_t  nmemb,  struct peer*peer) {
  SFILE*stream=peer->stream;
  int n = SFWRITE(ptr, size, nmemb, stream);
  //printf("write char:::%d\n", (unsigned int) ((char*)ptr)[0]);
  if(n!=nmemb) {
	if(peer->tran) {		/* first clear the java stack, then longjmp */
	  (*peer->jenv)->ThrowNew(peer->jenv, exceptionClass, "child aborted connection during write");
	  longjmp(peer->savepoint, 1);
	} else
	   longjmp(peer->env, 2);
  }

}
static void sread(void *ptr, size_t size, size_t nmemb, struct peer *peer) {
  SFILE*stream=peer->stream;
  int n = SFREAD(ptr, size, nmemb, stream);
  //printf("read char:::%d\n", (unsigned int) ((char*)ptr)[0]);
  if(n!=nmemb) {
	if(peer->tran) {		/* first clear the java stack, then longjmp */
	  (*peer->jenv)->ThrowNew(peer->jenv, exceptionClass, "child aborted connection during read");
	  longjmp(peer->savepoint, 1);
	} else
	  longjmp(peer->env, 1);
  }
}

static void id(struct peer*peer, char id) {
  swrite(&id, sizeof id, 1, peer);
}

static jobject objFromPtr(JNIEnv *env, void*val) {
  jobject obj = (*env)->NewObject (env, longClass, longCtor, (jlong)(unsigned long)val);
  assert(obj); if(!obj) logFatal(env, "allocate object"); 

  return obj;
}
static void* ptrFromObj(JNIEnv *env, jobject val) {
  jlong result = (*env)->CallLongMethod(env, val, longValue);
  assert(result);
  return (void*)(unsigned long)result;
}

static void logRcv(JNIEnv*env, char c) {
  char*s;
  if(logLevel<=3) return;

  s=malloc(20);
  assert(s);
  if(!s) return;
  sprintf(s, "recv: %i", (unsigned int)c);
  logDebug(env, s);
  free(s);
}

static void atexit_bridge() {
  if(sockname) {
#ifndef __MINGW32__
# if !defined(HAVE_ABSTRACT_NAMESPACE) && !defined(CFG_JAVA_SOCKET_INET)
  unlink(sockname);
# endif
  sem_destroy((sem_t*)&cond_sig);
  pthread_attr_destroy(&attr);
  pthread_mutex_destroy(&mutex);
  pthread_cond_destroy(&cond);
#endif
  free(sockname);
  sockname=NULL;
  }
}

static void enter() {
#ifndef __MINGW32__
  pthread_mutex_lock(&mutex);
  assert(count>=0);
  count++;
  pthread_mutex_unlock(&mutex);
#endif
}

static void leave() {
#ifndef __MINGW32__
  pthread_mutex_lock(&mutex);
  assert(count>0);
  if(!--count) pthread_cond_signal(&cond);
  pthread_mutex_unlock(&mutex);
#endif
}

static void *guard_requests(void *p) {
#ifndef __MINGW32__
  int err;

 again: 
  err = sem_wait((sem_t*)&cond_sig); 
  if(err==-1 && errno==EINTR) goto again; /* handle ctrl-z */
 
  pthread_mutex_lock(&mutex);
  bridge_shutdown=1;
  if(count) pthread_cond_wait(&cond, &mutex);
  pthread_mutex_unlock(&mutex);
  exit(0);
#endif
}

static void initGlobals(JNIEnv *env) {
  jobject hash;
  jmethodID addSystemLibraries;
  jstring arg;

  exceptionClass = (*env)->FindClass(env, "java/lang/Throwable");
  enumClass = (*env)->FindClass(env, "java/util/Enumeration");
  hashClass = (*env)->FindClass(env, "java/util/Hashtable");
  init = (*env)->GetMethodID(env, hashClass, "<init>", "()V");
  hash = (*env)->NewObject(env, hashClass, init);
  hashPut = (*env)->GetMethodID(env, hashClass, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
  hashRemove = (*env)->GetMethodID(env, hashClass, "remove", "(Ljava/lang/Object;)Ljava/lang/Object;");
  hashKeys = (*env)->GetMethodID(env, hashClass, "keys", "()Ljava/util/Enumeration;");
  
  enumMore = (*env)->GetMethodID(env, enumClass, "hasMoreElements", "()Z");
  enumNext = (*env)->GetMethodID(env, enumClass, "nextElement", "()Ljava/lang/Object;");

  handleRequests = (*env)->GetStaticMethodID(env, bridge, "HandleRequests", "(III)V");
  handleRequest = (*env)->GetStaticMethodID(env, bridge, "HandleRequest", "(Ljava/lang/Object;J)I");
  trampoline = (*env)->GetStaticMethodID(env, bridge, "Trampoline", "(Ljava/lang/Object;JZ)Z");

  addSystemLibraries = (*env)->GetStaticMethodID(env, bridge, "addSystemLibraries", "(Ljava/lang/String;)V");
  arg = (*env)->NewStringUTF(env, EXTENSION_DIR);
  (*env)->CallStaticVoidMethod(env, bridge, addSystemLibraries, arg);
  (*env)->DeleteLocalRef(env, arg);
  
  longClass = (*env)->FindClass (env, "java/lang/Long");
  longCtor = (*env)->GetMethodID(env, longClass, "<init>", "(J)V");
  longValue = (*env)->GetMethodID(env, longClass, "longValue", "()J");

  getClass = (*env)->GetStaticMethodID(env, bridge, "GetClass", "(Ljava/lang/Object;)Ljava/lang/Class;");
  assert(getClass);
  atexit(atexit_bridge);

#ifndef __MINGW32__
  {
	pthread_t thread;
	pthread_attr_init(&attr);
	pthread_cond_init(&cond, NULL);
	pthread_mutex_init(&mutex, NULL);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	
	sem_init((sem_t*)&cond_sig, 0, 0);
	pthread_create(&thread, &attr, guard_requests, 0);
  }
#endif
}
static jobject initHash(JNIEnv *env) {
  jobject hash = (*env)->NewObject(env, hashClass, init);
  jobject objectHash = (*env)->NewGlobalRef(env, hash);
  return objectHash;
}
static jobject getObjectHash(struct peer *peer) {
  if(!peer->objectHash) peer->objectHash=initHash(peer->jenv);
  if(!peer->objectHash) {
	logFatal(peer->jenv, "could not create hash table"); 
	peer->objectHash=peer->globalRef;
  }
  return peer->objectHash;
}
static int handle_request(struct peer*peer, JNIEnv *env) {
  char c;

  //logDebug(env, "waiting for request from client");
  sread(&c, 1, 1, peer);
  logRcv(env, c);
  switch(c) {
  case PROTOCOL_END: {
	return 0;
  }
/*
 client                                            server

 createObj (wait for 0)      ->                      createObj -> create
                                   <-                setResult1 (wait for 0)
 setresult, send 0           ->                      terminate loop (back to java)
                                   <-                setResultn (wait for 0)
 setresult, send 0           ->                      always:end of co, send 0
 terminate co loop                 <-
 */

  case LASTEXCEPTION: {
	jobject php_reflect;
	jmethodID lastEx;
	jlong result;
	sread(&php_reflect, sizeof php_reflect,1, peer);
	sread(&lastEx, sizeof lastEx,1, peer);
	sread(&result, sizeof result,1, peer);
	(*env)->CallVoidMethod(env, php_reflect, lastEx, result, (jlong)(long)peer);
	ID(peer, 0); 
	break;
  }	
  case INVOKE:
  case GETSETPROP: {
	jobject php_reflect;
	jmethodID invoke;
	jobject obj;
	jstring method;
	jobjectArray array;
	jlong result;
	jthrowable abort;

	sread(&php_reflect, sizeof php_reflect,1, peer);
	sread(&invoke, sizeof invoke,1, peer);
	sread(&obj, sizeof obj,1, peer);
	sread(&method, sizeof method,1, peer);
	sread(&array, sizeof array,1, peer);
	sread(&result, sizeof result,1, peer);
	peer->tran=1;
	(*env)->CallVoidMethod(env, php_reflect, invoke, obj, method, array, result, (jlong)(long)peer);
	abort = (*env)->ExceptionOccurred(env);
	if(abort) {  /* connection aborted by client, java stack cleared */
	  (*env)->ExceptionClear(env);
	  peer->tran=0;
	  longjmp(peer->env, 1);
	}
	ID(peer, 0);
	break;
  }
  case CREATEOBJECT: {
	jobject php_reflect;
	jmethodID invoke;
	jstring method;
	jboolean createInstance;
	jobjectArray array;
	jlong result;
	jthrowable abort;

	sread(&php_reflect, sizeof php_reflect,1, peer);
	sread(&invoke, sizeof invoke,1, peer);
	sread(&method, sizeof method,1, peer);
	sread(&createInstance, sizeof createInstance,1, peer);
	sread(&array, sizeof array,1, peer);
	sread(&result, sizeof result,1, peer);
	peer->tran=1;
	(*env)->CallVoidMethod(env, php_reflect, invoke, method, createInstance, array, result, (jlong)(long)peer);
	abort = (*env)->ExceptionOccurred(env);
	if(abort) { /* connection aborted by client, java stack cleared */
	  (*env)->ExceptionClear(env);
	  peer->tran=0;
	  longjmp(peer->env, 1);
	}
	ID(peer, 0);
	break;
  }

  case ALLOCOBJECT: {
	jclass clazz;
	jobject result;
	sread(&clazz, sizeof clazz,1, peer);
	result = (*env)->AllocObject(env, clazz);
	swrite(&result, sizeof result, 1, peer);
	break;
  }
  case CALLOBJECTMETHOD: {
	jobject result;
	jobject obj;
	jmethodID methodID;
	short nargs;
	jvalue *args;
	sread(&nargs, sizeof nargs,1, peer);
	sread(&obj, sizeof obj, 1, peer);
	sread(&methodID, sizeof methodID,1, peer);
	args=calloc(nargs, sizeof*args);
	ASSERTM(args);
	sread(args, sizeof *args,nargs, peer);
	result = (*env)->CallObjectMethodA(env, obj, methodID, args);
	swrite(&result, sizeof result, 1, peer);
	free(args);
	break;
  }
  case CALLVOIDMETHOD: {
	jobject obj;
	jmethodID methodID;
	short nargs;
	jvalue *args;
	sread(&nargs, sizeof nargs, 1, peer);
	sread(&obj, sizeof obj, 1, peer);
	sread(&methodID, sizeof methodID, 1, peer);
	args=calloc(nargs, sizeof*args);
	ASSERTM(args);
	sread(args, sizeof *args, nargs, peer);
	(*env)->CallVoidMethodA(env, obj, methodID, args);
	free(args);
	break;
  }
  case DELETEGLOBALREF: {
	long c;
	jobject ref, ob, ob2;
	sread(&ref, sizeof ref, 1, peer);
	(*env)->DeleteGlobalRef(env, ref);
	ob = objFromPtr(env, ref);
	ob2 = (*env)->CallObjectMethod(env, peer->globalRef, hashRemove, ob);
	assert(ob2);
	c = (long)ptrFromObj(env,(void*)ob2);
	assert(c>0);
	if(--c>0) {
	  jobject val = objFromPtr(env, (void*)c);
	  assert(val);
	  if(val) {
		(*env)->CallObjectMethod(env, peer->globalRef, hashPut, ob, val);
		(*env)->DeleteLocalRef(env, val);
	  }
	}
	break;
  }
  case EXCEPTIONCLEAR: {
	(*env)->ExceptionClear(env);
	break;
  }
  case EXCEPTIONOCCURRED: {
	jthrowable result;
	result = (*env)->ExceptionOccurred(env);
	swrite(&result, sizeof result, 1, peer);
	break;
  }
  case FINDCLASS: {
	jclass clazz;
	size_t len;
	char *name;
	sread(&len, sizeof len, 1, peer);
	name=malloc(len+1);
	ASSERTM(name);
	sread(name, sizeof *name, len, peer);
	name[len]=0;
	clazz = (*env)->FindClass(env, name); 
	swrite(&clazz, sizeof clazz, 1, peer);
	free(name);
	break;
  }
  case GETARRAYLENGTH: {
	jsize result;
	jarray array;
	sread(&array, sizeof array, 1, peer);
	result = (*env)->GetArrayLength(env, array);
	swrite(&result, sizeof result, 1, peer);
	break;
  }
  case GETBYTEARRAYELEMENTS: {
	jobject ob1, ob2;
	void *key;
	jbyte *result;
	jboolean isCopy;
	jbyteArray array;
	size_t count;
	sread(&array, sizeof array, 1, peer);
	count = (*env)->GetArrayLength(env, array);
	result = (*env)->GetByteArrayElements(env, array, &isCopy);
	isCopy=JNI_TRUE;
	swrite(&isCopy, sizeof isCopy, 1, peer);
	swrite(&count, sizeof count, 1, peer);
	swrite(result, sizeof *result, count, peer);
	sread(&key, sizeof key, 1, peer);

	ob1=objFromPtr(env, key);
	ob2=objFromPtr(env, result);
	assert(ob1 && ob2);
	if(!ob1 || !ob2) return -41;
	(*env)->CallObjectMethod(env, getObjectHash(peer), hashPut, ob1, ob2);
	break;
  }
  case GETMETHODID: { 
	jmethodID id;
	jclass clazz;
	size_t len;
	char *name;
	char *sig;
	sread(&clazz, sizeof clazz, 1, peer);
	sread(&len, sizeof len, 1, peer);
	name=malloc(len+1);
	ASSERTM(name);
	sread(name, sizeof*name, len, peer);
	name[len]=0;
	sread(&len,sizeof len, 1, peer);
	sig=malloc(len+1);
	ASSERTM(sig);
	sread(sig, sizeof*sig, len, peer);
	sig[len]=0;
	id = (*env)->GetMethodID(env, clazz, name, sig);
	swrite(&id, sizeof id, 1, peer);
	free(name);
	free(sig);
	break;
  }
  case GETOBJECTCLASS: {
	jclass result;
	jobject obj;
	sread(&obj, sizeof obj, 1, peer);
	result = (*env)->GetObjectClass(env, obj);
	swrite(&result, sizeof result, 1, peer);
	break;
  }
  case GETSTRINGUTFCHARS: {
	jobject ob1, ob2;
	void *key;
	jboolean isCopy;
	char*result;
	size_t length;
	jstring str;
	sread(&str, sizeof str, 1, peer);
	result = (char*)(*env)->GetStringUTFChars(env, str, &isCopy);
	isCopy=JNI_TRUE;
	swrite(&isCopy, sizeof isCopy, 1, peer);
	length=(*env)->GetStringUTFLength(env, str);
	swrite(&length, sizeof length, 1, peer);
	swrite(result, sizeof*result, length, peer);
	sread(&key, sizeof key, 1, peer);
	ob1=objFromPtr(env, key);
	ob2=objFromPtr(env, result);
	if(!ob1||!ob2) return -41;
	(*env)->CallObjectMethod(env, getObjectHash(peer), hashPut, ob1, ob2);
	break;
  }
  case NEWBYTEARRAY: {
	jbyteArray result;
	jsize len;
	sread(&len, sizeof len, 1, peer);
	result = (*env)->NewByteArray(env, len);
	swrite(&result, sizeof result, 1, peer);
	break;
  }
  case NEWGLOBALREF: {
	jobject result;
	jobject obj, ob, ob2;
	sread(&obj, sizeof obj, 1, peer);
	result = (*env)->NewGlobalRef(env, obj);
	ob=objFromPtr(env, result);
	swrite(&result, sizeof result, 1, peer);
	assert(ob);
	ob2=(*env)->CallObjectMethod(env, peer->globalRef, hashRemove, ob);
	if(ob&&ob2) {
	  long c = (long)ptrFromObj(env,ob2);
	  ob2 = objFromPtr(env,(void*)(++c));
	  assert(ob2);
	  if(ob2) {
		(*env)->CallObjectMethod(env, peer->globalRef, hashPut, ob, ob2);
		(*env)->DeleteLocalRef(env, ob2);
	  }		
	} else {
	  ob2 = objFromPtr(env,(void*)1);
	  assert(ob2);
	  if(ob&&ob2) { 
		(*env)->CallObjectMethod(env, peer->globalRef, hashPut, ob, ob2);
		(*env)->DeleteLocalRef(env, ob2);
	  }
	}
	break;
  }
  case NEWOBJECT: {
	jobject result;
	jclass clazz;
	jmethodID methodID;
	short count;
	jvalue *args;
	sread(&count, sizeof count, 1, peer);
	sread(&clazz, sizeof clazz, 1, peer);
	sread(&methodID, sizeof methodID, 1, peer);
	args=calloc(count, sizeof *args);
	ASSERTM(args);
	sread(args, sizeof *args, count, peer);
	result= (*env)->NewObjectA(env, clazz, methodID, args);
	swrite(&result, sizeof result, 1, peer);
	free(args);
	break;
  }
  case NEWOBJECTARRAY: {
	jobjectArray result;
	jsize len;
	jclass clazz;
	jobject init;
	sread(&len, sizeof len, 1, peer);
	sread(&clazz, sizeof clazz, 1, peer);
	sread(&init, sizeof init, 1, peer);
	result = (*env)->NewObjectArray(env, len, clazz, init);
	swrite(&result, sizeof result, 1, peer);
	break;
  } 
  case NEWSTRINGUTF: {
	jstring result;
	size_t len;
	char *utf;
	sread(&len, sizeof len, 1, peer);
	utf=malloc(len+1);
	ASSERTM(utf);
	sread(utf, sizeof*utf, len, peer);
	utf[len]=0;
	result = (*env)->NewStringUTF(env, utf);
	swrite(&result, sizeof result, 1, peer);
	free(utf);
	break;
  }
  case RELEASEBYTEARRAYELEMENTS: {
	jobject val, ob;
	jbyteArray array;
	jbyte *elems;
	jint mode;
	sread(&array, sizeof array, 1, peer);
	sread(&elems, sizeof elems, 1, peer);
	sread(&mode, sizeof mode, 1, peer);
	ob=objFromPtr(env, elems);
	assert(ob); if(!ob) return -41;
	val = (*env)->CallObjectMethod(env, getObjectHash(peer), hashRemove, ob);
	assert(val); if(!val) return -41;
	assert(!mode);
	(*env)->ReleaseByteArrayElements(env, array, ptrFromObj(env, val), mode);
	(*env)->DeleteLocalRef(env, val);
	(*env)->DeleteLocalRef(env, ob);
	break;
  }
  case RELEASESTRINGUTFCHARS: {
	jobject val, ob;
	jstring array;
	char*elems;
	sread(&array, sizeof array, 1, peer);
	sread(&elems, sizeof elems, 1, peer);
	ob=objFromPtr(env, elems);
	if(!ob) return -41;
	val = (*env)->CallObjectMethod(env, getObjectHash(peer), hashRemove, ob);
	assert(val);
	if(!val) return -41;
	(*env)->ReleaseStringUTFChars(env, array, ptrFromObj(env, val));
	(*env)->DeleteLocalRef(env, val);
	(*env)->DeleteLocalRef(env, ob);
	break;
  }
  case SETBYTEARRAYREGION: {
	jbyteArray array;
	jsize start;
	jsize len;
	jbyte *buf;
	sread(&array, sizeof array, 1, peer);
	sread(&start, sizeof start, 1, peer);
	sread(&len, sizeof len, 1, peer);
	buf=calloc(len, sizeof*buf);
	ASSERTM(buf);
	sread(buf, sizeof*buf, len, peer);
	(*env)->SetByteArrayRegion(env, array, start, len, buf);
	free(buf);
	break;
  }
  case SETOBJECTARRAYELEMENT: {
	jobjectArray array;
	jsize index;
	jobject val;
	sread(&array, sizeof array, 1, peer);
	sread(&index, sizeof index, 1, peer);
	sread(&val, sizeof val, 1, peer);
	(*env)->SetObjectArrayElement(env, array, index, val);
	break;
  }
  case ISINSTANCEOF: {
	jobject obj, clazz;
	jclass clazz1;
	jboolean result;
	sread(&obj, sizeof obj, 1, peer);
	sread(&clazz, sizeof clazz, 1, peer);
	/* jni crashes if we pass an object object instead of a class
	   object  */
	clazz1 = (*env)->CallStaticObjectMethod(env, bridge, getClass, clazz);
	result = clazz1 ? (*env)->IsInstanceOf(env, obj, clazz1) : JNI_FALSE;
	swrite(&result, sizeof result, 1, peer);
	break;
  }
  case TRANSACTION_BEGIN: 
  case TRANSACTION_END: 
	return c;

  default: {
	logError(env, "protocol error: recv unknown token");
  }
  }
  return 1;
}

JNIEXPORT jint JNICALL Java_JavaBridge_handleRequest(JNIEnv*env, jclass self, jobject globalRef, jlong socket)
{
  SFILE *file = (SFILE*)(long)socket;
  struct peer peer;
  int val=40;
  peer.objectHash=0;
  peer.stream=file;
  peer.jenv=env;
  peer.tran=0;
  peer.globalRef=globalRef;
  val=setjmp(peer.env);
  if(val) {
  _exit: 
	if (peer.objectHash && peer.objectHash!=globalRef) 
	  (*env)->DeleteGlobalRef(env, peer.objectHash);
	return -val;
  }
  val=handle_request(&peer, env);
  if (peer.objectHash && peer.objectHash!=globalRef) 
	(*env)->DeleteGlobalRef(env, peer.objectHash);
  return val;
}
static void logIntValue(JNIEnv*env, char*t, unsigned long i) {
  char*s;
  if(logLevel<=3) return;

  s=malloc(160);
  assert(s);
  if(!s) return;
  sprintf(s, "%s: %lx",t,i);
  logDebug(env, s);
  free(s);
}

static void connection_cleanup (JNIEnv *env, jobject globalRef) {
  long c;
  jobject enumeration, ref, ob2;
  /* cleanup global refs that the client left */
  enumeration=(*env)->CallObjectMethod(env, globalRef, hashKeys);
  while((*env)->CallBooleanMethod(env, enumeration, enumMore)) {
	ref = (*env)->CallObjectMethod(env, enumeration, enumNext);
	ob2=(*env)->CallObjectMethod(env, globalRef, hashRemove, ref);
	assert(ob2);
	if(ob2) {
	  c = (int)ptrFromObj(env,ob2);
	  assert(c>0);
	  while(c-->0) {
		(*env)->DeleteGlobalRef(env, ptrFromObj(env,ref));
	  }
	}
  }
}
JNIEXPORT jboolean JNICALL Java_JavaBridge_trampoline(JNIEnv*env, jclass self, jobject globalRef, jlong socket, jboolean jump)
{
  SFILE *peer = (SFILE*)(long)socket;
  while(peer && !SFEOF(peer)) {
	jint term;
	if(SFERROR(peer)) { logSysError(env, "communication error"); break; }
    term = (jump==JNI_TRUE) ? 
	  (*env)->CallStaticIntMethod(env, bridge, handleRequest, globalRef, socket) : 
	  Java_JavaBridge_handleRequest(env, bridge, globalRef, socket);
	  
	if(term>=0) {
	  logIntValue(env, "end packet", term);
	  switch (term) { 
	  case TRANSACTION_BEGIN: 
		if((*env)->CallStaticBooleanMethod(env, bridge, trampoline, 
										globalRef, socket, JNI_FALSE)==JNI_FALSE) return JNI_FALSE;
		break;
	  case TRANSACTION_END:
		return JNI_TRUE;
	  }
	} else {
	  logIntValue(env, "communication broken", term);
	  return JNI_FALSE;
	}
  }
  assert(0);
  return JNI_FALSE;
}

#ifdef HAVE_STRUCT_UCRED

/* Prepare the socket to receive auth information directly from the
   kernel. 
 */
static int prep_cred(int sock) {
  static const int true = 1;
  int ret = setsockopt(sock, SOL_SOCKET, SO_PASSCRED, (void*)&true, sizeof true);
  return ret;
}

/* Receive authentification information (enforced by the BSD or Linux
   kernel). It is impossible to fake the auth information.
 */
static int recv_cred(int sock, int *uid, int *gid) {
  struct ucred ucred;
  socklen_t so_len = sizeof ucred;
  int n = getsockopt(sock, SOL_SOCKET, SO_PEERCRED, &ucred, &so_len);
  int ret = (n==-1 || so_len!=sizeof ucred) ? -1 : 0;
  if(ret!=-1) {
	*uid=ucred.uid;
	*gid=ucred.gid;
  }  
  return ret;
}
#else  /* struct ucred missing */
#define prep_cred(a) 0
#define recv_cred(a, b, c) 0
#endif

JNIEXPORT void JNICALL Java_JavaBridge_handleRequests(JNIEnv*env, jobject instance, jobject globalRef, jint socket, jint uid, jint gid)
{
  SFILE *peer = SFDOPEN(socket, "r+");
  if(!peer) {logSysFatal(env, "could not fdopen socket"); return;}

  logIntValue(env, "create new communication channel", (unsigned long)peer);

  if(peer && (SFWRITE(&instance, sizeof instance, 1, peer)!=1)) {
	logSysFatal(env, "could not send instance, child not listening"); connection_cleanup(env, globalRef); SFCLOSE(peer);return;
  }
  enter();
  (*env)->CallStaticBooleanMethod(env, bridge, trampoline, globalRef, (jlong)(long)peer, JNI_TRUE);
  connection_cleanup(env, globalRef);

  logIntValue(env, "terminate communication channel", (unsigned long)peer);
  if(peer) SFCLOSE(peer);

  leave();
}


#ifndef __MINGW32__
static void post(int i) {
  sem_post((sem_t*)&cond_sig);
  signal(SIGTERM, SIG_DFL);
}
#endif

JNIEXPORT jboolean JNICALL Java_JavaBridge_openLog
  (JNIEnv *env, jclass self, jstring _logfile)
{
#ifndef __MINGW__
  char*logfile=NULL;

  assert(_logfile);

  if(_logfile!=NULL) {
	jboolean isCopy;
	const char*sname = (*env)->GetStringUTFChars(env, _logfile, &isCopy);
	logfile=strdup(sname);
	(*env)->ReleaseStringUTFChars(env, _logfile, sname);
  } else {
	char *s = LOGFILE;
	if(s && strlen(s)>0) logfile = strdup(s);
  }

  if(logfile) {
	int fd, null;
	fd = open(logfile, O_WRONLY | O_CREAT | O_APPEND | O_TRUNC, 0644);
	if(fd==-1) return JNI_FALSE;
	null = open("/dev/null", O_RDONLY);
	if(null!=-1) dup2 (null,0); 
	if(fd!=-1) { 
	  if(dup2(fd,1)==-1) return JNI_FALSE;
	  if(dup2(fd,2)==-1) return JNI_FALSE;
	}
	return JNI_TRUE;
  }
#endif
  return JNI_FALSE;
}

JNIEXPORT void JNICALL Java_JavaBridge_startNative
  (JNIEnv *env, jclass self, jint _logLevel, jstring _sockname)
{
#ifndef CFG_JAVA_SOCKET_INET
  struct sockaddr_un saddr;
#else
  struct sockaddr_in saddr;
#endif
  int sock, n;
  SFILE *peer;

  logLevel = _logLevel;
  bridge = self;
  initGlobals(env);

#ifndef __MINGW32__
  signal(SIGTERM, post);
#endif

  if(_sockname!=NULL) {
	jboolean isCopy;
	const char*sname = (*env)->GetStringUTFChars(env, _sockname, &isCopy);
	sockname=strdup(sname);
	(*env)->ReleaseStringUTFChars(env, _sockname, sname);
  } else {
	char *s = SOCKNAME;
	sockname = strdup(s);
  }
  /* socket */
#ifndef CFG_JAVA_SOCKET_INET
  saddr.sun_family = AF_LOCAL;
  memset(saddr.sun_path, 0, sizeof saddr.sun_path);
  strcpy(saddr.sun_path, sockname);
# ifndef HAVE_ABSTRACT_NAMESPACE
  unlink(sockname);
# else
  *saddr.sun_path=0;
# endif
  sock = socket (PF_LOCAL, SOCK_STREAM, 0);
  if(!sock) {logSysFatal(env, "could not create socket"); return;}
  if (-1==prep_cred(sock)) logSysFatal(env, "socket cannot receive credentials");
#else
  saddr.sin_family = AF_INET;
  saddr.sin_port=htons(atoi(sockname));
  saddr.sin_addr.s_addr = inet_addr( "127.0.0.1" );
  sock = socket (PF_INET, SOCK_STREAM, 0);
  if(!sock) {logSysFatal(env, "could not create socket"); return;}
#endif
  n = bind(sock,(struct sockaddr*)&saddr, sizeof saddr);
  if(n==-1) {logSysFatal(env, "could not bind socket"); return;}
#if !defined(HAVE_ABSTRACT_NAMESPACE) && !defined(CFG_JAVA_SOCKET_INET)
  chmod(sockname, 0666); // the childs usually run as "nobody"
#endif
  n = listen(sock, 20);
  if(n==-1) {logSysFatal(env, "could not listen to socket"); return;}

  while(1) {
	int socket, uid=-1, gid=-1;

  res:errno=0; 
	socket = accept(sock, NULL, 0); 
#ifndef __MINGW32__
	if(bridge_shutdown) while(1) sleep(65535);
#endif
	if(socket==-1) {
	  if(errno==EINTR) goto res; // Solaris, see INN FAQ

	  logSysFatal(env, "socket accept failed"); 
	  return;
	}
	if(-1==recv_cred(socket, &uid, &gid)) logSysFatal(env, "could not get credentials");
    (*env)->CallStaticVoidMethod(env, bridge, handleRequests,socket, uid, gid);
  }
}


JNIEXPORT void JNICALL Java_JavaBridge_setResultFromString
  (JNIEnv *env, jclass self, jlong result, jlong _peer, jbyteArray value)
{
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return;
  ID(peer, SETRESULTFROMSTRING);
  swrite(&result, sizeof result, 1, peer);
  swrite(&value, sizeof value, 1, peer);
  while(handle_request(peer, env));
}

JNIEXPORT void JNICALL Java_JavaBridge_setResultFromLong
  (JNIEnv *env, jclass self, jlong result, jlong _peer, jlong value)
{
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return;
  ID(peer, SETRESULTFROMLONG);
  swrite(&result, sizeof result, 1, peer);
  swrite(&value, sizeof value, 1, peer);
  while(handle_request(peer, env));
}

JNIEXPORT void JNICALL Java_JavaBridge_setResultFromDouble
  (JNIEnv *env, jclass self, jlong result, jlong _peer, jdouble value)
{
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return;
  ID(peer, SETRESULTFROMDOUBLE);
  swrite(&result, sizeof result, 1, peer);
  swrite(&value, sizeof value, 1, peer);
  while(handle_request(peer, env));
}

JNIEXPORT void JNICALL Java_JavaBridge_setResultFromBoolean
  (JNIEnv *env, jclass self, jlong result, jlong _peer, jboolean value)
{
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return;
  ID(peer, SETRESULTFROMBOOLEAN);
  swrite(&result, sizeof result, 1, peer);
  swrite(&value, sizeof value, 1, peer);
  while(handle_request(peer, env));
}

JNIEXPORT void JNICALL Java_JavaBridge_setResultFromObject
  (JNIEnv *env, jclass self, jlong result, jlong _peer, jobject value)
{
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return;
  ID(peer, SETRESULTFROMOBJECT);
  swrite(&result, sizeof result, 1, peer);
  swrite(&value, sizeof value, 1, peer);
  while(handle_request(peer, env));
}

JNIEXPORT jboolean JNICALL Java_JavaBridge_setResultFromArray
  (JNIEnv *env, jclass self, jlong result, jlong _peer, jobject value)
{
  jboolean send_content;
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return JNI_FALSE;
  ID(peer, SETRESULTFROMARRAY);
  swrite(&result, sizeof result, 1, peer);
  swrite(&value, sizeof value, 1, peer);
  sread(&send_content, sizeof send_content, 1, peer);
  while(handle_request(peer, env));
  return send_content;
}

/*
 * The following is from Sam Ruby's original PHP 4 code. When the
 * result was an array or Hashtable, the ext/java extension copied the
 * entire(!) array or hash to the PHP interpreter.  Since PHP 5 this
 * is dead code.
 */
#ifndef DISABLE_DEPRECATED
JNIEXPORT jlong JNICALL Java_JavaBridge_nextElement
  (JNIEnv *env, jclass self, jlong array, jlong _peer)
{
  jlong result;
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return 0;
  ID(peer, NEXTELEMENT);
  swrite(&array, sizeof array, 1, peer);
  while(handle_request(peer, env));
  sread(&result, sizeof result, 1, peer);
  while(handle_request(peer, env));
  return result;
}

JNIEXPORT jlong JNICALL Java_JavaBridge_hashIndexUpdate
  (JNIEnv *env, jclass self, jlong array, jlong _peer, jlong key)
{
  jlong result;
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return 0;
  ID(peer, HASHINDEXUPDATE);
  swrite(&array, sizeof array, 1, peer);
  swrite(&key, sizeof key, 1, peer);
  while(handle_request(peer, env));
  sread(&result, sizeof result, 1, peer);
  while(handle_request(peer, env));
  return result;
}
JNIEXPORT jlong JNICALL Java_JavaBridge_hashUpdate
  (JNIEnv *env, jclass self, jlong array, jlong _peer, jbyteArray key)
{
  jlong result;
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return 0;
  ID(peer, HASHUPDATE);
  swrite(&array, sizeof array, 1, peer);
  swrite(&key, sizeof key, 1, peer);
  while(handle_request(peer, env));
  sread(&result, sizeof result, 1, peer);
  while(handle_request(peer, env));
  return result;
}
#endif /* DISABLE_DEPRECATED */

JNIEXPORT void JNICALL Java_JavaBridge_setException
  (JNIEnv *env, jclass self, jlong result, jlong _peer, jthrowable value, jbyteArray strValue)
{
  struct peer*peer=(struct peer*)(long)_peer;
  if(setjmp(peer->savepoint)) return;
  ID(peer, SETEXCEPTION);
  swrite(&result, sizeof result, 1, peer);
  swrite(&value, sizeof value, 1, peer);
  swrite(&strValue, sizeof strValue, 1, peer);
  while(handle_request(peer, env));
}
JNINativeMethod javabridge[]={
  {"setResultFromString", "(JJ[B)V", Java_JavaBridge_setResultFromString},
  {"setResultFromLong", "(JJJ)V", Java_JavaBridge_setResultFromLong},
  {"setResultFromDouble", "(JJD)V", Java_JavaBridge_setResultFromDouble},
  {"setResultFromBoolean", "(JJZ)V", Java_JavaBridge_setResultFromBoolean},
  {"setResultFromObject", "(JJLjava/lang/Object;)V", Java_JavaBridge_setResultFromObject},
  {"setResultFromArray", "(JJLjava/lang/Object;)Z", Java_JavaBridge_setResultFromArray},
  {"nextElement", "(JJ)J", Java_JavaBridge_nextElement},
  {"hashUpdate", "(JJ[B)J", Java_JavaBridge_hashUpdate},
  {"hashIndexUpdate", "(JJJ)J", Java_JavaBridge_hashIndexUpdate},
  {"setException", "(JJLjava/lang/Throwable;[B)V", Java_JavaBridge_setException},
  {"startNative", "(ILjava/lang/String;)V", Java_JavaBridge_startNative},
  {"handleRequests", "(Ljava/lang/Object;III)V", Java_JavaBridge_handleRequests},
  {"handleRequest", "(Ljava/lang/Object;J)I", Java_JavaBridge_handleRequest},
  {"trampoline", "(Ljava/lang/Object;JZ)Z", Java_JavaBridge_trampoline},
  {"openLog", "(Ljava/lang/String;)Z", Java_JavaBridge_openLog},
};

static struct NativeMethods {
  char*class;
  JNINativeMethod*meth;
  int n;
} meths[]={
  {"JavaBridge", javabridge, (sizeof javabridge)/(sizeof *javabridge)},
};

static void jniRegisterNatives (JNIEnv *env)
{
  int i;
  jint r;
  jclass k;

  for(i=0; i<((sizeof meths)/(sizeof*meths)); i++) {
	k = (*env)->FindClass (env, meths[i].class);
	assert(k); if(!k) exit(9);
	r = (*env)->RegisterNatives (env, k, meths[i].meth, meths[i].n);
	assert(r==JNI_OK); if(r!=JNI_OK) exit(9);
  }
}

void java_bridge_main(int argc, char**argv) 
{
  JavaVMOption options[3];
  JavaVM *jvm;
  JNIEnv *jenv;
  JavaVMInitArgs vm_args; /* JDK 1.2 VM initialization arguments */
  jclass reflectClass, stringClass;
  jobjectArray arr;
  jmethodID init;
  int i, err, off;
  vm_args.version = JNI_VERSION_1_2; /* New in 1.1.2: VM version */
  /* Get the default initialization arguments and set the class 
   * path */
  JNI_GetDefaultJavaVMInitArgs(&vm_args);
  vm_args.nOptions=0;
  vm_args.options=options;
  if(argv[1]) vm_args.options[vm_args.nOptions++].optionString=argv[1];
  if(argv[2]) vm_args.options[vm_args.nOptions++].optionString=argv[2];
  if(argv[3]) vm_args.options[vm_args.nOptions++].optionString=argv[3];
  vm_args.ignoreUnrecognized=JNI_TRUE;

  /* load and initialize a Java VM, return a JNI interface 
   * pointer in env */
  err=JNI_CreateJavaVM(&jvm, (void*)&jenv, &vm_args);
  assert(!err); if(err) exit(9);
  jniRegisterNatives(jenv);
  reflectClass = (*jenv)->FindClass(jenv, "JavaBridge");
  assert(reflectClass); if(!reflectClass) exit(9);
  init = (*jenv)->GetStaticMethodID(jenv, reflectClass, "init", "([Ljava/lang/String;)V");
  assert(init); if(!init) exit(9);
  stringClass = (*jenv)->FindClass(jenv, "java/lang/String");
  assert(stringClass); if(!stringClass) exit(9);
  arr = (*jenv)->NewObjectArray(jenv, argc, stringClass, 0);
  assert(arr); if(!arr) exit(9);

  off = N_SARGS-4;
  for (i=0; (i+6)<argc; i++) {
	jstring arg;
	if(!argv[i+off]) break;
    arg = (*jenv)->NewStringUTF(jenv, argv[i+off]);
	assert(arg); if(!arg) exit(9);
    (*jenv)->SetObjectArrayElement(jenv, arr, i, arg);
  }
  (*jenv)->CallStaticVoidMethod(jenv, reflectClass, init, arr);
  (*jvm)->DestroyJavaVM(jvm);

  assert(0);
  while(1)			  /* DestroyJavaVM should already block forever */
	sleep(65535);
}

void java_bridge_main_gcj(int argc, char**_argv) 
{
  char **argv;
  /* someone should really fix this bug in gcj */
  meths[0].meth[4].signature="(JJLjava.lang.Object;)V";
  meths[0].meth[5].signature="(JJLjava.lang.Object;)Z";
  meths[0].meth[9].signature="(JJLjava.lang.Throwable;[B)V";
  meths[0].meth[10].signature="(ILjava.lang.String;)V";
  meths[0].meth[11].signature="(Ljava.lang.Object;III)V";
  meths[0].meth[12].signature="(Ljava.lang.Object;J)I";
  meths[0].meth[13].signature="(Ljava.lang.Object;JZ)Z";
  meths[0].meth[14].signature="(Ljava.lang.String;)Z";

  if(!_argv) exit(6);
  if(argc==4) {
	argv=calloc(N_SARGS, sizeof*argv);
	argv[N_SARGS-4]=_argv[1];			/* socketname */
	argv[N_SARGS-3]=_argv[2];			/* logLevel */
	argv[N_SARGS-2]=_argv[3];			/* logFile */
	argv[N_SARGS-1]=0;					/* last arg */
  } else {
	argv=_argv;
  }
  java_bridge_main(N_SARGS, argv);
}
@


1.42
log
@attempt toh handle solaris EINTR
@
text
@d996 6
a1001 2
	if(errno==EINTR) goto res; // Solaris, see INN FAQ
	if(socket==-1) {logSysFatal(env, "socket accept failed"); return;}
@


1.41
log
@Release-1.0.8
@
text
@d996 1
a997 1
	//if(errno) goto res;
@


1.40
log
@Release-1.0.8
@
text
@d143 1
a143 1
  if(!bridge) return;
d151 1
a151 1
  if(!bridge) return;
d159 1
a159 1
  if(!bridge) return;
d213 2
a214 1
  assert(obj);
d224 4
a227 1
  char*s=malloc(20);
d337 8
d350 1
a350 1
  if(logLevel>=4) logRcv(env, c);
d543 1
a543 1
	(*env)->CallObjectMethod(env, peer->objectHash, hashPut, ob1, ob2);
d595 1
a595 1
	(*env)->CallObjectMethod(env, peer->objectHash, hashPut, ob1, ob2);
d686 1
a686 1
	val = (*env)->CallObjectMethod(env, peer->objectHash, hashRemove, ob);
d702 1
a702 1
	val = (*env)->CallObjectMethod(env, peer->objectHash, hashRemove, ob);
d764 1
a764 2
  peer.objectHash=initHash(env);
  if(!peer.objectHash) {logFatal(env, "could not create hash table"); goto _exit;}
d772 2
a773 1
	(*env)->DeleteGlobalRef(env, peer.objectHash);
d777 2
a778 1
  (*env)->DeleteGlobalRef(env, peer.objectHash);
d782 4
a785 1
  char*s=malloc(160);
a791 10
static void logChannel(JNIEnv*env, char*t, unsigned long i) {
 if(logLevel>2) logIntValue(env, t, i);
}

static jobject connection_startup(JNIEnv *env) {
  jobject hash = (*env)->NewObject(env, hashClass, init);
  jobject globalRef = (*env)->NewGlobalRef(env, hash);

  return globalRef;
}
a809 1
  (*env)->DeleteGlobalRef(env, globalRef);
d822 1
a822 1
	  logChannel(env, "end packet", term);
d870 1
a870 1
JNIEXPORT void JNICALL Java_JavaBridge_handleRequests(JNIEnv*env, jobject instance, jint socket, jint uid, jint gid)
a871 1
  jobject globalRef;
d875 1
a875 3
  logChannel(env, "create new communication channel", (unsigned long)peer);
  globalRef = connection_startup(env);
  if(!globalRef){logFatal(env, "could not allocate global hash");if(peer) SFCLOSE(peer);return;}
d884 1
a884 1
  logChannel(env, "terminate communication channel", (unsigned long)peer);
d1147 1
a1147 1
  {"handleRequests", "(III)V", Java_JavaBridge_handleRequests},
d1234 1
@


1.39
log
@Release-1.0.8
@
text
@d751 1
a751 1
  int val;
d753 1
a753 1
  if(!peer.objectHash) {logFatal(env, "could not create hash table"); return -40;}
d760 1
@


1.38
log
@*** empty log message ***
@
text
@d837 1
a837 2
   kernel.  Will work on Solaris, Linux and modern BSD operating
   systems and only if the socket is of type LOCAL (UNIX). 
d969 1
a975 1
  if (-1==prep_cred(sock)) logSysFatal(env, "socket cannot receive credentials");
@


1.37
log
@use java security instead of dropping the process privileges
@
text
@d23 2
a24 1
#  ifndef HAVE_DECL_AF_LOCAL
d27 3
a29 1
#  ifndef HAVE_DECL_PF_LOCAL
d32 1
@


1.36
log
@secure mode
@
text
@d23 6
a46 1
#include <assert.h>
d59 5
a855 17

# ifdef JAVA_SECURE_MODE				
/* Drop privileges and run the request-handling thread with the same
   privileges that the authenticated user has.  WARNING: Some JVM's,
   for example IBM JDK1.4.1 or GNU Java 3.3.3 will crash when a java
   thread has non-default privileges.  However, this feature does work
   on Linux or BSD with Sun JDK >= 1.4.2_02 or Sun JDK >= 1.5 and you
   are encouraged to enable it whenever possible.
*/
static int set_cred(int uid, int gid) {
  int ret = setgid(gid);
  if(ret!=-1) ret = setuid(uid);
  return ret;
}
# else
# define set_cred(a, b) 0
# endif	/* secure mode */
a858 1
#define set_cred(a, b) 0
a865 2
  if(uid!=-1)
	if(-1==set_cred(uid, gid)) logSysFatal(env, "could drop privileges");
d979 1
a979 1
  n = listen(sock, 10);
@


1.35
log
@release 1.0.7
@
text
@d3 4
d220 1
a220 1
# if !defined(CFG_JAVA_SOCKET_ANON) && !defined(CFG_JAVA_SOCKET_INET)
d284 1
a284 1
  handleRequests = (*env)->GetStaticMethodID(env, bridge, "HandleRequests", "(J)V");
d819 51
a869 1
JNIEXPORT void JNICALL Java_JavaBridge_handleRequests(JNIEnv*env, jobject instance, jlong socket)
d872 4
a875 2
  SFILE *peer = (SFILE*)(long)socket;
  logChannel(env, "create new communication channel", socket);
d877 1
d885 1
a885 1
  (*env)->CallStaticBooleanMethod(env, bridge, trampoline, globalRef, socket, JNI_TRUE);
d888 1
a888 1
  logChannel(env, "terminate communication channel", socket);
d969 1
a969 1
# ifndef CFG_JAVA_SOCKET_ANON
d975 1
d981 2
a983 1
  if(!sock) {logSysFatal(env, "could not create socket"); return;}
d986 1
a986 1
#if !defined(CFG_JAVA_SOCKET_ANON) && !defined(CFG_JAVA_SOCKET_INET)
d993 1
a993 1
	int socket;
d1000 1
a1000 1
	if(socket==-1) {logSysError(env, "socket accept failed"); return;}
d1002 2
a1003 4
	peer = SFDOPEN(socket, "r+");
	if(!peer) {logSysFatal(env, "could not fdopen socket");goto res;}

    (*env)->CallStaticVoidMethod(env, bridge, handleRequests,(jlong)(long)peer);
d1151 1
a1151 1
  {"handleRequests", "(J)V", Java_JavaBridge_handleRequests},
@


1.34
log
@release 1.0.7
@
text
@d6 1
a6 1
#/* socket */
a299 1
	sigset_t d;
d512 1
a512 1
	if(!ob1 || !ob2) return;
d564 1
a564 1
	if(!ob1||!ob2) return;
d655 1
a655 1
	assert(ob); if(!ob) return;
d657 1
a657 1
	assert(val); if(!val) return;
d671 1
a671 1
	if(!ob) return;
d674 1
a674 1
	if(!val) return;
d714 1
a714 1
	result = (*env)->IsInstanceOf(env, obj, clazz1);
d838 1
d841 1
a841 1
  signal(SIGTERM, post);
d843 1
d894 1
d896 1
a896 1
  signal(SIGPWR, post);
@


1.33
log
@trampoline
@
text
@d8 3
d116 1
a116 2
  assert(logMessageID);
  if(!logMessageID) return;
d118 1
a118 2
  assert(str);
  if(!str) return; 
d282 1
a282 1
  trampoline = (*env)->GetStaticMethodID(env, bridge, "Trampoline", "(Ljava/lang/Object;JZ)V");
d788 1
a788 1
JNIEXPORT void JNICALL Java_JavaBridge_trampoline(JNIEnv*env, jclass self, jobject globalRef, jlong socket, jboolean jump)
d802 2
a803 1
		(*env)->CallStaticVoidMethod(env, bridge, trampoline, globalRef, socket, JNI_FALSE);
d806 1
a806 1
		return;
d810 1
a810 1
	  break;
d813 2
d829 1
a829 1
  (*env)->CallStaticVoidMethod(env, bridge, trampoline, globalRef, socket, JNI_TRUE);
d844 34
d1094 2
a1095 1
  {"trampoline", "(Ljava/lang/Object;JZ)V", Java_JavaBridge_trampoline},
d1180 2
a1181 1
  meths[0].meth[13].signature="(Ljava.lang.Object;JZ)V";
@


1.32
log
@php 5
@
text
@d79 2
d280 2
a460 7
  case DELETELOCALREF: {
	jobject ref;
	sread(&ref, sizeof ref, 1, peer);
	/* disabled, problems with gcj */
	//(*env)->DeleteLocalRef(env, ref);
	break;
  }
d718 4
d728 4
a731 1
static int handle_request_impl(SFILE*file, JNIEnv *env, jobject globalRef) {
d787 25
a811 1

d825 1
a825 9
  while(peer && !SFEOF(peer)) {
	if(SFERROR(peer)) { logSysError(env, "communication error"); break; }
	int term = handle_request_impl(peer, env, globalRef);
	if(term>=0) logChannel(env, "end packet", term);
	else {
	  logIntValue(env, "communication broken", term);
	  break;
	}
  }
d1055 2
d1140 3
a1142 1
	
@


1.31
log
@PHP5 iterator/array
@
text
@d84 2
d135 8
d148 5
d156 1
a156 1
  logError(jenv, s);
d288 2
d709 2
a710 2
	jobject obj;
	jclass clazz;
d714 4
a717 1
	result = (*env)->IsInstanceOf(env, obj, clazz);
d731 1
a731 1
  if(!peer.objectHash) {logError(env, "could not create hash table"); return -40;}
d791 1
a791 1
  if(!globalRef){logError(env, "could not allocate global hash");if(peer) SFCLOSE(peer);return;}
d794 1
a794 1
	logSysError(env, "could not send instance, child not listening"); connection_cleanup(env, globalRef); SFCLOSE(peer);return;
d864 1
a864 1
  if(!sock) {logSysError(env, "could not create socket"); return;}
d866 1
a866 1
  if(n==-1) {logSysError(env, "could not bind socket"); return;}
d871 1
a871 1
  if(n==-1) {logSysError(env, "could not listen to socket"); return;}
d881 1
a881 1
	if(socket==-1) {logDebug(env, "socket accept failed"); return;}
d884 1
a884 1
	if(!peer) {logSysError(env, "could not fdopen socket");goto res;}
d960 7
d1009 1
@


1.30
log
@php 4/5
@
text
@d484 1
a484 1
	jarray array;
d497 1
d634 1
a634 1
	jarray array;
d641 1
a641 1
	if(!ob) return;
d643 1
a643 2
	assert(val);
	if(!val) return;
d691 10
d926 2
a927 2
JNIEXPORT void JNICALL Java_JavaBridge_setResultFromArray
  (JNIEnv *env, jclass self, jlong result, jlong _peer)
d929 1
d931 1
a931 1
  if(setjmp(peer->savepoint)) return;
d934 2
d937 1
d1000 1
a1000 1
  {"setResultFromArray", "(JJ)V", Java_JavaBridge_setResultFromArray},
d1087 1
@


1.29
log
@php 4/5
@
text
@d357 1
d365 1
d369 1
a369 1
	(*env)->CallVoidMethod(env, php_reflect, invoke, method, array, result, (jlong)(long)peer);
@


1.28
log
@Version 1.1
@
text
@d29 1
d94 2
a95 1
static sigset_t block;
d201 4
a204 3
	pthread_attr_destroy(&attr);
	pthread_mutex_destroy(&mutex);
	pthread_cond_destroy(&cond);
d206 2
a207 2
	free(sockname);
	sockname=NULL;
a210 7
static void block_sig() {
#ifndef __MINGW32__
  sigset_t d;
  pthread_sigmask(SIG_BLOCK, &block, &d);
#endif
}

d231 6
a236 7
  int sig;
  block_sig();
#ifdef HAVE_SIGWAIT
  sigwait(&block, &sig);
#else
  sigsuspend(&block);
#endif
d238 1
a239 1
  count=-1;
d241 1
d284 1
a284 2
	sigemptyset(&block);
	sigaddset(&block, SIGTERM);
a755 1
  block_sig();
d783 4
d803 3
d845 1
d847 1
a847 3
	pthread_mutex_lock(&mutex);
	if(count==-1) {pthread_mutex_unlock(&mutex); return;}
	pthread_mutex_unlock(&mutex);
a848 1
	socket = accept(sock, NULL, 0); 
@


1.27
log
@PHP 5 support
@
text
@d969 1
a969 1
  (JNIEnv *env, jclass self, jlong result, jlong _peer, jbyteArray value)
d976 1
d989 1
a989 1
  {"setException", "(JJ[B)V", Java_JavaBridge_setException},
d1072 1
@


1.26
log
@win32/mingw
@
text
@d595 1
a595 1
	size_t len;
d597 1
a597 1
	sread(&len, sizeof len, 1, peer);
d600 1
a600 1
	args=calloc(len, sizeof *args);
d602 1
a602 1
	sread(args, sizeof *args, len, peer);
@


1.25
log
@Release-1.0.6
@
text
@d8 10
a17 6
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>

/* select */
#include <sys/select.h>
d27 3
a29 1
#include <pthread.h>
d37 8
d88 1
d91 1
a92 1
static int count=0;
d94 1
d195 4
a198 3
	unlink(sockname); 
	free(sockname);
	sockname=NULL;
d202 3
d209 1
d212 1
d216 1
d221 1
d225 1
d230 1
d234 1
d240 1
a240 1
  sigsuspend(&block); // FIXME
d246 1
a249 2
  pthread_t thread;
  sigset_t d;
d279 14
a292 8
  pthread_attr_init(&attr);
  pthread_cond_init(&cond, NULL);
  pthread_mutex_init(&mutex, NULL);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

  sigemptyset(&block);
  sigaddset(&block, SIGTERM);
  pthread_create(&thread, &attr, guard_requests, 0);
d793 1
d795 3
d815 2
a816 1
  saddr.sun_family = AF_UNIX;
d819 1
a819 1
#ifndef CFG_JAVA_SOCKET_ANON
d821 4
d826 4
a829 1
  *saddr.sun_path=0;
a830 1
  sock = socket (PF_UNIX, SOCK_STREAM, 0);
d834 1
a834 1
#ifndef CFG_JAVA_SOCKET_ANON
d844 1
d848 1
@


1.24
log
@correct type
@
text
@d736 1
a736 1
	logSysError(env, "could not send instance, child not listening"); SFCLOSE(peer);return;
a764 6
  /* catch signals not used by the VM, see
	 http://www-106.ibm.com/developerworks/ibm/library/i-signalhandling/
     (exit will call our atexit_bridge)
  */
  signal(SIGABRT, exit);

@


1.23
log
@an interrupted system call is not a system error
@
text
@d1034 1
a1034 1
  if(!argv) exit(6);
@


1.22
log
@Load libraries from /usr/share/java or from ext_dir/lib
@
text
@d811 1
a811 1
	if(socket==-1) {logSysError(env, "socket accept failed"); return;}
@


1.21
log
@Solaris and Win98 support
@
text
@d45 5
d225 2
d242 5
@


1.20
log
@only catch SIGABRT, all other signals are used by the VM
@
text
@d205 1
d207 3
@


1.19
log
@error messages
@
text
@d749 5
a753 5
  signal(SIGBUS, exit);
  signal(SIGILL, exit);
  /* do not catch these, the VM uses them internally */
  /*   signal(SIGSEGV, exit); */
  /*   signal(SIGPWR, exit); */
@


1.18
log
@threads check
@
text
@a713 1
  enter();
d722 1
@


1.17
log
@solaris 64
@
text
@a2 4
#ifndef _POSIX_PTHREAD_SEMANTICS
#define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */
#endif

@


1.16
log
@Added support for Slowlaris' broken stdio:
SFREAD SFWRITE SFDOPEN SFCLOSE SFEOF SFERROR: Use these instead of the stdio
versions.  On Solaris these functions access the raw socket, which is slow
but at least it works
@
text
@d3 4
@


1.15
log
@Fixed a bug that appeared on Slowlaris 9 stdio implementations.

From the BSD fopen(3) manpage (solaris' own manpage is pretty useless):

     Reads and writes may be intermixed on read/write streams in any order,
     and do not require an intermediate seek as in previous versions of stdio.
     This is not portable to other systems, however; ANSI C requires that a
     file positioning function intervene between output and input, unless an
     input operation encounters end-of-file.


One of these "other systems" is solaris 9. From Linux' manpage:

       Reads  and writes may be intermixed on read/write streams in any order.
       Note that ANSI C requires that a file  positioning  function  intervene
       between  output and input, unless an input operation encounters end-of-
       file.  (If this condition is not met, then a read is allowed to  return
       the result of writes other than the most recent.)  Therefore it is good
       practice (and indeed sometimes necessary under Linux) to put  an  fseek
       or  fgetpos  operation  between  write  and  read  operations on such a
       stream.  This operation may be an apparent no-op (as in fseek(...,  0L,
       SEEK_CUR) called for its synchronizing side effect.

The problem is that the above paragraph does not apply to fdopen'ed streams
because these streams are not seekable.  Applying a seek operation on a
socket stream generates an error:

From Nathan Kurz:

 Ok, so I'll put one in.  But everything I try comes back with an error that the
 operation is not permitted.  I've tried all the combinations of fseek() and
 fsetpos() that I can think of (to the current position, to the beginning, the
 end) but (logically enough) none are supported.


So one cannot use fseek on sockets streams. That's why *all* stdio
implementations, except Solaris' do *not* require fseek() anymore.


But that still does not solve our problem; we must rewind the Solaris stdio
buffers somehow.  fseek() does not work, but fortunately fflush() does
what we want. In other words, this is a hack that Sun invented to make
stdio buffers work with socket streams.  Die, sun, DIE!

Bugfix:  Call fflush right before fwrite and fread so that the
Sun stdio implementation rewinds the bufer pointers.
@
text
@d33 1
d80 1
a80 1
  FILE*stream;
d123 2
a124 4
  FILE*stream=peer->stream;
  int n;
  fflush(stream);
  n = fwrite(ptr, size, nmemb, stream);
d136 2
a137 4
  FILE*stream=peer->stream;
  int n;
  fflush(stream);
  n = fread(ptr, size, nmemb, stream);
d652 1
a652 1
static int handle_request_impl(FILE*file, JNIEnv *env, jobject globalRef) {
d712 1
a712 1
  FILE *peer = (FILE*)(long)socket;
d718 1
a718 1
  if(!globalRef){logError(env, "could not allocate global hash");if(peer) fclose(peer);return;}
d720 2
a721 2
  if(peer && (fwrite(&instance, sizeof instance, 1, peer)!=1)) {
	logSysError(env, "could not send instance, child not listening"); fclose(peer);return;
d723 2
a724 1
  while(peer && !feof(peer)) {
d735 1
a735 1
  if(peer) fclose(peer);
d747 1
a747 1
  FILE *peer;
d797 1
a797 1
	peer = fdopen(socket, "r+");
@


1.14
log
@gcc2
@
text
@d123 3
a125 1
  int n = fwrite(ptr, size, nmemb, stream);
d138 3
a140 1
  int n = fread(ptr, size, nmemb, stream);
@


1.14.2.1
log
@workaround for broken sparc stdio
@
text
@a32 2
#include "jfile.h"
#include "jfile.c"
d79 1
a79 1
  JFILE*stream;
d122 2
a123 2
  JFILE*stream=peer->stream;
  int n = java_fwrite(ptr, size, nmemb, stream);
d135 2
a136 2
  JFILE*stream=peer->stream;
  int n = java_fread(ptr, size, nmemb, stream);
d651 1
a651 1
static int handle_request_impl(JFILE*file, JNIEnv *env, jobject globalRef) {
d711 1
a711 1
  JFILE *peer = (JFILE*)(long)socket;
d717 1
a717 1
  if(!globalRef){logError(env, "could not allocate global hash");if(peer) java_fclose(peer);return;}
d719 2
a720 2
  if(peer && (java_fwrite(&instance, sizeof instance, 1, peer)!=1)) {
	logSysError(env, "could not send instance, child not listening"); java_fclose(peer);return;
d722 1
a722 2
  while(peer && !java_feof(peer)) {
	if(java_ferror(peer)) { logSysError(env, "communication error"); break; }
d733 1
a733 1
  if(peer) java_fclose(peer);
d745 1
a745 1
  JFILE *peer;
d795 1
a795 1
	peer = java_fdopen(socket, "r+");
@


1.13
log
@The client receives the bridge instance as the first element.  This fixes the classpath bug.
To work around a problem in the IBM VM (it crashes if one creates a class which implements Runnable and extends from Classloader, the java code had to be re-organized to use an inner class.
@
text
@d967 1
a967 1
  int i, err;
d993 1
a993 1
  int off=N_SARGS-4;
@


1.12
log
@Bugfix/Workaround for gcj 'AttachCurrentThread' bug
@
text
@d228 1
a228 1
  handleRequests = (*env)->GetStaticMethodID(env, bridge, "HandleRequests", "(I)V");
d669 1
a669 1
static void logIntValue(JNIEnv*env, char*t, int i) {
d673 1
a673 1
  sprintf(s, "%s: %i",t,i);
d677 1
a677 1
static void logChannel(JNIEnv*env, char*t, int i) {
d708 1
a708 1
JNIEXPORT void JNICALL Java_JavaBridge_handleRequests(JNIEnv*env, jclass self, jint socket)
d711 1
a711 1
  FILE *peer;
a714 2
  peer = fdopen(socket, "r+");
  if(!peer) logSysError(env, "could not fdopen socket");
d717 1
a717 1
  if(!globalRef){logError(env, "could not allocate global hash");fclose(peer);return;}
d719 3
a733 1
  close(socket);
d745 1
d795 2
d798 1
a798 1
    (*env)->CallStaticVoidMethod(env, bridge, handleRequests, socket);
d933 1
a933 1
  {"handleRequests", "(I)V", Java_JavaBridge_handleRequests},
d993 1
a993 1
  int off=6;
d1018 5
a1022 5
	argv=calloc(10, sizeof*argv);
	argv[6]=_argv[1];			/* socketname */
	argv[7]=_argv[2];			/* logLevel */
	argv[8]=_argv[3];			/* logFile */
	argv[9]=0;					/* last arg */
d1026 1
a1026 1
  java_bridge_main(10, argv);
@


1.11
log
@anon socket/use jniRegisterNatives to inject the native code into the JVM (doesn't need a dynamic loader anymore)
@
text
@d57 2
d227 3
d708 2
a709 2
struct param {int s; JNIEnv *env; JavaVM *vm;};
static void *handle_requests(void *p) {
a710 2
  JNIEnv *env;
  struct param *param = (struct param*)p;
d714 2
a715 5
  int err = (*param->vm)->AttachCurrentThread(param->vm, (void**)&env, NULL);

  if(err) {logError(env, "could not attach to java vm"); free(p); return NULL;}
  logChannel(env, "create new communication channel", param->s);
  peer = fdopen(param->s, "r+");
d719 1
a719 1
  if(!globalRef){logError(env, "could not allocate global hash");fclose(peer);free(p);return NULL;}
d731 1
a731 2
  logChannel(env, "terminate communication channel", param->s);
  (*param->vm)->DetachCurrentThread(param->vm);
d733 1
a733 1
  close(param->s);
a734 1
  free(p);
a735 1
  return NULL;
a742 1
  pthread_t thread;
d748 4
a751 3
/*   signal(SIGSEGV, exit); */
/*   signal(SIGPWR, exit); */
  initGlobals(env);
d754 1
d785 1
a785 2
	struct param *param = malloc(sizeof*param);
	if(!param) {logMemoryError(env, __FILE__, __LINE__); return;}
d791 2
a792 2
	param->s = accept(sock, NULL, 0); 
	if(param->s==-1) {logSysError(env, "socket accept failed"); return;}
d795 1
a795 4
	param->env = env;
	n=(*env)->GetJavaVM(env, &param->vm);
	if(n) {logError(env, "could not get java vm"); return;}
	pthread_create(&thread, &attr, handle_requests, param);
a917 1

d930 1
d941 1
a941 1
static void jniRegisterNatives (JNIEnv *env) 
d957 1
a957 1
  JavaVMOption options[]={{argv[1], 0}, {argv[2], 0}, {argv[3], 0}};
d969 1
a969 1
  vm_args.nOptions=sizeof(options)/sizeof*options;
d971 3
d991 1
a991 1
  for (i=0; i<argc; i++) {
d1005 20
@


1.10
log
@fixes for GNU Java /gcj 3.3.3)
@
text
@d41 1
a41 1
  exit(6); \
d750 4
a766 1

d769 1
d771 5
a775 2
  unlink(sockname); 

d780 1
d782 1
d924 84
@


1.9
log
@java_set_jar_library_path added
@
text
@d370 1
d377 10
d392 2
a393 1
	(*env)->DeleteLocalRef(env, ref);
d512 1
a512 1
	jobject obj, ob;
d518 17
a534 2
	assert(!(*env)->CallObjectMethod(env, peer->globalRef, hashRemove, ob));
	if(ob) (*env)->CallObjectMethod(env, peer->globalRef, hashPut, ob, ob);
d684 2
a685 1
  jobject enumeration, ref;
d690 9
a698 2
	jobject jo=(*env)->CallObjectMethod(env, globalRef, hashRemove, ref);
	(*env)->DeleteGlobalRef(env, ptrFromObj(env,ref));
@


1.8
log
@The server now tracks resources
@
text
@d752 1
a752 1
	if(errno) goto res; 		
@


1.7
log
@Close the socket in rshutdown
@
text
@d46 1
d52 4
d79 1
d215 1
d221 4
d370 1
a370 1
	jobject ref;
d373 3
d500 1
a500 1
	jobject obj;
d503 1
d505 3
d619 1
a619 1
static int handle_request_impl(FILE*file, JNIEnv *env) {
d627 1
d649 19
d670 1
d683 3
d687 1
a687 1
	int term = handle_request_impl(peer, env);
d694 2
d707 1
a707 1
  
@


1.6
log
@Fixed a typo that caused a massive memory leak on the java side
@
text
@d60 1
d62 4
d169 2
d173 28
a200 3
static void exit_sig(int dummy) {
  atexit_bridge();
  _exit(0);
d202 1
d204 2
d219 9
a227 1
  signal(SIGTERM, exit_sig);
d635 2
d658 1
a683 2
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
d702 5
a706 1
res:errno=0; param->s = accept(sock, NULL, 0); 
@


1.5
log
@Start java in a separate process and give pval's a proper reference count.
@
text
@d657 2
a658 1
	param->s = accept(sock, NULL, 0);
d660 2
@


1.4
log
@proper termination for the IBM JDK, README update, INSTALL added
@
text
@d360 1
d374 5
a378 1
	(*env)->CallObjectMethod(env, peer->objectHash, hashPut, objFromPtr(env, key), objFromPtr(env, result));
d413 1
d427 4
a430 1
	(*env)->CallObjectMethod(env, peer->objectHash, hashPut, objFromPtr(env, key), objFromPtr(env, result));
d493 1
a493 1
	jobject val;
d500 3
a502 1
	val = (*env)->CallObjectMethod(env, peer->objectHash, hashRemove, objFromPtr(env, elems));
d504 1
d507 2
d512 1
a512 1
	jobject val;
d517 3
a519 1
	val = (*env)->CallObjectMethod(env, peer->objectHash, hashRemove, objFromPtr(env, elems));
d521 1
d523 2
a565 1

@


1.3
log
@Do not use longjmp to clear the stack after Apache has aborted the connection.  Instead jump back to java, then throw an exception, then longjmp to our main loop
@
text
@d167 2
a168 1
  exit(0);
@


1.2
log
@update to 1.0.0
@
text
@d41 1
a41 1
  longjmp(peer->env, 6); \
d44 2
d63 4
a66 1
  jmp_buf env;
d105 1
a105 1
  abort();
d112 8
a119 1
  if(n!=nmemb) longjmp(peer->env, 2);
d125 7
a131 1
  if(n!=nmemb) longjmp(peer->env, 1);
a165 1
static jmp_buf signal_env;
d167 1
a167 1
  longjmp(signal_env, 1);
d172 1
d230 2
d238 1
d240 6
d255 2
d262 1
d264 6
d543 4
a551 1
  peer.stream=file;
a605 2
  if(setjmp(signal_env)) return; //sigkill arrived

d652 1
d663 1
d674 1
d685 1
d696 1
d707 1
d718 1
d732 1
d746 1
d760 1
@


1.1
log
@Initial revision
@
text
@d66 1
d69 1
a69 1
  jstring str = (*jenv)->NewStringUTF(jenv, msg);
d71 1
a71 1
  if(!str) return;
a74 8
static void logMessage(JNIEnv *jenv, char *msg) {
  static jmethodID logMessageID=NULL;
  assert(bridge);
  if(!bridge) return;
  if(!logMessageID)
	logMessageID = (*jenv)->GetStaticMethodID(jenv, bridge, "logMessage", "(Ljava/lang/String;)V");
  doLog(jenv, msg, logMessageID);
}
d98 1
a98 1
  sprintf(s, "system error: out of memory error in: %s, line: %s", file, pos);
d123 1
d148 1
d150 1
a150 1
  exit(0);
d153 2
d157 1
a157 1
  jobject hash = (*env)->NewObject(env, hashClass, init);
a224 1
	jobject obj;
d302 1
a302 1
	short len;
d327 1
a327 1
	short count;
d342 1
a342 1
	short len;
d374 1
a374 1
	short length;
d407 1
a407 1
	short len;
d434 1
a434 1
	short len;
a450 1
	short count;
a462 1
	short count;
d465 1
a465 1
	sread(&elems, sizeof elems, count, peer);
d507 2
a508 1
  if(val=setjmp(peer.env)) {
a533 1
  int _s=param->s;
d536 1
a536 1
  if(err) {logError(env, "could not attach to java vm"); free(p); return;}
a547 1
	assert(_s==param->s);
a549 1
	assert(_s==param->s);
d566 3
a607 1
  exit_bridge();
@


1.1.1.1
log
@Initial
@
text
@@
