head	1.1;
access;
symbols
	sparc-64-test:1.1.0.2;
locks; strict;
comment	@ * @;


1.1
date	2004.10.09.21.57.20;	author jost2345;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.10.09.21.57.20;	author jost2345;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.10.09.22.21.59;	author jost2345;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file jfile.c was initially added on branch sparc-64-test.
@
text
@@


1.1.2.1
log
@workaround for broken sparc stdio
@
text
@a0 55
#include "jfile.h"

#ifdef HAS_BROKEN_STDIO
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>

/*  fix/workaround for broken stdio implementations */

size_t java_fwrite(const void  *ptr,  size_t  size,  size_t  nmemb,  JFILE *stream) {
  size_t c=0, s, n;

  assert(nmemb>0);
  while(nmemb--) {
    s = n = 0;
    while((size>s)&&((n=write(stream->file, ptr+s+c, size-s)) > 0)) s+=n;
    c += s;
    if(n == -1) { stream->eof = 1; break; }
  }
  return c/size;
}

size_t java_fread(void  *ptr,  size_t  size,  size_t  nmemb,  JFILE *stream) {
  size_t c=0, s, n;

  assert(nmemb>0);
  while(nmemb--) {
    s = n = 0;
    while((size>s)&&((n=read(stream->file, ptr+s+c, size-s)) > 0)) s+=n;
    c += s;
    if(n == -1) { stream->eof = 1; break; }
  }
  return c/size;
}

JFILE* java_fdopen(int fd, char*flags) {
  JFILE*f = calloc(1, sizeof*f);

  if(f)
    f->file = fd;
  else
    { f->err=1; errno=ENOMEM; }

  return f;
}

int java_fclose(JFILE *f) {
  int r = close(f->file);
  free(f);
  return r==-1?EOF:0;
}

#endif
@


1.1.2.2
log
@nmemb may be 0
@
text
@d15 1
a15 1
  //assert(nmemb>0);
d28 1
a28 1
  //assert(nmemb>0);
@


