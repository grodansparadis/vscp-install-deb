head	1.68;
access;
symbols
	Release-4-3-3:1.67.0.8
	ROOT_Release-4-3-3:1.67
	upstream_version_4_3_2:1.67
	debian_version_4_3_2-1:1.67
	ROOT_Release-4-3-2:1.67
	Release-4-3-2:1.67.0.6
	Release-4-3-1:1.67.0.4
	ROOT_Release-4-3-1:1.67
	debian_version_4_3_0-1:1.67
	upstream_version_4_3_0:1.67
	ROOT_Release-4-3-0:1.67
	Release-4-3-0:1.67.0.2
	debian_version_3_2_1b-2:1.61
	debian_version_4_2_2-1:1.66
	upstream_version_4_2_2:1.66
	debian_version_3_2_1b-1:1.61
	upstream_version_3_2_1b:1.61
	Release-4-1-2:1.64.0.2
	Release-4-0-8:1.62.0.6
	debian_version_4_0_8a-1:1.62
	upstream_version_4_0_8a:1.62
	jostb-debian-ubuntu-patch:1.62.0.4
	debian_version_4_0_8-1:1.62
	upstream_version_4_0_8:1.62
	debian_version_4_0_7-1:1.62
	upstream_version_4_0_7:1.62
	debian_version_4_0_6-1:1.62
	upstream_version_4_0_6:1.62
	debian_version_4_0_2-1:1.62
	upstream_version_4_0_2:1.62
	Release-4-0-2_Root:1.62
	Release-4-0-2:1.62.0.2
	upstream_version_4_0_1:1.62
	debian_version_4_0_1-2:1.62
	Release-3-2-1:1.61.0.2
	Release-3-1-8:1.59.0.2
	Release-3-0-8_root:1.40.2.1
	Release-3-0-8_Root:1.44
	Release-3-0-8:1.40.0.2
	Release-2-0-8:1.30.0.4
	Release-2-0-7_Root:1.19
	Release-2-0-7:1.19.0.2
	Release-2-0-6-branch:1.13.0.2;
locks; strict;
comment	@ * @;


1.68
date	2008.01.06.21.07.56;	author jost_boekemeier;	state dead;
branches;
next	1.67;

1.67
date	2007.09.19.10.12.27;	author jost_boekemeier;	state Exp;
branches;
next	1.66;

1.66
date	2007.07.09.14.35.06;	author jost_boekemeier;	state Exp;
branches;
next	1.65;

1.65
date	2007.07.03.15.50.52;	author jost_boekemeier;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.18.16.56.00;	author jost_boekemeier;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.13.19.51.47;	author jost_boekemeier;	state Exp;
branches;
next	1.62;

1.62
date	2007.03.09.20.28.07;	author andremachado;	state Exp;
branches;
next	1.61;

1.61
date	2006.12.05.20.11.22;	author jost2345;	state Exp;
branches;
next	1.60;

1.60
date	2006.11.25.17.00.31;	author jost2345;	state Exp;
branches;
next	1.59;

1.59
date	2006.09.10.17.31.11;	author jost2345;	state Exp;
branches;
next	1.58;

1.58
date	2006.09.05.20.40.32;	author jost2345;	state Exp;
branches;
next	1.57;

1.57
date	2006.08.27.14.40.11;	author jost2345;	state Exp;
branches;
next	1.56;

1.56
date	2006.08.21.17.41.52;	author jost2345;	state Exp;
branches;
next	1.55;

1.55
date	2006.08.13.21.48.35;	author jost2345;	state Exp;
branches;
next	1.54;

1.54
date	2006.08.08.17.20.45;	author jost2345;	state Exp;
branches;
next	1.53;

1.53
date	2006.07.23.20.32.47;	author jost2345;	state Exp;
branches;
next	1.52;

1.52
date	2006.07.19.15.25.34;	author jost2345;	state Exp;
branches;
next	1.51;

1.51
date	2006.07.16.20.29.25;	author jost2345;	state Exp;
branches;
next	1.50;

1.50
date	2006.06.26.18.43.55;	author jost2345;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.19.20.37.14;	author jost2345;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.15.19.03.29;	author jost2345;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.13.16.13.40;	author jost2345;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.07.14.33.33;	author jost2345;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.04.17.48.13;	author jost2345;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.30.17.01.55;	author jost2345;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.28.18.15.02;	author jost2345;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.26.19.09.31;	author jost2345;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.12.17.46.46;	author jost2345;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.19.14.42.44;	author jost2345;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2006.03.16.20.27.00;	author jost2345;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.12.16.44.39;	author jost2345;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.10.18.41.37;	author jost2345;	state Exp;
branches;
next	1.36;

1.36
date	2006.02.03.17.41.36;	author jost2345;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.30.19.39.53;	author jost2345;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.15.21.05.30;	author jost2345;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.19.19.36.40;	author jost2345;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.18.18.17.48;	author jost2345;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.05.13.11.19;	author jost2345;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.13.16.46.47;	author jost2345;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.07.21.13.45;	author jost2345;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.01.20.58.24;	author jost2345;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.24.20.58.31;	author jost2345;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.23.18.20.56;	author jost2345;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.21.11.39.39;	author jost2345;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.18.18.31.39;	author jost2345;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.11.18.08.16;	author jost2345;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.01.16.56.55;	author jost2345;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.17.13.46.23;	author jost2345;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.12.15.23.09;	author jost2345;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.08.17.57.23;	author jost2345;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.25.12.16.09;	author jost2345;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.21.20.17.30;	author jost2345;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.19.20.45.40;	author jost2345;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.16.16.10.41;	author jost2345;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.15.15.18.02;	author jost2345;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.15.20.17.35;	author jost2345;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.17.21.01.23;	author jost2345;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.13.13.23.13;	author jost2345;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.11.17.34.19;	author jost2345;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.09.17.24.26;	author jost2345;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.05.14.55.38;	author jost2345;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.20.14.01.37;	author jost2345;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.19.16.06.43;	author jost2345;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.19.14.10.11;	author jost2345;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.19.13.29.25;	author jost2345;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.17.21.57.22;	author jost2345;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.15.19.10.29;	author jost2345;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.13.21.43.28;	author jost2345;	state Exp;
branches;
next	;

1.40.2.1
date	2006.04.23.19.09.08;	author jost2345;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2006.05.05.18.29.54;	author jost2345;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2006.05.13.16.09.57;	author jost2345;	state Exp;
branches;
next	;


desc
@@


1.68
log
@Release-5-0-0
@
text
@/*-*- mode: C; tab-width:4 -*-*/

/* protocol.c -- implementation of the PHP/Java Bridge XML protocol.

  Copyright (C) 2003-2007 Jost Boekemeier

  This file is part of the PHP/Java Bridge.

  The PHP/Java Bridge ("the library") is free software; you can
  redistribute it and/or modify it under the terms of the GNU General
  Public License as published by the Free Software Foundation; either
  version 2, or (at your option) any later version.

  The library is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with the PHP/Java Bridge; see the file COPYING.  If not, write to the
  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307 USA.

  Linking this file statically or dynamically with other modules is
  making a combined work based on this library.  Thus, the terms and
  conditions of the GNU General Public License cover the whole
  combination.

  As a special exception, the copyright holders of this library give you
  permission to link this library with independent modules to produce an
  executable, regardless of the license terms of these independent
  modules, and to copy and distribute the resulting executable under
  terms of your choice, provided that you also meet, for each linked
  independent module, the terms and conditions of the license of that
  module.  An independent module is a module which is not derived from
  or based on this library.  If you modify this library, you may extend
  this exception to your version of the library, but you are not
  obligated to do so.  If you do not wish to do so, delete this
  exception statement from your version. */  

#include "zend.h"
#include "init_cfg.h"
#if !defined(ZEND_ENGINE_2)

#include "php_java.h"

#include <stdarg.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "protocol.h"
#include "java_bridge.h"
#include "php_java_snprintf.h"
#include "sio.h"

#define SLEN 256 // initial length of the parser string
#define SEND_SIZE 8192 // initial size of the send buffer

#define ILEN 40 // integer, double representation.
#define PRECISION "14" /* 15 .. 17 digits - 1 */
#define FLEN 160 // the max len of the following format strings

#define GROW(size) { \
  flen = size; \
  if((*env)->send_len+size>=(*env)->send_size) { \
    size_t nsize = (*env)->send_len+size+SEND_SIZE; \
	(*env)->send=realloc((*env)->send, (*env)->send_size=nsize); \
	assert((*env)->send); if(!(*env)->send) exit(9); \
  } \
}
#ifdef DISABLE_HEX
#define HEX_ARG "%ld"
#else
#define HEX_ARG "%lx"
#endif

static char *getSessionFactory(proxyenv *env) {
  static const char invalid[] = "0";
  register char *context = (*env)->servlet_ctx;
  return context?context:(char*)invalid;
}
static char*get_context(proxyenv *env, char context[CONTEXT_LEN_MAX], short*context_length) {
  char *ctx = (*env)->current_servlet_ctx ? (*env)->current_servlet_ctx : (*env)->servlet_ctx;
  size_t l = strlen(ctx);
  assert(l<CONTEXT_LEN_MAX);
  *context_length = 
	EXT_GLOBAL(snprintf) (context, 
						  CONTEXT_LEN_MAX, 
						  "%c%c%c%c%s", 
						  0177, 0xFF,0xFF&l,0xFF&(l>>8),
						  ctx);
  return context;
}

/**
 * Send the packet to the server
 */
static short send_data(proxyenv *env, char *data, size_t size) {
  size_t s=0; ssize_t n=0;
 res: 
  errno=0;
  while((size>s)&&((n=(*env)->f_send(env, data+s, size-s)) > 0)) 
	s+=n;
  if(size>s && !n && errno==EINTR) goto res; // Solaris, see INN FAQ
  return n!=-1;
}

static short add_header(proxyenv *env, size_t *size, char*header, size_t header_length) {
  if(!header_length) return 1;

  if(*size+header_length<(*env)->send_size) {
	memmove((*env)->send+header_length, (*env)->send, *size);
	memcpy(((*env)->send), header, header_length);
	*size+=header_length;
	return 1;
  } else {
	return send_data(env, header, header_length);
  }
}

static short end(proxyenv *env) {
  short success;
  size_t size = (*env)->send_len;
  char *servlet_context;
  char *context;
  short context_length = 0;
  char kontext[CONTEXT_LEN_MAX];
  /* get the context for the re-redirected connection */
  if((*env)->must_reopen==2) context = get_context(env, kontext, &context_length);
  (*env)->must_reopen=0;

  TSRMLS_FETCH();

  servlet_context = EXT_GLOBAL (get_servlet_context) (TSRMLS_C);

  if(!(*env)->is_local && servlet_context) {
	char header[SEND_SIZE];
	int header_length;
	unsigned char mode = EXT_GLOBAL (get_mode) ();

	assert(!(*env)->peer_redirected || ((*env)->peer_redirected && (((*env)->peer0)==-1)));
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c%c", servlet_context, (unsigned long)(size+2), EXT_GLOBAL(get_channel)(env), getSessionFactory(env), 127, mode);

	success = add_header(env, &size, header, header_length);
  } else {						/* re-directed */
	success = add_header(env, &size, context, context_length);
  }
  if(success) success = send_data(env, (char*)(*env)->send, size);
  return success;
}

static char *get_cookies(zval *val, proxyenv *env) {
  static const char zero[] = "", cookies[] = "\
get_cookies();\
function get_cookies() {\
  $str=\"\";\
  $first=true;\
  foreach($_COOKIE as $k => $v) {\
    $str = $str . ($first ? \"Cookie: $k=$v\":\"; $k=$v\");\
    $first=false;\
  }\
  if(!$first) $str .= '\r\n';\
  return $str;\
}\
";
  TSRMLS_FETCH();
  if((SUCCESS==zend_eval_string((char*)cookies, val, "cookies" TSRMLS_CC)) && (Z_TYPE_P(val)==IS_STRING)) {
	return Z_STRVAL_P(val);
  }
  assert(0);
  return (char*)zero;
}  

/**
 * Used by getSession() to aquire the session context.
 * Sends override_redirect and cookies
 * @@see check_context
 */
static short end_session(proxyenv *env) {
  short success;
  size_t size = (*env)->send_len;
  zval val;
  int peer0 = (*env)->peer0;
  char header[SEND_SIZE];
  int header_length;
  short override_redirect = 4 + ((peer0!=-1)?1:2); // legacy flag + override_redirect or getSession
  unsigned char mode = EXT_GLOBAL (get_mode) ();
	
  TSRMLS_FETCH();

  (*env)->finish=end;
  
  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_REDIRECT: %d\r\n%sX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c%c", (*env)->servlet_context_string, (unsigned long)(size+2), override_redirect, get_cookies(&val, env), EXT_GLOBAL(get_channel)(env), getSessionFactory(env), 127, mode);

  success = add_header(env, &size, header, header_length);
  if(success) success = send_data(env, (char*)(*env)->send, size);
  return success;
}

/**
 * Send out the data to the back-end.
 * @@param env The proxyenv
 * @@return 1 on success, 0 if the connection the back-end is lost
 */
static short finish(proxyenv *env) {
  short success = (*env)->finish(env);
  if(!success) return 0;
  (*env)->send_len=0;
  return 1;
}

/**
 * Send out the data to the back-end and read the response.
 * @@param env The proxyenv
 * @@return 1 on success, 0 if the connection the back-end is lost
 */
static short flush(proxyenv *env) {
  short success;
  if((*env)->connection_is_closed) return 0;
  success = finish(env);
  if(success) success=(*env)->handle(env);

  if(!success) (*env)->connection_is_closed = 1;

  return success;
}

static short end_connection (proxyenv *env) {
  short success;
  char *servlet_context;
  short context_length = 0;
  char *context;
  size_t size = (*env)->send_len;
  char kontext[CONTEXT_LEN_MAX];
  unsigned char mode = EXT_GLOBAL (get_mode) ();

  if((*env)->must_reopen==2) context = get_context(env, kontext, &context_length);
  (*env)->must_reopen=0;
  (*env)->finish=end;

  TSRMLS_FETCH();

  servlet_context = EXT_GLOBAL (get_servlet_context) (TSRMLS_C);

  if(!(*env)->is_local && servlet_context) {
	char header[SEND_SIZE];
	int header_length;

	assert(!(*env)->peer_redirected);

	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c%c", servlet_context, (unsigned long)(size+2), EXT_GLOBAL(get_channel)(env),  getSessionFactory(env), 127, mode);

	success = add_header(env, &size, header, header_length);
	if(success) success = send_data(env, (char*)(*env)->send, size);
  } else {						/* re-directed */
	success = add_header(env, &size, context, context_length);
	if(success) success = send_data(env, (char*)(*env)->send, size);
  }
  return success;
}
static ssize_t send_async(proxyenv*env, const void*buf, size_t length) {
  return EXT_GLOBAL(sfwrite)(buf, length, (*env)->async_ctx.peer);
}
static ssize_t send_pipe(proxyenv*env, const void*buf, size_t length) {
  return write((*env)->peer, buf, length);
}
static ssize_t send_socket(proxyenv*env, const void*buf, size_t length) {
  return send((*env)->peer, buf, length, 0);
}

static ssize_t recv_pipe(proxyenv*env, void*buf, size_t length) {
  return read((*env)->peerr, buf, length);
}

static ssize_t recv_socket(proxyenv*env, void*buf, size_t length) {
  return recv((*env)->peer, buf, length, 0);
}

short EXT_GLOBAL(begin_async) (proxyenv*env) {
  assert(((*env)->peer0==-1));	/* secondary "override redirect"
								   channel cannot be used during
								   stream mode */
  if(((*env)->peer) != -1) (*env)->async_ctx.peer = EXT_GLOBAL(sfdopen)(env);

  if((*env)->async_ctx.peer) {
								/* save default f_send, use send_async */
	(*env)->handle = (*env)->async_ctx.handle_request;
	(*env)->async_ctx.f_send = (*env)->f_send;
	(*env)->f_send = (*env)->f_send0 = send_async;
	return 1;
  } else {
	return 0;
  }
}
void EXT_GLOBAL(end_async) (proxyenv*env) {
  assert(((*env)->peer0==-1));	/* secondary "override redirect"
								   channel cannot be used during
								   stream mode */
  (*env)->handle=(*env)->handle_request;
  if((*env)->async_ctx.peer) {
	int err = EXT_GLOBAL(sfclose)((*env)->async_ctx.peer);
								/* restore default f_send */
	(*env)->f_send = (*env)->f_send0 = (*env)->async_ctx.f_send;
	(*env)->async_ctx.peer = 0;
	if(err) EXT_GLOBAL(sys_error)("could not close async buffer",93);
  }
}
void EXT_GLOBAL(redirect_pipe)(proxyenv*env) {
	(*env)->f_recv0 = (*env)->f_recv = recv_pipe;
	(*env)->f_send0 = (*env)->f_send = send_pipe;
}
void EXT_GLOBAL(setResultWith_context) (char*key, char*val, char*path) {
  static const char empty[] = "/";
  static const char name[] = "setResultWith_cookie";
  static const char cmd[] = "\n\
$path=trim('%s');\n\
if($path[0]!='/') $path='/'.$path;\n\
setcookie('%s', '%s', 0, $path);\n\
";
  char buf[1024];
  int ret;

  TSRMLS_FETCH();

  /* if path is empty or if java.servlet=On, discard path value. Use
	 java.servlet=User to retain the path */
  if(!path || 
	 (EXT_GLOBAL(cfg)->servlet_is_default
	  && !(EXT_GLOBAL(cfg)->is_cgi_servlet))) {
	path = (char*)empty;
  }

  EXT_GLOBAL(snprintf)(buf, sizeof(buf), (char*)cmd, path, key, val);
  ret = zend_eval_string((char*)buf, 0, (char*)name TSRMLS_CC);
  assert(SUCCESS==ret);
}

  
#define GROW_QUOTE() \
  if(pos+8>=newlen) { \
    newlen=newlen+newlen/10; \
    new=realloc(new, newlen+8); \
    assert(new); if(!new) exit(9); \
  } 
static char* replaceQuote(char *name, size_t len, size_t *ret_len) {
  static const char quote[]="&quot;";
  static const char amp[]="&amp;";
  register size_t newlen=len+8+len/10, pos=0;
  char c, *new = malloc(newlen);
  register short j;
  assert(new); if(!new) exit(9);
  
  while(len--) {
	switch (c=*name++) {
	case '\"':
	  {
		for(j=0; j<(sizeof(quote)-1); j++) {
		  new[pos++]=quote[j]; 
		  GROW_QUOTE();
		}
	  } 
	  break;
	case '&':
	  {
		for(j=0; j<(sizeof(amp)-1); j++) {
		  new[pos++]=amp[j]; 
		  GROW_QUOTE();
		}
	  } 
	  break;
	default: 
	  {
		new[pos++]=c;
		GROW_QUOTE();
	  }
	}
  }

  new[pos]=0;
  *ret_len=pos;
  return new;
}
 static void CreateObjectBegin(proxyenv *env, char*name, size_t len, char createInstance, void *result) {
   size_t flen;
   assert(createInstance=='C' || createInstance=='I');
   if(!len) len=strlen(name);
   GROW(FLEN+ILEN+len);
   (*env)->send_len+=EXT_GLOBAL(snprintf) ((char*)((*env)->send+(*env)->send_len), flen, "<C v=\"%s\" p=\"%c\" i=\""/**/HEX_ARG/**/"\">", name, createInstance, (unsigned long)((*env)->async_ctx.result=result));
   assert((*env)->send_len<=(*env)->send_size);
 }
 static short CreateObjectEnd(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "</C>");
   assert((*env)->send_len<=(*env)->send_size);
   return flush(env);
 }
 static void InvokeBegin(proxyenv *env, unsigned long object, char*method, size_t len, char property, void* result) {
   size_t flen;
   assert(property=='I' || property=='P');
   if(!len) len=strlen(method);
   GROW(FLEN+ILEN+len+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<I v=\""/**/HEX_ARG/**/"\" m=\"%s\" p=\"%c\" i=\""/**/HEX_ARG/**/"\">", object, method, property, (unsigned long)((*env)->async_ctx.result=result));
   assert((*env)->send_len<=(*env)->send_size);
 }
 static short InvokeEnd(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "</I>");
   assert((*env)->send_len<=(*env)->send_size);
   return flush(env);
 }

 static void ResultBegin(proxyenv *env, void*result) {
   size_t flen;
   GROW(FLEN+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<R i=\""/**/HEX_ARG/**/"\">", (unsigned long)((*env)->async_ctx.result=result));
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void ResultEnd(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "</R>");
   assert((*env)->send_len<=(*env)->send_size);
   finish(env);
 }

static short EndConnection(proxyenv *env, char property) {
  size_t flen;
  assert(property=='A' || property=='E');
  GROW(FLEN);
  (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<F p=\"%c\"/>", property);
  assert((*env)->send_len<=(*env)->send_size);

  (*env)->finish=end_connection;
  return flush(env);
}

 static void String(proxyenv *env, char*name, size_t _len) {
   size_t flen;
   static const char Sb[]="<S v=\"";
   static const char Se[]="\"/>";
   size_t send_len;
   size_t len, slen;
   assert(_len || !strlen(name));
   name = replaceQuote(name, _len, &len);
   send_len = (sizeof (Sb)-1) + (sizeof (Se)-1) + len;
   GROW(send_len);
   slen=(*env)->send_len;
   memcpy((*env)->send+slen, Sb, sizeof(Sb)-1); slen+=sizeof(Sb)-1;
   memcpy((*env)->send+slen, name, len); slen+=len;
   memcpy((*env)->send+slen, Se, sizeof(Se)-1);

   (*env)->send_len+=send_len;
   assert((*env)->send_len<=(*env)->send_size);
   free(name);
 }
 static void Boolean(proxyenv *env, short boolean) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<B v=\"%c\"/>", boolean?'T':'F');
   assert((*env)->send_len<=(*env)->send_size);
 }
#ifdef DISABLE_HEX
 static void Long(proxyenv *env, long l) {
   size_t flen;
   GROW(FLEN+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<L v=\"%ld\"/>", l);
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void ULong(proxyenv *env, unsigned long l) {
   size_t flen;
   GROW(FLEN+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<L v=\"%lu\"/>", l);
   assert((*env)->send_len<=(*env)->send_size);
 }
#else
 static void Long(proxyenv *env, long l) {
   size_t flen;
   GROW(FLEN+ILEN);
   if(l<0)
	 (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<L v=\""/**/HEX_ARG/**/"\" p=\"A\"/>", (unsigned long)(-l));
   else
	 (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<L v=\""/**/HEX_ARG/**/"\" p=\"O\"/>", (unsigned long)l);
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void ULong(proxyenv *env, unsigned long l) {
   size_t flen;
   GROW(FLEN+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<L v=\""/**/HEX_ARG/**/"\" p=\"O\"/>", (unsigned long)l);
   assert((*env)->send_len<=(*env)->send_size);
 }
#endif
 static void Double(proxyenv *env, double d) {
   size_t flen;
   GROW(FLEN+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<D v=\"%."/**/PRECISION/**/"e\"/>", d);
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void Object(proxyenv *env, unsigned long object) {
   size_t flen;
   GROW(FLEN+ILEN);
   if(!object) 
	 (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<O v=\"\"/>");
   else
	 (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len),flen, "<O v=\""/**/HEX_ARG/**/"\"/>", object);
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void Exception(proxyenv *env, unsigned long object, char *str, size_t len) {
   size_t flen, newlen;
   if(!len) len=strlen(str);
   str = replaceQuote(str, len, &newlen); len = newlen;
   GROW(FLEN+ILEN+len);
   if(!object) 
	 (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<E v=\"\" m=\"%s\"/>", str);
   else
	 (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len),flen, "<E v=\""/**/HEX_ARG/**/"\" m=\"%s\"/>", object, str);
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void CompositeBegin_a(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<X t=\"A\">");
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void CompositeBegin_h(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<X t=\"H\">");
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void CompositeEnd(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "</X>");
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void PairBegin_s(proxyenv *env, char*key, size_t len) {
   size_t flen, newlen;
   assert(strlen(key));
   if(!len) len=strlen(key);
   key = replaceQuote(key, len, &newlen); len = newlen;
   GROW(FLEN+len);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<P t=\"S\" v=\"%s\">", key);
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void PairBegin_n(proxyenv *env, unsigned long key) {
   size_t flen;
   GROW(FLEN+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<P t=\"N\" v=\""/**/HEX_ARG/**/"\">", key);
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void PairBegin(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<P>");
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void PairEnd(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "</P>");
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void Unref(proxyenv *env, unsigned long object) {
   size_t flen;
   GROW(FLEN+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<U v=\""/**/HEX_ARG/**/"\"/>", object);
   assert((*env)->send_len<=(*env)->send_size);
 }

 

static void redirect(proxyenv *env) {}
static short close_socket(proxyenv *env) {
  int err = close((*env)->peer);
  return err == -1 ? 0 : 1;
}
static void check_session (proxyenv *env) {

  TSRMLS_FETCH();

  if(!(*env)->is_local && IS_SERVLET_BACKEND(env) && !(*env)->backend_has_session_proxy) {
	if((*env)->peer_redirected) { /* override redirect */
	  int sock = socket (PF_INET, SOCK_STREAM, 0);
	  struct sockaddr *saddr = &(*env)->orig_peer_saddr;
	  if (-1!=sock) {
		static const int is_true = 1;
		setsockopt(sock, 0x6, TCP_NODELAY, (void*)&is_true, sizeof is_true);
		if (-1!=connect(sock, saddr, sizeof (struct sockaddr))) {
		  (*env)->peer0 = (*env)->peer;
		  (*env)->peer = sock;
		  (*env)->f_recv = recv_socket;
		  (*env)->f_send = send_socket;
		} else {				/* could not connect */
		  close(sock);
		  EXT_GLOBAL(sys_error)("Could not connect to server",78);
		}
	  } else
		EXT_GLOBAL(sys_error)("Could not create socket",79);
	}
	(*env)->finish=(*env)->endSession;
  }
}
static void destruct(proxyenv *env) {
	if(((*env)->peerr!=-1) && (!(*env)->is_shared)) close((*env)->peerr);
	if(((*env)->peer0!=-1) && (!(*env)->is_shared)) close((*env)->peer0);
	if((*env)->s) free((*env)->s);
	if((*env)->send) free((*env)->send);
	if((*env)->server_name) free((*env)->server_name);
	if((*env)->current_servlet_ctx && (*env)->servlet_ctx != (*env)->current_servlet_ctx) free((*env)->current_servlet_ctx);
	if((*env)->servlet_ctx && (!(*env)->is_shared)) free((*env)->servlet_ctx);
	if((*env)->servlet_context_string) free((*env)->servlet_context_string);
	if((*env)->cfg.hosts) free((*env)->cfg.hosts);
	if((*env)->cfg.servlet) free((*env)->cfg.servlet);
}
static void close_connection(proxyenv *env TSRMLS_DC) {
  if(env && *env) {
	if((*env)->peer!=-1) { /* end servlet session */

	  /* end async */
	  if((*env)->async_ctx.peer) {
		EXT_GLOBAL(sfclose)((*env)->async_ctx.peer); (*env)->async_ctx.peer=0;
		(*env)->handle = (*env)->handle_request;
		(*env)->f_send = (*env)->f_send0 = (*env)->async_ctx.f_send;
	  }

	  if(!(*env)->connection_is_closed) (*env)->writeEndConnection(env, 'E');
	  if(!(*env)->is_shared) (*env)->f_close(env);
	}
	(*env)->destruct(env);

	/* remove the remaining of the pipe channel. In and out are
	   usually unlinked and removed immediately, but the channel name
	   is kept for override redirect */
	EXT_GLOBAL(unlink_channel)(env);
	if((*env)->pipe.channel) {
	  free((*env)->pipe.channel); 
	  (*env)->pipe.channel = 0;
	}

	free(*env);
	free(env);
	EXT_GLOBAL(destroy_cloned_cfg)(TSRMLS_C);
  }
}
static short recycle_connection(proxyenv *env TSRMLS_DC) {
  if(env && *env) {
	if((*env)->connection_is_closed) return 0;
	if((*env)->peer!=-1) {

	  /* end async protocol */
	  if((*env)->handle==(*env)->async_ctx.handle_request) 
		EXT_GLOBAL(end_async(env));
	  if(!(*env)->writeEndConnection(env, 'A')) { 
		(*env)->connection_is_closed=1;
		return 0;
	  }
	}
	EXT_GLOBAL(passivate_connection)(env TSRMLS_CC);
	EXT_GLOBAL(destroy_cloned_cfg)(TSRMLS_C);
	if((*env)->current_servlet_ctx && 
	   (*env)->servlet_ctx != (*env)->current_servlet_ctx) {
	  free((*env)->current_servlet_ctx); 
	}
	(*env)->current_servlet_ctx = 0; 
	(*env)->async_ctx.nextValue = 0;
  }
  return 1;
}
/**
 * Close an active connection. The connection must be active, i.e. JG(cfg).hosts,
 * JG(cfg).servlet and JG(cfg).ini_user must contain the appropriate values.
 *
 * @@param env The proxy env
 * @@param persistent_connection true for keep alive, false closes physical connection
 * @@see activate_connection
 */
short EXT_GLOBAL(close_connection)(proxyenv*env, short persistent_connection TSRMLS_DC) {
  int success = 1;
  if(persistent_connection) success = recycle_connection(env TSRMLS_CC);
  if(!persistent_connection || !success) close_connection(env TSRMLS_CC);
  return success;
}
short EXT_GLOBAL(init_environment) (struct proxyenv_ *env, short (*handle_request)(proxyenv *env), short (*handle_cached)(proxyenv *env), short is_local) {

  env->is_local = is_local;
  env->handle = env->handle_request = handle_request;
  env->async_ctx.handle_request = handle_cached;

  env->f_recv0 = env->f_recv = recv_socket;
  env->f_send0 = env->f_send = send_socket;
  env->f_close=close_socket;

  env->peer0 = env->peerr = -1;
  env->is_shared = 0;
  env->peer_redirected = 0;
  
  env->async_ctx.peer = 0;
  env->async_ctx.nextValue = 0;
  
  /* parser variables */
  env->pos=env->c = 0;
  env->len = SLEN; 
  env->s=malloc(env->len);
  if(!env->s) return 0;
  
  /* send buffer */
  env->send_size=SEND_SIZE;
  env->send=malloc(SEND_SIZE);
  if(!env->send) {free(env->s); return 0;}
  env->send_len=0;
   
  env->must_reopen = env->must_share = 0;
  env->connection_is_closed = 0;
  env->current_servlet_ctx = 
	env->servlet_ctx = env->servlet_context_string = 0;
  env->backend_has_session_proxy = 0;
  env->cfg.ini_user = 0;
  env->cfg.hosts = env->cfg.servlet = 0;
  env->checkSession = check_session;

  env->writeInvokeBegin=InvokeBegin;
  env->writeInvokeEnd=InvokeEnd;
  env->writeResultBegin=ResultBegin;
  env->writeResultEnd=ResultEnd;
  env->writeCreateObjectBegin=CreateObjectBegin;
  env->writeCreateObjectEnd=CreateObjectEnd;

  env->writeString=String;
  env->writeBoolean=Boolean;
  env->writeLong=Long;
  env->writeULong=ULong;
  env->writeDouble=Double;
  env->writeObject=Object;
  env->writeException=Exception;
  env->writeCompositeBegin_a=CompositeBegin_a;
  env->writeCompositeBegin_h=CompositeBegin_h;
  env->writeCompositeEnd=CompositeEnd;
  env->writePairBegin=PairBegin;
  env->writePairBegin_s=PairBegin_s;
  env->writePairBegin_n=PairBegin_n;
  env->writePairEnd=PairEnd;
  env->writeUnref=Unref;

  env->writeEndConnection=EndConnection;

  env->endSession=end_session;
  env->redirect=redirect;
  env->finish=end;

  env->destruct=destruct;

  return 1;
}
proxyenv *EXT_GLOBAL(createEnvironment) (short (*handle_request)(proxyenv *env), short (*handle_cached)(proxyenv *env), short *is_local) {
  char *server;
  int peer;
  proxyenv *env;  
  struct sockaddr saddr;
  
  TSRMLS_FETCH();
  if(!(server=EXT_GLOBAL(test_server)(&peer, is_local, &saddr TSRMLS_CC))) 
	return 0;

  env=(proxyenv*)malloc(sizeof *env);     
  if(!env) return 0;
  *env=(proxyenv)calloc(1, sizeof **env); 
  if(!*env) {free(env); return 0;}
  
  (*env)->peer = peer;

  memcpy(&(*env)->orig_peer_saddr, &saddr, sizeof (struct sockaddr));
  (*env)->server_name = server;
  
  if(!EXT_GLOBAL(init_environment)(*env, handle_request, handle_cached, *is_local)) {
	free(*env); free(env); return 0;
  }
  return env;
}
	
	
#ifndef PHP_WRAPPER_H
#error must include php_wrapper.h
#endif

#endif
@


1.67
log
@Release-4-3-0
@
text
@@


1.66
log
@Release-4-1-8
@
text
@d43 1
a43 1
#if !defined(ZEND_ENGINE_2) || EXTENSION == MONO
@


1.65
log
@Release-4-1-7
@
text
@d41 4
d92 1
a92 1
						  077, 0xFF,0xFF&l,0xFF&(l>>8),
d788 2
@


1.64
log
@Release-4-1-2
@
text
@d140 1
a140 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\nX_JAVABRIDGE_CONTEXT_DEFAULT: %s\r\n\r\n%c%c", servlet_context, (unsigned long)(size+2), EXT_GLOBAL(get_channel)(env), getSessionFactory(env), EXT_GLOBAL(getDefaultSessionFactory)(TSRMLS_C), 127, mode);
d191 1
a191 1
  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_REDIRECT: %d\r\n%sX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\nX_JAVABRIDGE_CONTEXT_DEFAULT: %s\r\n\r\n%c%c", (*env)->servlet_context_string, (unsigned long)(size+2), override_redirect, get_cookies(&val, env), EXT_GLOBAL(get_channel)(env), getSessionFactory(env), EXT_GLOBAL(getDefaultSessionFactory)(TSRMLS_C), 127, mode);
d249 1
a249 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\nX_JAVABRIDGE_CONTEXT_DEFAULT: %s\r\n\r\n%c%c", servlet_context, (unsigned long)(size+2), EXT_GLOBAL(get_channel)(env),  getSessionFactory(env), EXT_GLOBAL(getDefaultSessionFactory)(TSRMLS_C), 127, mode);
@


1.63
log
@Release-4-1-0
@
text
@d81 10
a90 9
	size_t l = strlen((*env)->servlet_ctx);
	assert(l<CONTEXT_LEN_MAX);
	*context_length = 
	  EXT_GLOBAL(snprintf) (context, 
							CONTEXT_LEN_MAX, 
							"%c%c%c%c%s", 
							077, 0xFF,0xFF&l,0xFF&(l>>8),
							(*env)->servlet_ctx);
	return context;
@


1.62
log
@Files update 3.2.2 to 4.0.1. Extracted from the src.tar.gz downloaded from sf.net, uploaded by Jost Boekemeier. Update to repository by Andre Felipe Machado.
@
text
@a81 1
	
d183 1
a183 1
  short override_redirect = (peer0!=-1)?1:2;
d185 1
a185 1

@


1.61
log
@Release-3-2-1
@
text
@d5 1
a5 1
  Copyright (C) 2006 Jost Boekemeier
@


1.60
log
@Release-3-2-1
@
text
@d469 6
d485 6
d731 1
@


1.59
log
@Release-3-1-8
@
text
@d618 4
d623 5
@


1.58
log
@Release-3-1-8rc3
@
text
@d3 1
a3 1
/**\file protocol.c -- implementation of the PHP/Java Bridge XML protocol.
d496 1
a496 1
   size_t flen;
d498 1
d525 1
a525 1
   size_t flen;
d528 1
d560 1
a560 3
static void redirect(proxyenv *env) {
  assert(0);
}
d629 3
d644 1
@


1.57
log
@Release-3-1-8rc
@
text
@d140 1
a140 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\nX_JAVABRIDGE_CONTEXT_DEFAULT: %s\r\n\r\n%c", servlet_context, (unsigned long)(size+1), EXT_GLOBAL(get_channel)(env), getSessionFactory(env), EXT_GLOBAL(getDefaultSessionFactory)(TSRMLS_C), mode);
d191 1
a191 1
  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_REDIRECT: %d\r\n%sX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\nX_JAVABRIDGE_CONTEXT_DEFAULT: %s\r\n\r\n%c", (*env)->servlet_context_string, (unsigned long)(size+1), override_redirect, get_cookies(&val, env), EXT_GLOBAL(get_channel)(env), getSessionFactory(env), EXT_GLOBAL(getDefaultSessionFactory)(TSRMLS_C), mode);
d249 1
a249 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\nX_JAVABRIDGE_CONTEXT_DEFAULT: %s\r\n\r\n%c", servlet_context, (unsigned long)(size+1), EXT_GLOBAL(get_channel)(env),  getSessionFactory(env), EXT_GLOBAL(getDefaultSessionFactory)(TSRMLS_C), mode);
@


1.56
log
@Release-3-1-8devel1
@
text
@d88 1
a88 1
							077, 0xFF,0xFF&(l>>8),0xFF&l,
a309 24
void EXT_GLOBAL(check_session) (proxyenv *env TSRMLS_DC) {
  if(!(*env)->is_local && IS_SERVLET_BACKEND(env) && !(*env)->backend_has_session_proxy) {
	if((*env)->peer_redirected) { /* override redirect */
	  int sock = socket (PF_INET, SOCK_STREAM, 0);
	  struct sockaddr *saddr = &(*env)->orig_peer_saddr;
	  if (-1!=sock) {
		static const int is_true = 1;
		setsockopt(sock, 0x6, TCP_NODELAY, (void*)&is_true, sizeof is_true);
		if (-1!=connect(sock, saddr, sizeof (struct sockaddr))) {
		  (*env)->peer0 = (*env)->peer;
		  (*env)->peer = sock;
		  (*env)->f_recv = recv_socket;
		  (*env)->f_send = send_socket;
		} else {				/* could not connect */
		  close(sock);
		  EXT_GLOBAL(sys_error)("Could not connect to server",78);
		}
	  } else
		EXT_GLOBAL(sys_error)("Could not create socket",79);
	}
	(*env)->finish=end_session;
  }
}

d558 45
d615 1
a615 1
	  if(!(*env)->is_shared) close((*env)->peer);
d617 1
a617 10
	if(((*env)->peerr!=-1) && (!(*env)->is_shared)) close((*env)->peerr);
	if(((*env)->peer0!=-1) && (!(*env)->is_shared)) close((*env)->peer0);
	if((*env)->s) free((*env)->s);
	if((*env)->send) free((*env)->send);
	if((*env)->server_name) free((*env)->server_name);
	if((*env)->current_servlet_ctx && (*env)->servlet_ctx != (*env)->current_servlet_ctx) free((*env)->current_servlet_ctx);
	if((*env)->servlet_ctx && (!(*env)->is_shared)) free((*env)->servlet_ctx);
	if((*env)->servlet_context_string) free((*env)->servlet_context_string);
	if((*env)->cfg.hosts) free((*env)->cfg.hosts);
	if((*env)->cfg.servlet) free((*env)->cfg.servlet);
d658 28
a685 32
proxyenv *EXT_GLOBAL(createSecureEnvironment) (int peer, short (*handle_request)(proxyenv *env), short (*handle_cached)(proxyenv *env), char *server_name, short is_local, struct sockaddr *saddr) {
   proxyenv *env;  
   env=(proxyenv*)malloc(sizeof *env);     
   if(!env) return 0;
   *env=(proxyenv)calloc(1, sizeof **env); 
   if(!*env) {free(env); return 0;}

   (*env)->f_recv0 = (*env)->f_recv = recv_socket;
   (*env)->f_send0 = (*env)->f_send = send_socket;

   (*env)->peer = peer;
   (*env)->peer0 = (*env)->peerr = -1;
   (*env)->is_shared = 0;
   (*env)->peer_redirected = 0;
   memcpy(&(*env)->orig_peer_saddr, saddr, sizeof (struct sockaddr));
   
   (*env)->handle = (*env)->handle_request = handle_request;
   (*env)->async_ctx.handle_request = handle_cached;
   (*env)->async_ctx.peer = 0;
   (*env)->async_ctx.nextValue = 0;

   /* parser variables */
   (*env)->pos=(*env)->c = 0;
   (*env)->len = SLEN; 
   (*env)->s=malloc((*env)->len);
   if(!(*env)->s) {free(*env); free(env); return 0;}

   /* send buffer */
   (*env)->send_size=SEND_SIZE;
   (*env)->send=malloc(SEND_SIZE);
   if(!(*env)->send) {free((*env)->s); free(*env); free(env); return 0;}
   (*env)->send_len=0;
d687 36
a722 1
   (*env)->is_local = is_local;
d724 1
a724 30
   (*env)->server_name = server_name;
   (*env)->must_reopen = (*env)->must_share = 0;
   (*env)->connection_is_closed = 0;
   (*env)->current_servlet_ctx = 
	 (*env)->servlet_ctx = (*env)->servlet_context_string = 0;
   (*env)->backend_has_session_proxy = 0;
   (*env)->cfg.ini_user = 0;
   (*env)->cfg.hosts = (*env)->cfg.servlet = 0;

   (*env)->writeInvokeBegin=InvokeBegin;
   (*env)->writeInvokeEnd=InvokeEnd;
   (*env)->writeResultBegin=ResultBegin;
   (*env)->writeResultEnd=ResultEnd;
   (*env)->writeCreateObjectBegin=CreateObjectBegin;
   (*env)->writeCreateObjectEnd=CreateObjectEnd;

   (*env)->writeString=String;
   (*env)->writeBoolean=Boolean;
   (*env)->writeLong=Long;
   (*env)->writeDouble=Double;
   (*env)->writeObject=Object;
   (*env)->writeException=Exception;
   (*env)->writeCompositeBegin_a=CompositeBegin_a;
   (*env)->writeCompositeBegin_h=CompositeBegin_h;
   (*env)->writeCompositeEnd=CompositeEnd;
   (*env)->writePairBegin=PairBegin;
   (*env)->writePairBegin_s=PairBegin_s;
   (*env)->writePairBegin_n=PairBegin_n;
   (*env)->writePairEnd=PairEnd;
   (*env)->writeUnref=Unref;
d726 11
a736 2
   (*env)->writeEndConnection=EndConnection;
   (*env)->finish=end;
d738 6
a743 2
   return env;
 }
d745 10
@


1.55
log
@Release-3-1-8devel
@
text
@d3 38
d160 1
a160 1
  if(!$first) $str = $str . '\r\n';\
@


1.54
log
@Release-3-1-7
@
text
@d49 2
a50 2
							"%c%c%s", 
							077, l&0xFF,
@


1.53
log
@Release-3-1-6
@
text
@d3 2
d9 1
a11 1
#include "php_java.h"
d14 1
d42 1
a42 1
static char*get_context(proxyenv *env, char context[256], short*context_length) {
d45 1
a45 1
	assert(l<256);
d48 1
a48 1
							256, 
d87 1
a87 1
  char kontext[256];
d194 1
a194 1
  char kontext[256];
d222 1
a222 1
  return (ssize_t)fwrite(buf, 1ul, length, (*env)->async_ctx.peer);
d239 1
a239 1
void EXT_GLOBAL(begin_async) (proxyenv*env) {
d243 1
a243 2
  (*env)->handle=(*env)->async_ctx.handle_request;
  (*env)->async_ctx.peer = fdopen((*env)->peer, "w");
a244 1
  //assert((*env)->async_ctx.peer);
d247 1
d250 3
d261 1
a261 5
	int err = fflush((*env)->async_ctx.peer);
	if(err) {
	  php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Fatal: could not fflush async buffer.",93);
	  exit(9);
	}
d264 2
d546 9
a554 2
	if((*env)->peer!=-1) {
	  /* end servlet session */
@


1.52
log
@Release-3-1-6
@
text
@d164 1
a164 1
  if(!success) { (*env)->connection_is_closed = 1; return 0; }
d179 3
@


1.51
log
@Release-3-1-6
@
text
@d555 1
a555 1
	EXT_GLOBAL(destroy_channel)(env);
@


1.50
log
@Release-3-1-2
@
text
@d35 1
a35 1
  static char invalid[] = "0";
d37 1
a37 1
  return context?context:invalid;
a38 1

d99 1
a99 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", servlet_context, (unsigned long)(size+1), EXT_GLOBAL(get_channel)(TSRMLS_C), getSessionFactory(env), mode);
d150 1
a150 1
  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_REDIRECT: %d\r\n%sX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", (*env)->servlet_context_string, (unsigned long)(size+1), override_redirect, get_cookies(&val, env), EXT_GLOBAL(get_channel)(TSRMLS_C), getSessionFactory(env), mode);
d205 1
a205 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", servlet_context, (unsigned long)(size+1), EXT_GLOBAL(get_channel)(TSRMLS_C),  getSessionFactory(env), mode);
d262 1
a262 15

#ifndef __MINGW32__
void EXT_GLOBAL(redirect)(proxyenv*env, char*redirect_port, char*channel_in, char*channel_out TSRMLS_DC) {
  assert(redirect_port);
  if(*redirect_port!='/') { /* socket */
	char *server = EXT_GLOBAL(test_server)(&(*env)->peer, 0, 0 TSRMLS_CC);
	assert(server); if(!server) exit(9);
	free(server);
  } else {						/* pipe */
	(*env)->peerr = open(channel_in, O_RDONLY);
	(*env)->peer = open(channel_out, O_WRONLY);
	if((-1==(*env)->peerr) || (-1==(*env)->peer)) {
	  php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Fatal: could not open comm. pipe.",92);
	  exit(9);
	}
a264 7
  }
}
#else
void EXT_GLOBAL(redirect)(proxyenv*env, char*redirect_port, char*channel_in, char*channel_out TSRMLS_DC) {
  char *server = EXT_GLOBAL(test_server)(&(*env)->peer, 0, 0 TSRMLS_CC);
  assert(server); if(!server) exit(9);
  free(server);
a265 1
#endif
d543 1
a543 1
	  close((*env)->peer);
d545 2
a546 2
	if((*env)->peerr!=-1) close((*env)->peerr);
	if((*env)->peer0!=-1) close((*env)->peer0);
d551 1
a551 1
	if((*env)->servlet_ctx) free((*env)->servlet_ctx);
d555 1
a557 1
	EXT_GLOBAL(destroy_channel)(TSRMLS_C);
d607 1
d631 1
a631 1
   (*env)->must_reopen = 0;
@


1.49
log
@Release-3-1-0
@
text
@d179 1
a179 1
  if(success) (*env)->handle(env);
d618 1
a618 1
proxyenv *EXT_GLOBAL(createSecureEnvironment) (int peer, void (*handle_request)(proxyenv *env), void (*handle_cached)(proxyenv *env), char *server_name, short is_local, struct sockaddr *saddr) {
@


1.48
log
@Release-3-1-0
@
text
@d28 5
d100 1
a100 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", servlet_context, (unsigned long)(size+1), EXT_GLOBAL(get_channel)(TSRMLS_C), getSessionFactory(env), mode);
d151 1
a151 1
  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_REDIRECT: %d\r\n%sX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", (*env)->servlet_context_string, (unsigned long)(size+1), override_redirect, get_cookies(&val, env), EXT_GLOBAL(get_channel)(TSRMLS_C), getSessionFactory(env), mode);
d190 1
d206 1
a206 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: 0\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n", servlet_context, getSessionFactory(env));
d295 2
a296 2
		static const int true = 1;
		setsockopt(sock, 0x6, TCP_NODELAY, (void*)&true, sizeof true);
d389 1
a389 1
   (*env)->send_len+=EXT_GLOBAL(snprintf) ((char*)((*env)->send+(*env)->send_len), flen, "<C v=\"%s\" p=\"%c\" i=\"%ld\">", name, createInstance, (long)((*env)->async_ctx.result=result));
d399 1
a399 1
 static void InvokeBegin(proxyenv *env, long object, char*method, size_t len, char property, void* result) {
d404 1
a404 1
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<I v=\"%ld\" m=\"%s\" p=\"%c\" i=\"%ld\">", object, method, property, (long)((*env)->async_ctx.result=result));
d418 1
a418 1
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<R i=\"%ld\">", (long)((*env)->async_ctx.result=result));
d465 1
d472 11
d489 1
a489 1
 static void Object(proxyenv *env, long object) {
d495 1
a495 1
	 (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len),flen, "<O v=\"%ld\"/>", object);
d498 1
a498 1
 static void Exception(proxyenv *env, long object, char *str, size_t len) {
d505 1
a505 1
	 (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len),flen, "<E v=\"%ld\" m=\"%s\"/>", object, str);
d537 1
a537 1
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<P t=\"N\" v=\"%ld\">", key);
d552 1
a552 1
 static void Unref(proxyenv *env, long object) {
d555 1
a555 1
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<U v=\"%ld\"/>", object);
a561 1
  short is_closed = 0;
d594 1
a594 1
	EXT_GLOBAL(save_cfg)(env TSRMLS_CC);
a598 1
	  (*env)->current_servlet_ctx = 0; 
d600 1
d604 9
a612 1
short EXT_GLOBAL(close_connection)(proxyenv**penv, short persistent_connection TSRMLS_DC) {
d614 2
a615 3
  if(persistent_connection) success = recycle_connection(*penv TSRMLS_CC);
  if(!persistent_connection || !success) close_connection(*penv TSRMLS_CC);
  *penv=0;						/* a copy should already be in connections */
@


1.47
log
@Release-3-1-0
@
text
@d51 1
a51 1
static void send_data(proxyenv *env, char *data, size_t size) {
d58 1
d61 2
a62 2
static void add_header(proxyenv *env, size_t *size, char*header, size_t header_length) {
  if(!header_length) return;
d68 1
d70 1
a70 1
	send_data(env, header, header_length);
d74 2
a75 1
static void end(proxyenv *env) {
d97 1
a97 1
	add_header(env, &size, header, header_length);
d99 1
a99 1
	add_header(env, &size, context, context_length);
d101 2
a102 3
  send_data(env, (char*)(*env)->send, size);

  (*env)->send_len=0;
d132 2
a133 1
static void end_session(proxyenv *env) {
d148 4
a151 2
  add_header(env, &size, header, header_length);
  send_data(env, (char*)(*env)->send, size);
d153 8
d162 1
d165 11
a175 3
static void flush(proxyenv *env) {
  (*env)->finish(env);
  (*env)->handle(env);
d178 2
a179 1
void protocol_end (proxyenv *env) {
d188 1
d191 1
d202 2
a203 2
	add_header(env, &size, header, header_length);
	send_data(env, (char*)(*env)->send, size);
d205 2
a206 2
	add_header(env, &size, context, context_length);
	send_data(env, (char*)(*env)->send, size);
d208 1
a208 1
  (*env)->send_len=0;
d289 2
d386 1
a386 1
 static void CreateObjectEnd(proxyenv *env) {
d391 1
a391 1
   flush(env);
d401 1
a401 1
 static void InvokeEnd(proxyenv *env) {
d406 1
a406 1
   flush(env);
d420 1
a420 1
   end(env);
d423 10
a432 8
 static void EndConnection(proxyenv *env, char property) {
   size_t flen;
   assert(property=='A' || property=='E');
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<F p=\"%c\"/>", property);
   assert((*env)->send_len<=(*env)->send_size);
   flush(env);
 }
d544 1
d548 1
a548 2
	  (*env)->writeEndConnection(env, 'E');
	  protocol_end(env);
a549 2
	  if((*env)->peerr!=-1) close((*env)->peerr);
	  if((*env)->peer0!=-1) close((*env)->peer0);
d551 2
d567 1
a567 1
static void recycle_connection(proxyenv *env TSRMLS_DC) {
d569 1
d571 5
a575 3
	  /* end servlet session */
	  (*env)->writeEndConnection(env, 'A');
	  protocol_end(env);
d585 1
d587 4
a590 5
void EXT_GLOBAL(close_connection)(proxyenv**penv, short persistent_connection TSRMLS_DC) {
  if(persistent_connection) 
	recycle_connection(*penv TSRMLS_CC);
  else
	close_connection(*penv TSRMLS_CC);
d592 1
d630 1
d658 1
@


1.46
log
@Release-3-1-0
@
text
@d527 1
d547 5
d597 2
a598 1
   (*env)->servlet_ctx = (*env)->servlet_context_string = 0;
@


1.45
log
@Release-3-1-0
@
text
@d91 1
a91 1
	assert(!(*env)->peer_redirected || ((*env)->peer_redirected && ((*env)->peer0)==-1));
d402 1
@


1.44
log
@Release-3-1-0
@
text
@d60 2
a61 2
static size_t add_header(proxyenv *env, size_t *size, char*header, size_t header_length) {
  if(!header_length) return 0;
d131 1
a131 2
  size_t s=0, size = (*env)->send_len;
  ssize_t n;
a133 1
  int peer = (*env)->peer;
a169 1
	ssize_t n;
d513 9
a521 18
static void close_connection(proxyenv**penv TSRMLS_DC) {
  if(*penv) {
	proxyenv *env = *penv;
	if(*env) {
	  if((*env)->peer!=-1) {
		/* end servlet session */
		(*env)->writeEndConnection(env, 'E');
		protocol_end(env);
		close((*env)->peer);
		if((*env)->peerr!=-1) close((*env)->peerr);
		if((*env)->peer0!=-1) close((*env)->peer0);
	  }
	  if((*env)->s) free((*env)->s);
	  if((*env)->send) free((*env)->send);
	  if((*env)->server_name) free((*env)->server_name);
	  if((*env)->servlet_ctx) free((*env)->servlet_ctx);
	  if((*env)->servlet_context_string) free((*env)->servlet_context_string);
	  free(*env);
d523 8
d532 2
a534 4

  *penv = 0;
  EXT_GLOBAL(destroy_channel)(TSRMLS_C);
  EXT_GLOBAL(destroy_cloned_cfg)(TSRMLS_C);
a541 7

	  if((*env)->servlet_ctx) {
		free((*env)->servlet_ctx);
		(*env)->servlet_ctx = 0;
	  }
	  
	  (*env)->backend_has_session_proxy = 0;
d543 2
d551 2
a552 1
	close_connection(penv TSRMLS_CC);
d592 2
@


1.43
log
@Release-3-1-0
@
text
@d91 1
a91 1
	assert(!(*env)->peer_redirected || ((*env)->peer_redirected && ((*env)->peer0)!=-1));
a144 1
  assert(!(*env)->peer_redirected || ((*env)->peer_redirected && ((*env)->peer0)!=-1));
d158 1
a158 1
void EXT_GLOBAL (protocol_end) (proxyenv *env) {
d186 1
d399 8
d516 49
a564 1
 proxyenv *EXT_GLOBAL(createSecureEnvironment) (int peer, void (*handle_request)(proxyenv *env), void (*handle_cached)(proxyenv *env), char *server_name, short is_local, struct sockaddr *saddr) {
d624 1
@


1.42
log
@Release-3-1-0
@
text
@d38 1
a38 1
	assert(l<sizeof context);
d41 1
a41 1
							sizeof(context), 
@


1.41
log
@Release-3.0.8
@
text
@d35 1
a35 1
static void send_context(proxyenv *env) {
a36 3
	char context[256] = { 077, l&0xFF};
	int context_length = 2;
	ssize_t n;
d38 6
a43 5
	assert(l<256);
	context_length += 
	  EXT_GLOBAL(snprintf) (context+context_length, 
							sizeof(context)-context_length, 
							"%s", 
d45 25
a69 2
	n=(*env)->f_send(env, context, context_length);
	assert(n==context_length);
d73 1
a73 2
  size_t s=0, size = (*env)->send_len;
  ssize_t n=0;
d75 5
a79 2
  /* send the context for the re-redirected connection */
  if((*env)->must_reopen==2) send_context(env);
a89 1
	ssize_t n;
d94 3
a96 2
	n=(*env)->f_send(env, header, header_length);
	assert(n==header_length);
d98 1
a98 7
  n=0;

 res: 
  errno=0;
  while((size>s)&&((n=(*env)->f_send(env, (*env)->send+s, size-s)) > 0)) 
	s+=n;
  if(size>s && !n && errno==EINTR) goto res; // Solaris, see INN FAQ
a146 3
  n=(*env)->f_send(env, header, header_length);
  assert(n==header_length);
  n=0;
d148 2
a149 5
 res: 
  errno=0;
  while((size>s)&&((n=(*env)->f_send(env, (*env)->send+s, size-s)) > 0)) 
	s+=n;
  if(size>s && !n && errno==EINTR) goto res; // Solaris, see INN FAQ
d161 8
a168 1
  
d181 5
a185 5
	n=(*env)->f_send(env, header, header_length);
	assert(n==header_length);
  } else {
	if((*env)->must_reopen==2) send_context(env);
	(*env)->must_reopen=0;
@


1.40
log
@Release-3.0.8rc
@
text
@d279 1
a279 1
	 java.servlet=MultiUser to retain the path */
@


1.40.2.1
log
@Release-3-0-8-1
@
text
@d279 1
a279 1
	 java.servlet=User to retain the path */
@


1.40.2.2
log
@Release-3-0-8-1
@
text
@d69 1
a69 1
	assert(!(*env)->peer_redirected || ((*env)->peer_redirected && (((*env)->peer0)==-1)));
d128 1
a128 1
  //assert(!(*env)->peer_redirected || ((*env)->peer_redirected && ((*env)->peer0)!=-1));
@


1.40.2.3
log
@Release-3-0-8-1
@
text
@a248 2
		static const int true = 1;
		setsockopt(sock, 0x6, TCP_NODELAY, (void*)&true, sizeof true);
@


1.39
log
@Release-3.0.8test1
@
text
@d210 1
a210 1
	  php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Fatal: could not open fflush async buffer.",93);
@


1.38
log
@Release-3.0.8pre2
@
text
@a83 3
  
  /* store (sync. or async.) result */
  (*env)->handle(env);
a140 3

  /* store result, get_session() always requires a round-trip */
  (*env)->handle_request(env);
d144 2
a145 1
  (*env)->finish(env);			/* end() or end_session() */
@


1.37
log
@Release-3.0.8pre2
@
text
@d47 1
a47 1
	n=(*env)->f_send(env, (*env)->peer, context, context_length);
d72 1
a72 1
	n=(*env)->f_send(env, (*env)->peer, header, header_length);
d79 1
a79 1
  while((size>s)&&((n=(*env)->f_send(env, (*env)->peer, (*env)->send+s, size-s)) > 0)) 
d84 3
d133 1
a133 1
  n=(*env)->f_send(env, peer, header, header_length);
d139 1
a139 1
  while((size>s)&&((n=(*env)->f_send(env, (*env)->peer, (*env)->send+s, size-s)) > 0)) 
d145 2
d150 1
a150 2
  (*env)->finish(env);
  (*env)->handle(env);
d168 1
a168 1
	n=(*env)->f_send(env, (*env)->peer, header, header_length);
d175 2
a176 2
static ssize_t send_pipe(proxyenv*env, int peer, const void*buf, size_t length) {
  return write(peer, buf, length);
d178 5
a182 2
static ssize_t send_socket(proxyenv*env, int peer, const void*buf, size_t length) {
  return send(peer, buf, length, 0);
d193 30
d258 1
d512 1
@


1.36
log
@Release-3.0.7
@
text
@d146 1
a146 1
  (*env)->handle_request(env);
d308 1
a308 1
   (*env)->send_len+=EXT_GLOBAL(snprintf) ((char*)((*env)->send+(*env)->send_len), flen, "<C v=\"%s\" p=\"%c\" i=\"%ld\">", name, createInstance, (long)result);
d323 1
a323 1
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<I v=\"%ld\" m=\"%s\" p=\"%c\" i=\"%ld\">", object, method, property, (long)result);
d333 1
d337 1
a337 1
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<R i=\"%ld\">", (long)result);
a346 27
 static void GetMethodBegin(proxyenv *env, long object, char*method, size_t len, void* result) {
   size_t flen;
   if(!len) len=strlen(method);
   GROW(FLEN+ILEN+len+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<M v=\"%ld\" m=\"%s\" i=\"%ld\">", object, method, (long) result);
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void GetMethodEnd(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "</M>");
   assert((*env)->send_len<=(*env)->send_size);
   flush(env);
 }
 static void CallMethodBegin(proxyenv *env, long object, long method, void* result) {
   size_t flen;
   GROW(FLEN+ILEN+ILEN+ILEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "<F v=\"%ld\" m=\"%ld\" i=\"%ld\">", object, method, (long)result);
   assert((*env)->send_len<=(*env)->send_size);
 }
 static void CallMethodEnd(proxyenv *env) {
   size_t flen;
   GROW(FLEN);
   (*env)->send_len+=EXT_GLOBAL(snprintf)((char*)((*env)->send+(*env)->send_len), flen, "</F>");
   assert((*env)->send_len<=(*env)->send_size);
   flush(env);
 }
d457 1
a457 1
 proxyenv *EXT_GLOBAL(createSecureEnvironment) (int peer, void (*handle_request)(proxyenv *env), char *server_name, short is_local, struct sockaddr *saddr) {
d472 3
a474 1
   (*env)->handle_request = handle_request;
@


1.35
log
@Release-3.0.7
@
text
@d245 8
a252 1
  if(!path) path = (char*)empty;
@


1.34
log
@Release-3.0.6
@
text
@d196 4
d518 1
a518 4
   (*env)->writeGetMethodBegin=GetMethodBegin;
   (*env)->writeGetMethodEnd=GetMethodEnd;
   (*env)->writeCallMethodBegin=CallMethodBegin;
   (*env)->writeCallMethodEnd=CallMethodEnd;
@


1.33
log
@Release-3.0.3
@
text
@d75 1
d108 5
d207 2
a208 2
void EXT_GLOBAL(check_context) (proxyenv *env TSRMLS_DC) {
  if(!(*env)->is_local && IS_SERVLET_BACKEND(env) && !(*env)->servlet_ctx) {
d506 1
@


1.32
log
@Release-3.0.3
@
text
@d50 1
a50 6
static const char *get_channel() {
  static const char empty[] = "";
  char *channel = EXT_GLOBAL(cfg)->channel;
  if(channel) return channel;
  return empty;
}
d60 1
d70 1
a70 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", servlet_context, (unsigned long)(size+1), get_channel(), getSessionFactory(env), mode);
d118 2
d123 1
a123 1
  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_REDIRECT: %d\r\n%sX_JAVABRIDGE_CHANNEL: %s\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", (*env)->servlet_context_string, (unsigned long)(size+1), override_redirect, get_cookies(&val, env), get_channel(), getSessionFactory(env), mode);
d181 1
a181 1
void EXT_GLOBAL(redirect)(proxyenv*env, char*redirect_port TSRMLS_DC) {
d188 2
a189 2
	(*env)->peerr = open(EXT_GLOBAL(cfg)->channel_in, O_RDONLY);
	(*env)->peer = open(EXT_GLOBAL(cfg)->channel_out, O_WRONLY);
d195 1
a195 1
void EXT_GLOBAL(redirect)(proxyenv*env, char*redirect_port TSRMLS_DC) {
@


1.31
log
@Version-3.0(pre)
@
text
@d47 1
a47 1
	n=send((*env)->peer, context, context_length, 0);
d50 6
a55 1

d74 1
a74 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", servlet_context, (unsigned long)(size+1), getSessionFactory(env), mode);
d76 1
a76 1
	n=send((*env)->peer, header, header_length, 0);
d82 1
a82 1
  while((size>s)&&((n=send((*env)->peer, (*env)->send+s, size-s, 0)) > 0)) 
d125 2
a126 2
  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %lu\r\nX_JAVABRIDGE_REDIRECT: %d\r\n%sX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", (*env)->servlet_context_string, (unsigned long)(size+1), override_redirect, get_cookies(&val, env), getSessionFactory(env), mode);
  n=send(peer, header, header_length, 0);
d132 1
a132 1
  while((size>s)&&((n=send((*env)->peer, (*env)->send+s, size-s, 0)) > 0)) 
d160 1
a160 1
	n=send((*env)->peer, header, header_length, 0);
d167 6
d174 29
d212 1
d475 3
d479 1
a479 1
   (*env)->peer0 = -1;
@


1.30
log
@2.0.8RC3 fixes PR1283154 and 1286139 and 1288025 (partially).
@
text
@d68 1
a68 1
	assert(!(*env)->peer_redirected || ((*env)->peer_redirected && (*env)->peer0));
d114 1
a114 1
  short override_redirect = peer0?1:2;
d119 1
a119 1
  assert(!(*env)->peer_redirected || ((*env)->peer_redirected && (*env)->peer0));
d164 1
a164 1
  if(!(*env)->is_local && IS_SERVLET_BACKEND(env)) {
d435 1
a435 1
   (*env)->peer0 = 0;
@


1.29
log
@2.0.8RC2 fixes PR1283148 and 1281189.
@
text
@d11 1
a19 12
#ifndef ZEND_ENGINE_2
extern int EXT_GLOBAL(snprintf) (char *buf, size_t len, const char *format,...);
#else
# if EXTENSION == JAVA
#  define java_ap_php_snprintf ap_php_snprintf 
# elif EXTENSION == MONO
#  define mono_ap_php_snprintf ap_php_snprintf 
# else
#  error unknown EXTENSION
# endif
#endif

d69 1
a69 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %ld\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", servlet_context, size+1, getSessionFactory(env), mode);
d120 1
a120 1
  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %ld\r\nX_JAVABRIDGE_REDIRECT: %d\r\n%sX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", (*env)->servlet_context_string, size+1, override_redirect, get_cookies(&val, env), getSessionFactory(env), mode);
d184 6
a189 4
  static char empty[] = "/";
  static char cmd[] = "\
$path=trim('%s');\
setcookie('%s', '%s', 0, strncmp($_SERVER['PHP_SELF'], $path, strlen($path))?'/':$path);\
d196 3
a198 3
  if(!path) path = empty;
  EXT_GLOBAL(snprintf)(buf, sizeof(buf), cmd, path, key, val);
  ret = zend_eval_string(buf, 0, "setResultWith_cookie" TSRMLS_CC);
@


1.28
log
@2.0.8RC1 fixes PR1276889, 1275899, 1274526, 1202896
@
text
@d16 1
a16 1
#define PRECISION "15" /* 15 .. 17 */
d185 1
a185 1
		  php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Could not connect to server: %s.",78, strerror(errno));
d188 1
a188 1
		php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Could not create socket: %s.",79, strerror(errno));
@


1.27
log
@Release-2.0.8(pre4)
@
text
@d16 1
a16 1
#define PRECISION "20"
d19 1
a19 1
#ifndef __MINGW32__
a157 1
	size_t s=0;
a194 1
  zval xval;
@


1.26
log
@Release-2.0.8(pre4)
@
text
@d46 16
a62 1
  static void send_context(proxyenv *env);
d169 3
a193 13
static void send_context(proxyenv *env) {
	size_t l = strlen((*env)->servlet_ctx);
	char context[SEND_SIZE] = { 077, l&0xFF};
	int context_length = 2;
	ssize_t n;
	
	assert(l<256);
	context_length += EXT_GLOBAL(snprintf) (context+context_length, sizeof(context)-context_length, "%s", 
										   (*env)->servlet_ctx);

	n=send((*env)->peer, context, context_length, 0);
	assert(n==context_length);
}
@


1.25
log
@Release-2.0.8(pre3)
@
text
@d47 1
a47 1
  static send_context(proxyenv *env);
d50 1
a50 1

d55 4
a58 1
  if(!(*env)->is_local && EXT_GLOBAL (get_servlet_context) ()) {
d65 1
a65 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %ld\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", EXT_GLOBAL (get_servlet_context) (), size+1, getSessionFactory(env), mode);
d137 4
d142 1
a142 1
  if(!(*env)->is_local && EXT_GLOBAL (get_servlet_context) ()) {
d150 1
a150 1
	header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: 0\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n", EXT_GLOBAL (get_servlet_context) (),getSessionFactory(env));
d176 1
a176 1
static send_context(proxyenv *env) {
@


1.24
log
@Release-2.0.8-pre3
@
text
@d47 1
d51 4
d107 1
d113 1
a113 1
  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %ld\r\nX_JAVABRIDGE_REDIRECT: 1\r\n%sX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", (*env)->servlet_context_string, size+1, get_cookies(&val, env), getSessionFactory(env), mode);
d169 1
a169 1
void EXT_GLOBAL (send_context)(proxyenv *env) {
d182 19
@


1.23
log
@Release-2.0.8-preview
@
text
@d51 1
a51 1
	char header[1024];
d54 1
d56 1
d59 2
a60 1
	send((*env)->peer, header, header_length, 0);
d72 50
d123 1
a123 1
  end(env);
d131 2
a132 2
	ssize_t n=0;
	char header[1024];
d134 2
a135 1
	unsigned char mode = EXT_GLOBAL (get_mode) ();
d139 2
a140 1
	send((*env)->peer, header, header_length, 0);
d144 19
d165 1
a165 1
	char context[1024] = { 077, l&0xFF};
d167 1
d173 2
a174 1
	send((*env)->peer, context, context_length, 0);
d401 1
a401 1
 proxyenv *EXT_GLOBAL(createSecureEnvironment) (int peer, void (*handle_request)(proxyenv *env), char *server_name, short is_local) {
d409 4
d431 1
a431 1
   (*env)->servlet_ctx = 0;
d457 1
@


1.22
log
@Release-2.0.8(pre)
@
text
@d42 1
a42 1
  register char *context = (*env)->servlet_redirect;
d55 1
a55 4
	if((*env)->cookie_name) 
	  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nCookie: %s=%s\r\nContent-Type: text/html\r\nContent-Length: %ld\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", EXT_GLOBAL (get_servlet_context) (), (*env)->cookie_name, (*env)->cookie_value, size+1, getSessionFactory(env), mode);
	else
	  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %ld\r\nX_JAVABRIDGE_CONTEXT: %s\r\n\r\n%c", EXT_GLOBAL (get_servlet_context) (), size+1, getSessionFactory(env), mode);
d83 1
a83 4
	if((*env)->cookie_name) 
	  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nCookie: %s=%s\r\nContent-Type: text/html\r\nContent-Length: 0\r\n\r\n", EXT_GLOBAL (get_servlet_context) (), (*env)->cookie_name, (*env)->cookie_value);
	else
	  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\nContent-Type: text/html\r\nContent-Length: 0\r\n\r\n", EXT_GLOBAL (get_servlet_context) ());
d90 3
a92 3
	size_t l = strlen((*env)->servlet_redirect);
	char context[1024] = { 077, (l&0xFF000000)>>24, (l&0xFF0000)>>16, (l&0xFF00)>>8, l&0xFF};
	int context_length = 5;
d94 1
d96 1
a96 1
										   (*env)->servlet_redirect);
d262 10
d292 1
d351 1
a351 1
   (*env)->cookie_name = (*env)->cookie_value = (*env)->servlet_redirect = 0;
d368 1
@


1.21
log
@gtk, swing and swt examples added
@
text
@d40 6
d56 1
a56 1
	  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nCookie: %s=%s\r\nContent-Type: text/html\r\nContent-Length: %ld\r\n\r\n%c", EXT_GLOBAL (get_servlet_context) (), (*env)->cookie_name, (*env)->cookie_value, size+1, mode);
d58 1
a58 1
	  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\nContent-Length: %ld\r\n\r\n%c", EXT_GLOBAL (get_servlet_context) (), size+1, mode);
d95 11
d345 1
a345 1
   (*env)->cookie_name = (*env)->cookie_value = 0;
@


1.20
log
@Release-2.0.8pre
@
text
@d40 1
a40 1
static void flush(proxyenv *env) {
d64 4
d174 1
a174 1
   flush(env);
@


1.19
log
@Release-2.0.7
@
text
@d159 13
d328 2
@


1.18
log
@Shut down servlet connection
@
text
@a3 1
#include <assert.h>
@


1.17
log
@Release-2.0.7pre
@
text
@d51 1
a51 1
	  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive; Timeout=120\r\nCookie: %s=%s\r\nContent-Type: text/html\r\nContent-Length: %ld\r\n\r\n%c", EXT_GLOBAL (get_servlet_context) (), (*env)->cookie_name, (*env)->cookie_value, size+1, mode);
d53 1
a53 1
	  header_length=EXT_GLOBAL(snprintf) (header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive; Timeout=120\r\nContent-Type: text/html\r\nContent-Length: %ld\r\n\r\n%c", EXT_GLOBAL (get_servlet_context) (), size+1, mode);
d67 19
@


1.16
log
@Release-2.0.7-pre
@
text
@d11 1
d23 7
a29 1
#define EXT_GLOBAL(snprintf) ap_php_snprintf 
d45 1
a45 1
  if(EXT_GLOBAL (get_servlet_context) ()) {
d267 1
a267 1
 proxyenv *EXT_GLOBAL(createSecureEnvironment) (int peer, void (*handle_request)(proxyenv *env), char *server_name) {
d289 2
@


1.15
log
@Tomcat 5
@
text
@d20 1
a20 1
extern int php_java_snprintf(char *buf, size_t len, const char *format,...);
d22 1
a22 1
#define php_java_snprintf ap_php_snprintf 
d38 1
a38 1
  if(get_servlet_context()) {
d41 1
a41 8
	unsigned short level = cfg->logLevel_val>4?4:cfg->logLevel_val;

#ifndef ZEND_ENGINE_2
  // we want arrays as values
	unsigned char mode=128|64|(level<<2)|2;
#else
	unsigned char mode=128|64|(level<<2)|0;
#endif
d44 1
a44 1
	  header_length=php_java_snprintf(header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: keep-alive\r\nCookie: %s=%s\r\nContent-Type: text/html\r\nContent-Length: %ld\r\n\r\n%c", get_servlet_context(), (*env)->cookie_name, (*env)->cookie_value, size+1, mode);
d46 1
a46 1
	  header_length=php_java_snprintf(header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: keep-alive\r\nContent-Type: text/html\r\nContent-Length: %ld\r\n\r\n%c", get_servlet_context(), size+1, mode);
d109 1
a109 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<C v=\"%s\" p=\"%c\" i=\"%ld\">", name, createInstance, (long)result);
d115 1
a115 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "</C>");
d124 1
a124 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<I v=\"%ld\" m=\"%s\" p=\"%c\" i=\"%ld\">", object, method, property, (long)result);
d130 1
a130 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "</I>");
d138 1
a138 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<M v=\"%ld\" m=\"%s\" i=\"%ld\">", object, method, (long) result);
d144 1
a144 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "</M>");
d151 1
a151 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<F v=\"%ld\" m=\"%ld\" i=\"%ld\">", object, method, (long)result);
d157 1
a157 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "</F>");
d184 1
a184 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<B v=\"%c\"/>", boolean?'T':'F');
d190 1
a190 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<L v=\"%ld\"/>", l);
d196 1
a196 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<D v=\"%."/**/PRECISION/**/"e\"/>", d);
d203 1
a203 1
	 (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<O v=\"\"/>");
d205 1
a205 1
	 (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len),flen, "<O v=\"%ld\"/>", object);
d211 1
a211 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<X t=\"A\">");
d217 1
a217 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<X t=\"H\">");
d223 1
a223 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "</X>");
d230 1
a230 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<P t=\"S\" v=\"%s\">", key);
d236 1
a236 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<P t=\"N\" v=\"%ld\">", key);
d242 1
a242 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<P>");
d248 1
a248 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "</P>");
d254 1
a254 1
   (*env)->send_len+=php_java_snprintf((char*)((*env)->send+(*env)->send_len), flen, "<U v=\"%ld\"/>", object);
d260 1
a260 1
 proxyenv *java_createSecureEnvironment(int peer, void (*handle_request)(proxyenv *env), char *server_name) {
d283 1
@


1.14
log
@Tomcat 5 support / multicasts removed
@
text
@d41 2
d44 2
a45 1
	static const char mode[] = "2";
d47 1
a47 1
	static const char mode[] = "";
d51 1
a51 1
	  header_length=php_java_snprintf(header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: keep-alive\r\nCookie: %s=%s\r\nContent-Type: text/html\r\nContent-Length: %ld\r\n\r\n%s", get_servlet_context(), (*env)->cookie_name, (*env)->cookie_value, size+sizeof(mode)-1, mode);
d53 1
a53 1
	  header_length=php_java_snprintf(header, sizeof(header), "PUT %s HTTP/1.1\r\nHost: localhost\r\nConnection: keep-alive\r\nContent-Type: text/html\r\nContent-Length: %ld\r\n\r\n%s", get_servlet_context(), size+sizeof(mode)-1, mode);
@


1.13
log
@Version 2.0.6 (windows)
@
text
@d38 17
d273 3
d279 2
d287 1
@


1.12
log
@multicast: ignore outdated packets
@
text
@d96 1
a96 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<C v=\"%s\" p=\"%c\" i=\"%ld\">", name, createInstance, (long)result);
d102 1
a102 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "</C>");
d111 1
a111 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<I v=\"%ld\" m=\"%s\" p=\"%c\" i=\"%ld\">", object, method, property, (long)result);
d117 1
a117 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "</I>");
d125 1
a125 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<M v=\"%ld\" m=\"%s\" i=\"%ld\">", object, method, (long) result);
d131 1
a131 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "</M>");
d138 1
a138 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<F v=\"%ld\" m=\"%ld\" i=\"%ld\">", object, method, (long)result);
d144 1
a144 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "</F>");
d171 1
a171 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<B v=\"%c\"/>", boolean?'T':'F');
d177 1
a177 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<L v=\"%ld\"/>", l);
d183 1
a183 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<D v=\"%."/**/PRECISION/**/"e\"/>", d);
d190 1
a190 1
	 (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<O v=\"\"/>");
d192 1
a192 1
	 (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len,flen, "<O v=\"%ld\"/>", object);
d198 1
a198 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<X t=\"A\">");
d204 1
a204 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<X t=\"H\">");
d210 1
a210 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "</X>");
d217 1
a217 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<P t=\"S\" v=\"%s\">", key);
d223 1
a223 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<P t=\"N\" v=\"%ld\">", key);
d229 1
a229 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<P>");
d235 1
a235 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "</P>");
d241 1
a241 1
   (*env)->send_len+=php_java_snprintf((*env)->send+(*env)->send_len, flen, "<U v=\"%ld\"/>", object);
@


1.11
log
@LOCALE fixes
@
text
@d57 1
a57 1
  char c, *s, *new = malloc(newlen);
@


1.10
log
@windows fixes
@
text
@d16 1
d19 5
d26 1
d54 1
a54 1
  static const char quote[]="&quote;";
d92 1
d96 1
a96 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<C v=\"%s\" p=\"%c\" i=\"%ld\">", name, createInstance, (long)result);
d100 1
d102 1
a102 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</C>");
d107 1
d111 1
a111 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<I v=\"%ld\" m=\"%s\" p=\"%c\" i=\"%ld\">", object, method, property, (long)result);
d115 1
d117 1
a117 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</I>");
d122 1
d125 1
a125 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<M v=\"%ld\" m=\"%s\" i=\"%ld\">", object, method, (long) result);
d129 1
d131 1
a131 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</M>");
d136 1
d138 1
a138 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<F v=\"%ld\" m=\"%ld\" i=\"%ld\">", object, method, (long)result);
d142 1
d144 1
a144 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</F>");
d150 1
d169 1
d171 1
a171 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<B v=\"%c\"/>", boolean?'T':'F');
d175 1
d177 1
a177 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<L v=\"%ld\"/>", l);
d181 1
d183 1
a183 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<D v=\"%e\"/>", d);
d187 1
d190 1
a190 1
	 (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<O v=\"\"/>");
d192 1
a192 1
	 (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<O v=\"%ld\"/>", object);
d196 1
d198 1
a198 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<X t=\"A\">");
d202 1
d204 1
a204 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<X t=\"H\">");
d208 1
d210 1
a210 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</X>");
d214 1
d217 1
a217 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<P t=\"S\" v=\"%s\">", key);
d221 1
d223 1
a223 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<P t=\"N\" v=\"%ld\">", key);
d227 1
d229 1
a229 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<P>");
d233 1
d235 1
a235 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</P>");
d239 1
d241 1
a241 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<U v=\"%ld\"/>", object);
@


1.9
log
@Release-2.0.2
@
text
@d41 1
a41 1
  if(pos+1>=newlen) { \
d43 1
a43 1
    new=realloc(new, newlen+1); \
d49 2
a50 2
  register size_t newlen=len+len/10, pos=0;
  char c, *s, *new = malloc(newlen+1);
d219 1
a219 1
 proxyenv *java_createSecureEnvironment(int peer, void (*handle_request)(proxyenv *env)) {
d235 2
@


1.8
log
@Release 2.0
@
text
@d21 2
a22 1
	(*env)->send=realloc((*env)->send, (*env)->send_size*=2); \
d48 1
d55 20
a74 3
	if((c=*name++)=='&') {
	  for(j=0; j< sizeof(quote); j++) {
		new[pos++]=quote[j]; 
a76 3
	} else {
	  new[pos++]=c;
	  GROW_QUOTE();
d79 1
d135 5
a139 2
   size_t len;
   if(!_len) _len=strlen(name);
d141 8
a148 2
   GROW(FLEN+len);
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<S v=\"%s\"/>", name);
@


1.7
log
@bug in S newlen
@
text
@d27 11
a37 3
   send((*env)->peer, (*env)->send, (*env)->send_len, 0);
   (*env)->send_len=0;
   (*env)->handle_request(env);
@


1.6
log
@malloc array 1 element too small
@
text
@d55 2
a56 2
  new[newlen]=0;
  *ret_len=newlen;
@


1.5
log
@*** empty log message ***
@
text
@d34 1
a34 1
    new=realloc(new, newlen); \
d40 1
a40 1
  char c, *s, *new = malloc(newlen);
@


1.4
log
@Protocol update
@
text
@d32 1
a32 1
  if(pos==newlen) { \
d55 1
@


1.3
log
@Protocol update
@
text
@d10 1
a10 1
#include "php_wrapper.h"
d26 1
a26 1
 static void flush(proxyenv *env) {
d30 28
a57 1
 }
d62 1
a62 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<C v=\"%s\" p=\"%c\" i=\"%ld\">", name, createInstance, result);
d75 1
a75 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<I v=\"%ld\" m=\"%s\" p=\"%c\" i=\"%ld\">", object, method, property, result);
d87 1
a87 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<M v=\"%ld\" m=\"%s\" i=\"%ld\">", object, method, result);
d98 1
a98 1
   (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<F v=\"%ld\" m=\"%ld\" i=\"%ld\">", object, method, result);
d108 4
a111 2
 static void String(proxyenv *env, char*name, size_t len) {
   if(!len) len=strlen(name);
d115 1
d184 1
a184 1
 proxyenv *java_createSecureEnvironment(int peer, int (*handle_request)(proxyenv *env)) {
@


1.2
log
@Replaced JNI with XML protocol
@
text
@d12 2
a13 38
// FIXME: Don't use sprintf
static void flush(proxyenv *env) {
  send((*env)->peer, (*env)->send, (*env)->send_len, 0);
  (*env)->send_len=0;
  (*env)->handle_request(env);
}
static void CreateObjectBegin(proxyenv *env, char*name, size_t strlen, short createInstance, void *result) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<C v=\"%s\" p=\"%c\" i=\"%ld\">", name, createInstance?'C':'I', result);
}
static void CreateObjectEnd(proxyenv *env) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</C>");

  flush(env);
}
static void InvokeBegin(proxyenv *env, long object, char*method, size_t strlen, short property, void* result) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<I v=\"%ld\" m=\"%s\" p=\"%c\" i=\"%ld\">", object, method, property?'P':'I', result);
}
static void InvokeEnd(proxyenv *env) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</I>");

  flush(env);
}
static void GetMethodBegin(proxyenv *env, long object, char*method, size_t strlen, void* result) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<M v=\"%ld\" m=\"%s\" i=\"%ld\">", object, method, result);
}
static void GetMethodEnd(proxyenv *env) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</M>");

  flush(env);
}
static void CallMethodBegin(proxyenv *env, long object, long method, void* result) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<F v=\"%ld\" m=\"%ld\" i=\"%ld\">", object, method, result);
}
static void CallMethodEnd(proxyenv *env) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</F>");

  flush(env);
}
d15 2
a16 33
static void String(proxyenv *env, char*name, size_t strlen) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<S v=\"%s\"/>", name);
}
static void Boolean(proxyenv *env, short boolean) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<B v=\"%c\"/>", boolean?'T':'F');
}
static void Long(proxyenv *env, long l) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<L v=\"%ld\"/>", l);
}
static void Double(proxyenv *env, double d) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<L v=\"%e\"/>", d);
}
static void Object(proxyenv *env, long object) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<O v=\"%ld\"/>", object);
}
static void CompositeBegin_a(proxyenv *env) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<X t=\"A\"");
}
static void CompositeBegin_h(proxyenv *env) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<X t=\"H\"");
}
static void CompositeEnd(proxyenv *env) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</X>");
}
static void PairBegin_s(proxyenv *env, char*key, size_t strlen) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<P t=\"S\" v=\"%s\">", key);
}
static void PairBegin_n(proxyenv *env, unsigned long key) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "<P t=\"N\" v=\"%ld\">", key);
}
static void PairEnd(proxyenv *env) {
  (*env)->send_len+=sprintf((*env)->send+(*env)->send_len, "</P>");
}
a17 1

d19 173
a191 35
proxyenv *java_createSecureEnvironment(int peer, int (*handle_request)(proxyenv *env)) {
  proxyenv *env;  
  env=(proxyenv*)malloc(sizeof *env);     
  if(!env) return 0;
  *env=(proxyenv)calloc(1, sizeof **env); 
  if(!*env) {free(env); return 0;}

  (*env)->peer = peer;
  (*env)->handle_request = handle_request;
  (*env)->len = 2; //FIXME: use 255
  (*env)->s=malloc((*env)->len);
  if(!(*env)->s) {free(*env); free(env); return 0;}
  (*env)->send=malloc(8192);
  if(!(*env)->send) {free((*env)->s); free(*env); free(env); return 0;}
  (*env)->send_len=0;

  (*env)->writeInvokeBegin=InvokeBegin;
  (*env)->writeInvokeEnd=InvokeEnd;
  (*env)->writeCreateObjectBegin=CreateObjectBegin;
  (*env)->writeCreateObjectEnd=CreateObjectEnd;
  (*env)->writeGetMethodBegin=GetMethodBegin;
  (*env)->writeGetMethodEnd=GetMethodEnd;
  (*env)->writeCallMethodBegin=CallMethodBegin;
  (*env)->writeCallMethodEnd=CallMethodEnd;
  (*env)->writeString=String;
  (*env)->writeBoolean=Boolean;
  (*env)->writeLong=Long;
  (*env)->writeDouble=Double;
  (*env)->writeObject=Object;
  (*env)->writeCompositeBegin_a=CompositeBegin_a;
  (*env)->writeCompositeBegin_h=CompositeBegin_h;
  (*env)->writeCompositeEnd=CompositeEnd;
  (*env)->writePairBegin_s=PairBegin_s;
  (*env)->writePairBegin_n=PairBegin_n;
  (*env)->writePairEnd=PairEnd;
d193 2
a194 2
  return env;
} 
@


1.1
log
@Replaced JNI with XML protocol
@
text
@a10 1
#include "sio.c"
d12 6
a17 1
// FIXME: Don't use fprintf
d19 1
a19 1
  fprintf((*env)->peer, "<C v=\"%s\" p=\"%c\" i=\"%lx\">", name, createInstance?'C':'I', result);
d22 3
a24 2
  fprintf((*env)->peer, "</C>");
  (*env)->handle_request(env);
d27 1
a27 1
  fprintf((*env)->peer, "<I v=\"%lx\" m=\"%s\" p=\"%c\" i=\"%lx\">", object, method, property?'P':'I', result);
d30 3
a32 2
  fprintf((*env)->peer, "</I>");
  (*env)->handle_request(env);
d35 1
a35 1
  fprintf((*env)->peer, "<M v=\"%lx\" m=\"%s\" i=\"%lx\">", object, method, result);
d38 3
a40 2
  fprintf((*env)->peer, "</M>");
  (*env)->handle_request(env);
d43 1
a43 1
  fprintf((*env)->peer, "<F v=\"%lx\" m=\"%lx\" i=\"%lx\">", object, method, result);
d46 3
a48 2
  fprintf((*env)->peer, "</F>");
  (*env)->handle_request(env);
d52 1
a52 1
  fprintf((*env)->peer, "<S v=\"%s\"/>", name);
d55 1
a55 1
  fprintf((*env)->peer, "<B v=\"%c\"/>", boolean?'T':'F');
d58 1
a58 1
  fprintf((*env)->peer, "<L v=\"%lx\"/>", l);
d61 1
a61 1
  fprintf((*env)->peer, "<L v=\"%d\"/>", d);
d64 1
a64 1
  fprintf((*env)->peer, "<O v=\"%lx\"/>", object);
d67 1
a67 1
  fprintf((*env)->peer, "<X t=\"A\"");
d70 1
a70 1
  fprintf((*env)->peer, "<X t=\"H\"");
d73 1
a73 1
  fprintf((*env)->peer, "</X>");
d76 1
a76 1
  fprintf((*env)->peer, "<P t=\"S\" v=\"%s\">", key);
d79 1
a79 1
  fprintf((*env)->peer, "<P t=\"N\" v=\"%lx\">", key);
d82 1
a82 1
  fprintf((*env)->peer, "</P>");
d84 1
d87 1
a87 1
proxyenv *java_createSecureEnvironment(SFILE *peer, int (*handle_request)(proxyenv *env)) {
d96 6
@

