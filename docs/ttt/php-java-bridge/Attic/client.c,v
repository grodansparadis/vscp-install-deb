head	1.117;
access;
symbols
	Release-4-3-3:1.116.0.8
	ROOT_Release-4-3-3:1.116
	upstream_version_4_3_2:1.116
	debian_version_4_3_2-1:1.116
	ROOT_Release-4-3-2:1.116
	Release-4-3-2:1.116.0.6
	Release-4-3-1:1.116.0.4
	ROOT_Release-4-3-1:1.116
	debian_version_4_3_0-1:1.116
	upstream_version_4_3_0:1.116
	ROOT_Release-4-3-0:1.116
	Release-4-3-0:1.116.0.2
	debian_version_3_2_1b-2:1.110
	debian_version_4_2_2-1:1.115
	upstream_version_4_2_2:1.115
	debian_version_3_2_1b-1:1.110
	upstream_version_3_2_1b:1.110
	Release-4-1-2:1.113.0.2
	Release-4-0-8:1.112.0.4
	debian_version_4_0_8a-1:1.112
	upstream_version_4_0_8a:1.112
	jostb-debian-ubuntu-patch:1.112.0.2
	debian_version_4_0_8-1:1.112
	upstream_version_4_0_8:1.112
	debian_version_4_0_7-1:1.111
	upstream_version_4_0_7:1.111
	debian_version_4_0_6-1:1.111
	upstream_version_4_0_6:1.111
	debian_version_4_0_2-1:1.111
	upstream_version_4_0_2:1.111
	Release-4-0-2_Root:1.111
	Release-4-0-2:1.111.0.2
	upstream_version_4_0_1:1.111
	debian_version_4_0_1-2:1.111
	Release-3-2-1:1.110.0.2
	Release-3-1-8:1.109.0.2
	Release-3-0-8_root:1.90.2.1
	Release-3-0-8_Root:1.93
	Release-3-0-8:1.90.0.2
	Release-2-0-8:1.70.0.4
	Release-2-0-7_Root:1.55
	Release-2-0-7:1.55.0.2
	Release-2-0-6-branch:1.49.0.2
	Version-1:1.29.0.6
	Version-2:1.29.0.4
	Release-2:1.29.0.2
	PHP-5:1.11.0.4
	Release-1-0-6:1.11.0.6
	sparc-64-test:1.9.0.2
	V-2004-08-28:1.1.1.1
	PHP-JAVA-BRIDGE:1.1.1;
locks; strict;
comment	@ * @;
expand	@k@;


1.117
date	2008.01.06.21.07.56;	author jost_boekemeier;	state dead;
branches;
next	1.116;

1.116
date	2007.09.19.10.12.27;	author jost_boekemeier;	state Exp;
branches;
next	1.115;

1.115
date	2007.07.09.14.35.06;	author jost_boekemeier;	state Exp;
branches;
next	1.114;

1.114
date	2007.07.03.15.50.52;	author jost_boekemeier;	state Exp;
branches;
next	1.113;

1.113
date	2007.06.13.19.51.47;	author jost_boekemeier;	state Exp;
branches;
next	1.112;

1.112
date	2007.04.07.16.22.39;	author jost_boekemeier;	state Exp;
branches;
next	1.111;

1.111
date	2007.03.09.20.28.07;	author andremachado;	state Exp;
branches;
next	1.110;

1.110
date	2006.11.25.17.00.31;	author jost2345;	state Exp;
branches;
next	1.109;

1.109
date	2006.09.10.17.31.11;	author jost2345;	state Exp;
branches;
next	1.108;

1.108
date	2006.09.05.20.40.32;	author jost2345;	state Exp;
branches;
next	1.107;

1.107
date	2006.08.27.14.40.11;	author jost2345;	state Exp;
branches;
next	1.106;

1.106
date	2006.08.21.17.41.52;	author jost2345;	state Exp;
branches;
next	1.105;

1.105
date	2006.08.19.12.34.00;	author jost2345;	state Exp;
branches;
next	1.104;

1.104
date	2006.08.08.17.20.45;	author jost2345;	state Exp;
branches;
next	1.103;

1.103
date	2006.07.23.20.32.47;	author jost2345;	state Exp;
branches;
next	1.102;

1.102
date	2006.07.19.15.25.34;	author jost2345;	state Exp;
branches;
next	1.101;

1.101
date	2006.07.16.20.29.25;	author jost2345;	state Exp;
branches;
next	1.100;

1.100
date	2006.06.27.20.44.33;	author jost2345;	state Exp;
branches;
next	1.99;

1.99
date	2006.06.26.18.43.54;	author jost2345;	state Exp;
branches;
next	1.98;

1.98
date	2006.06.19.20.37.14;	author jost2345;	state Exp;
branches;
next	1.97;

1.97
date	2006.05.15.19.03.29;	author jost2345;	state Exp;
branches;
next	1.96;

1.96
date	2006.05.13.16.13.40;	author jost2345;	state Exp;
branches;
next	1.95;

1.95
date	2006.05.07.14.33.33;	author jost2345;	state Exp;
branches;
next	1.94;

1.94
date	2006.05.04.17.48.13;	author jost2345;	state Exp;
branches;
next	1.93;

1.93
date	2006.04.30.17.01.55;	author jost2345;	state Exp;
branches;
next	1.92;

1.92
date	2006.04.26.19.09.31;	author jost2345;	state Exp;
branches;
next	1.91;

1.91
date	2006.04.12.17.46.46;	author jost2345;	state Exp;
branches;
next	1.90;

1.90
date	2006.03.21.18.11.02;	author jost2345;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2006.03.18.18.56.40;	author jost2345;	state Exp;
branches;
next	1.88;

1.88
date	2006.03.16.20.27.00;	author jost2345;	state Exp;
branches;
next	1.87;

1.87
date	2006.03.12.16.44.39;	author jost2345;	state Exp;
branches;
next	1.86;

1.86
date	2006.03.10.18.41.37;	author jost2345;	state Exp;
branches;
next	1.85;

1.85
date	2006.03.01.19.31.38;	author jost2345;	state Exp;
branches;
next	1.84;

1.84
date	2006.02.13.18.34.16;	author jost2345;	state Exp;
branches;
next	1.83;

1.83
date	2006.01.30.19.39.53;	author jost2345;	state Exp;
branches;
next	1.82;

1.82
date	2006.01.15.21.05.30;	author jost2345;	state Exp;
branches;
next	1.81;

1.81
date	2006.01.08.23.44.40;	author jost2345;	state Exp;
branches;
next	1.80;

1.80
date	2006.01.04.19.35.07;	author jost2345;	state Exp;
branches;
next	1.79;

1.79
date	2005.12.28.22.44.32;	author jost2345;	state Exp;
branches;
next	1.78;

1.78
date	2005.12.20.21.26.26;	author jost2345;	state Exp;
branches;
next	1.77;

1.77
date	2005.12.19.19.36.40;	author jost2345;	state Exp;
branches;
next	1.76;

1.76
date	2005.12.18.18.17.48;	author jost2345;	state Exp;
branches;
next	1.75;

1.75
date	2005.12.11.22.24.40;	author jost2345;	state Exp;
branches;
next	1.74;

1.74
date	2005.12.08.18.41.56;	author jost2345;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.23.19.09.42;	author jost2345;	state Exp;
branches;
next	1.72;

1.72
date	2005.11.17.17.24.19;	author jost2345;	state Exp;
branches;
next	1.71;

1.71
date	2005.11.05.13.11.19;	author jost2345;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.15.19.17.38;	author jost2345;	state Exp;
branches;
next	1.69;

1.69
date	2005.09.07.21.13.45;	author jost2345;	state Exp;
branches;
next	1.68;

1.68
date	2005.09.01.20.58.24;	author jost2345;	state Exp;
branches;
next	1.67;

1.67
date	2005.08.24.20.58.31;	author jost2345;	state Exp;
branches;
next	1.66;

1.66
date	2005.08.23.19.09.58;	author jost2345;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.23.18.20.56;	author jost2345;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.21.11.39.39;	author jost2345;	state Exp;
branches;
next	1.63;

1.63
date	2005.08.18.18.31.39;	author jost2345;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.14.15.11.45;	author jost2345;	state Exp;
branches;
next	1.61;

1.61
date	2005.08.11.18.08.16;	author jost2345;	state Exp;
branches;
next	1.60;

1.60
date	2005.08.01.16.56.55;	author jost2345;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.28.17.00.41;	author jost2345;	state Exp;
branches;
next	1.58;

1.58
date	2005.07.25.20.42.27;	author jost2345;	state Exp;
branches;
next	1.57;

1.57
date	2005.07.17.13.46.23;	author jost2345;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.12.15.23.09;	author jost2345;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.08.17.57.22;	author jost2345;	state Exp;
branches;
next	1.54;

1.54
date	2005.07.01.17.39.05;	author jost2345;	state Exp;
branches;
next	1.53;

1.53
date	2005.06.21.20.17.29;	author jost2345;	state Exp;
branches;
next	1.52;

1.52
date	2005.06.19.20.45.40;	author jost2345;	state Exp;
branches;
next	1.51;

1.51
date	2005.06.16.16.10.25;	author jost2345;	state Exp;
branches;
next	1.50;

1.50
date	2005.06.15.15.18.02;	author jost2345;	state Exp;
branches;
next	1.49;

1.49
date	2005.05.15.20.17.35;	author jost2345;	state Exp;
branches;
next	1.48;

1.48
date	2005.04.29.17.35.57;	author jost2345;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.24.17.25.52;	author jost2345;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.23.16.04.26;	author jost2345;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.18.20.32.59;	author jost2345;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.17.21.01.21;	author jost2345;	state Exp;
branches;
next	1.43;

1.43
date	2005.04.15.20.11.10;	author jost2345;	state Exp;
branches;
next	1.42;

1.42
date	2005.04.14.19.24.18;	author jost2345;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.14.19.17.20;	author jost2345;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.11.15.55.41;	author jost2345;	state Exp;
branches;
next	1.39;

1.39
date	2005.04.08.17.11.49;	author jost2345;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.27.15.45.45;	author jost2345;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.13.13.23.12;	author jost2345;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.11.17.34.18;	author jost2345;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.05.14.55.38;	author jost2345;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.21.17.53.18;	author jost2345;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.19.13.29.25;	author jost2345;	state Exp;
branches;
next	1.32;

1.32
date	2005.02.17.21.57.22;	author jost2345;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.15.19.10.27;	author jost2345;	state Exp;
branches;
next	1.30;

1.30
date	2005.02.13.21.43.28;	author jost2345;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.04.17.01.09;	author jost2345;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.28.16.32.52;	author jost2345;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.02.14.02.10;	author jost2345;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.20.20.04.43;	author jost2345;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.12.09.57.25;	author jost2345;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.03.18.35.21;	author jost2345;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.01.20.29.56;	author jost2345;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.29.16.14.33;	author jost2345;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.28.21.12.57;	author jost2345;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.26.21.13.39;	author jost2345;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.24.23.18.16;	author jost2345;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.21.14.44.55;	author jost2345;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.20.16.19.14;	author jost2345;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.19.16.54.33;	author jost2345;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.18.21.39.55;	author jost2345;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.17.18.31.08;	author jost2345;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.16.23.28.17;	author jost2345;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.11.18.36.00;	author jost2345;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.12.17.07.16;	author jost2345;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.11.18.11.52;	author jost2345;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.09.11.35.17;	author jost2345;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2004.10.07.11.19.46;	author jost2345;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.06.16.37.59;	author jost2345;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.04.16.28.29;	author jost2345;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.26.13.32.42;	author jost2345;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.22.19.17.48;	author jost2345;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.19.18.45.13;	author jost2345;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.09.21.49.23;	author jost2345;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.28.06.05.06;	author jost2345;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.08.28.06.05.06;	author jost2345;	state Exp;
branches;
next	;

1.9.2.1
date	2004.10.09.21.57.19;	author jost2345;	state Exp;
branches;
next	;

1.90.2.1
date	2006.04.23.19.09.08;	author jost2345;	state Exp;
branches;
next	1.90.2.2;

1.90.2.2
date	2006.05.05.18.29.54;	author jost2345;	state Exp;
branches;
next	1.90.2.3;

1.90.2.3
date	2006.05.13.16.09.57;	author jost2345;	state Exp;
branches;
next	;


desc
@@


1.117
log
@Release-5-0-0
@
text
@/*-*- mode: C; tab-width:4 -*-*/

/* client.c -- communicates with the PHP/Java Bridge back end.

  Copyright (C) 2003-2007 Jost Boekemeier

  This file is part of the PHP/Java Bridge.

  The PHP/Java Bridge ("the library") is free software; you can
  redistribute it and/or modify it under the terms of the GNU General
  Public License as published by the Free Software Foundation; either
  version 2, or (at your option) any later version.

  The library is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with the PHP/Java Bridge; see the file COPYING.  If not, write to the
  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307 USA.

  Linking this file statically or dynamically with other modules is
  making a combined work based on this library.  Thus, the terms and
  conditions of the GNU General Public License cover the whole
  combination.

  As a special exception, the copyright holders of this library give you
  permission to link this library with independent modules to produce an
  executable, regardless of the license terms of these independent
  modules, and to copy and distribute the resulting executable under
  terms of your choice, provided that you also meet, for each linked
  independent module, the terms and conditions of the license of that
  module.  An independent module is a module which is not derived from
  or based on this library.  If you modify this library, you may extend
  this exception to your version of the library, but you are not
  obligated to do so.  If you do not wish to do so, delete this
  exception statement from your version. */

#include "zend.h"
#include "init_cfg.h"
#if !defined(ZEND_ENGINE_2)

#include "php_java.h"

/* execve, mkfifo */
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>

/* strings */
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#include <ctype.h>

/* setenv */
#include <stdlib.h>

/* signal */
#include <signal.h>

/* miscellaneous */
#include <stdio.h>
#include <errno.h>

/* php */
#ifdef ZEND_ENGINE_2
#include "zend_exceptions.h"
#else
#include "zend_stack.h"
#endif

#include "protocol.h"
#include "parser.h"
#include "php_java_strtod.h"

#include "java_bridge.h"

EXT_EXTERN_MODULE_GLOBALS(EXT)

#ifdef DISABLE_HEX
#define GET_LONG(val) strtol(val, 0, 10)
#else
#define GET_LONG(val) strtoul(val, 0, 16)
#endif


static void setResultFromString (pval *presult, unsigned char*s, size_t len){
  Z_TYPE_P(presult)=IS_STRING;
  Z_STRLEN_P(presult)=len;
  Z_STRVAL_P(presult)=emalloc(Z_STRLEN_P(presult)+1);
  memcpy(Z_STRVAL_P(presult), s, Z_STRLEN_P(presult));
  Z_STRVAL_P(presult)[Z_STRLEN_P(presult)]=0;
}
#ifdef DISABLE_HEX
static  void  setResultFromLong  (pval *presult, long value) {
  Z_TYPE_P(presult)=IS_LONG;
  Z_LVAL_P(presult)=value;
}
#else
static void setResultFromLong (pval *presult, unsigned long value, short flag){
  Z_TYPE_P(presult)=IS_LONG;
  if(flag)
	Z_LVAL_P(presult)=value*-1;
  else
	Z_LVAL_P(presult)=value;
}
#endif

static void  setResultFromDouble  (pval *presult, double value) {
  Z_TYPE_P(presult)=IS_DOUBLE;
  Z_DVAL_P(presult)=value;
}

static  void  setResultFromBoolean  (pval *presult, short value) {
  Z_TYPE_P(presult)=IS_BOOL;
  Z_LVAL_P(presult)=value;
}

#ifdef ZEND_ENGINE_2
static  void  setResultFromException  (pval *presult, long value) {
  /* wrap the vm object in a pval object */
  TSRMLS_FETCH();
  
  assert(Z_TYPE_P(presult) == IS_NULL);
  if (Z_TYPE_P(presult) != IS_OBJECT) {
	object_init_ex(presult, EXT_GLOBAL(exception_class_entry));
	presult->is_ref=1;
    presult->refcount=1;
  }
  EXT_GLOBAL(store_jobject)(presult, value TSRMLS_CC);
}

static void setResultFromObject (pval *presult, long value, char type) {
  /* wrap the vm object in a pval object */
  TSRMLS_FETCH();
  
  if (Z_TYPE_P(presult) != IS_OBJECT) {
	switch(type) {
	case 'C':
	case 'A': 
	  object_init_ex(presult, EXT_GLOBAL(array_entry));
	  break;
	default: 
	  assert(0);
	case 'O':
	case 'E':
	  object_init_ex(presult, EXT_GLOBAL(class_entry));
	  break;
	}
	presult->is_ref=1;
	presult->refcount=1;

  } else {
	if((type=='C' || type=='A') && 
	   !instanceof_function(Z_OBJCE_P(presult), EXT_GLOBAL(array_entry) TSRMLS_CC)) {
	  object_init_ex(presult, EXT_GLOBAL(array_entry));
	}
  }

  EXT_GLOBAL(store_jobject)(presult, value TSRMLS_CC);
}
#else
static void setResultFromObject (pval *presult, long value, char type) {
  /* wrap the vm object in a pval object */
  pval *handle;
  TSRMLS_FETCH();
  
  if (Z_TYPE_P(presult) != IS_OBJECT) {
	object_init_ex(presult, EXT_GLOBAL(class_entry));
	presult->is_ref=1;
    presult->refcount=1;
  }

  ALLOC_ZVAL(handle);
  Z_TYPE_P(handle) = IS_LONG;
  Z_LVAL_P(handle) = value;
  pval_copy_constructor(handle);
  INIT_PZVAL(handle);
  zend_hash_index_update(Z_OBJPROP_P(presult), 0, &handle, sizeof(pval *), NULL);
}
#endif


/*
 * Call a user function. Since our cross-compiler (which creates
 * windows executables) does not allow us to access EG(exception),
 * this is currently a two step process: We first jump into the
 * evaluator in order to handle exceptions for us.  The evaluator will
 * call the _call_with_exception_handler() thunk which calls the user
 * function with our exception handler in place.  If the user function
 * is in the current environment, we call it directly, asking
 * _call_with_exception_handler to provide the parameter array.  If an
 * exception occured, the _exception_handler procedure is called,
 * which sets the JG(exception) and communicates the exception to the
 * server.
 *
 * The current scheme allows us to support exception handling in PHP4:
 * If we detect that the server's java_last_exception carries an
 * exception after executing the thunk (in which case we can be sure
 * that the thunk was aborted), we can call the _exception_handler
 * with the exception. -- After that the communication continues as
 * usual: the server receives the exception as the result of the apply
 * call and might communicate the exception back to us which in turn
 * causes an abortion of the next frame until either the server or the
 * client catches the exception or there are no more frames available.
 */ 
static int call_user_cb(zval**object, zval*func, zval**retval_ptr, zval*func_params TSRMLS_DC) {
  int retval, err;
  struct cb_stack_elem stack_elem = {0, object, func, retval_ptr, func_params};
  
  static const char name[] = "call_with_exception_handler";
#if defined(ZEND_ENGINE_2)
  static const char call_with_exception_handler[] =
	"try {"/**/EXT_NAME()/**/"_call_with_exception_handler();} catch (Exception $__JavaException) {"/**/EXT_NAME()/**/"_exception_handler($__JavaException);}";
#else
  static const char call_with_exception_handler[] =
	EXT_NAME()/**/"_call_with_exception_handler();";
#endif	
  if(!JG(cb_stack)){
	JG(cb_stack)=emalloc(sizeof*JG(cb_stack));
	if(!JG(cb_stack))exit(9);
	zend_stack_init(JG(cb_stack));
  }
  zend_stack_push(JG(cb_stack), &stack_elem, sizeof stack_elem);
  
  retval = zend_eval_string((char*)call_with_exception_handler, 0, (char*)name TSRMLS_CC);
  return retval;
}

/*
 * Check for exception and communicate the exception back to the
 * server.  Return true if an exception was handled.
 */
static short handle_exception(zval*presult TSRMLS_DC) {
  short has_exception=0;
  struct cb_stack_elem *stack_elem;
  int err = zend_stack_top(JG(cb_stack), (void**)&stack_elem); assert(SUCCESS==err);
  if(stack_elem->exception&&Z_TYPE_P(stack_elem->exception)!=IS_NULL) {
	proxyenv *jenv = EXT_GLOBAL(connect_to_server)(TSRMLS_C);
	long result;
	//php_error(E_WARNING, "php_mod_"/**/EXT_NAME()/**/"(%d): Unhandled exception during callback in user function: %s.", 25, fname);
	EXT_GLOBAL(get_jobject_from_object)(stack_elem->exception, &result TSRMLS_CC);
	has_exception=1;
#ifdef ZEND_ENGINE_2
	{
		zval *ex = 0;
		zval fname;
		ZVAL_STRINGL(&fname, "__toString", sizeof("__toString")-1, 0);
		call_user_function_ex(0, &stack_elem->exception, &fname, &ex, 0, 0, 1, 0 TSRMLS_CC);
		if(ex) {
		  (*jenv)->writeResultBegin(jenv, presult);
		  (*jenv)->writeException(jenv, result, 
								  Z_STRVAL_P(ex), Z_STRLEN_P(ex));
		} else {
		  (*jenv)->writeResultBegin(jenv, presult);
		  (*jenv)->writeException(jenv, result, "php exception", 0);
		}
		(*jenv)->writeResultEnd(jenv);
	  }
#else
	(*jenv)->writeResultBegin(jenv, presult);
	(*jenv)->writeException(jenv, result, "php exception", 0);
	(*jenv)->writeResultEnd(jenv);
#endif
	zval_ptr_dtor(&stack_elem->exception);
#if defined(ZEND_ENGINE_2)
	zend_clear_exception(TSRMLS_C);
#endif
}
  return has_exception;
}

static void setResultFromApply(zval *presult, unsigned char *cname, size_t clen, unsigned char*fname, size_t flen, zval *object, zval *func_params)
{
  zval *func, *retval_ptr=0;
  
  TSRMLS_FETCH();

  MAKE_STD_ZVAL(func);
  setResultFromString(func, cname, clen);

  if (call_user_cb(&object, func, &retval_ptr, func_params TSRMLS_CC) != SUCCESS) {
	php_error(E_WARNING, "php_mod_"/**/EXT_NAME()/**/"(%d): Could not call user function: %s.", 23, cname);
  } else {
	int err;
	if(!handle_exception(presult TSRMLS_CC)) EXT_GLOBAL(result)(retval_ptr, 0, presult TSRMLS_CC);
	err = zend_stack_del_top(JG(cb_stack));
	assert(SUCCESS==err);
  }

  if(retval_ptr) 
	zval_ptr_dtor(&retval_ptr);
  zval_ptr_dtor(&func);
}
/*
 * Since PHP doesn't offer an easy way to call a PHP function without
 * accessing a global variable we must push the arguments on a stack
 * and call zend_eval_string. It evaluates a wrapper function which in
 * turn calls a user function on PHP level to provide the argument
 * array.
 */
void EXT_GLOBAL(call_php_function)(unsigned char *name, size_t len, zval *func_params, zval **retval_ptr) {
  zval *object = 0, *func;

  TSRMLS_FETCH();

  MAKE_STD_ZVAL(func);
  setResultFromString(func, name, len);

  if (call_user_cb(&object, func, retval_ptr, func_params TSRMLS_CC) != SUCCESS) {
	php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Could not call php function: %s.", 24, name);
	exit(9);
  } else {
	struct cb_stack_elem *stack_elem;
	int err = zend_stack_top(JG(cb_stack), (void**)&stack_elem); 
	assert(SUCCESS==err);
#ifdef ZEND_ENGINE_2
	if(stack_elem->exception&&Z_TYPE_P(stack_elem->exception)!=IS_NULL) {
	  zval *ex = 0;
	  zval fname;
	  ZVAL_STRINGL(&fname, "__toString", sizeof("__toString")-1, 0);
	  call_user_function_ex(0, &stack_elem->exception, &fname, &ex, 0, 0, 1, 0 TSRMLS_CC);
	  if(ex) {
		php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Exception in PHP function %s: %s.", 43, name, Z_STRVAL_P(ex));
	  } else {
		php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Exception in PHP function %s.", 43, name);
	  }
	}
#endif
	err = zend_stack_del_top(JG(cb_stack));
	assert(SUCCESS==err);
  }
  zval_ptr_dtor(&func);
}

static  void  setResultFromArray  (pval *presult) {
  array_init( presult );
  INIT_PZVAL( presult );
}

static  pval*nextElement  (pval *handle) {
  pval *result;
  MAKE_STD_ZVAL(result);
  ZVAL_NULL(result);
  zend_hash_next_index_insert(Z_ARRVAL_P(handle), &result, sizeof(zval *), NULL);
  return result;
}

static  pval*hashIndexUpdate  (pval *handle, long key) {
  pval *result;
  MAKE_STD_ZVAL(result);
  ZVAL_NULL(result);
  zend_hash_index_update(Z_ARRVAL_P(handle), (unsigned long)key, &result, sizeof(zval *), NULL);
  return result;
}

static pval*hashUpdate  (pval *handle, unsigned char *key, size_t len) {
  pval *result;
  MAKE_STD_ZVAL(result);
  ZVAL_NULL(result);
  assert(key);
  zend_hash_update(Z_ARRVAL_P(handle), (char*)key, len+1, &result, sizeof(zval *), NULL);
  return result;
}

static  void  setException  (pval *presult, long value, unsigned char *strValue, size_t len) {
#ifndef ZEND_ENGINE_2
  setResultFromString(presult, strValue, len);
  Z_TYPE_P(presult)=IS_EXCEPTION;
#else
  zval *exception;

  TSRMLS_FETCH();
  ZVAL_NULL(presult);
  MAKE_STD_ZVAL(exception); 
  ZVAL_NULL(exception);
  setResultFromException(exception, value); 
  zend_throw_exception_object(exception TSRMLS_CC);
#endif
}

#define GET_RESULT(pos) if(!ctx->id) {ctx->id=(zval*)GET_LONG((const char*)PARSER_GET_STRING(st, pos));}
struct stack_elem { 
  zval *container;				/* ctx->id */
  char composite_type;          /* A|H */

  unsigned char *m, *p;						/* see Apply in PROTOCOL.TXT */
  size_t m_length, p_length;
  long v, n;
  zval *retval;
};
struct parse_ctx {
  zval*id;
  zend_stack containers;
};
static void begin(parser_tag_t tag[3], parser_cb_t *cb){
  struct parse_ctx *ctx=(struct parse_ctx*)cb->ctx;
  parser_string_t *st=tag[2].strings;

  switch ((*tag[0].strings[0].string)[tag[0].strings[0].off]) {
  case 'A':						/* receive apply args as normal array */
	GET_RESULT(4);
	{
	  /* store array result in tmp_retval, keep ctx->id in retval */
	  zval *tmp_retval;
	  MAKE_STD_ZVAL(tmp_retval);
	  ZVAL_NULL(tmp_retval);

      {
      struct stack_elem stack_elem = 
		{ tmp_retval, 'A', 
		  (unsigned char*)strdup((char*)PARSER_GET_STRING(st, 2)), /* m */
		  (unsigned char*)strdup((char*)PARSER_GET_STRING(st, 1)), /* p */
		  st[2].length,			/* m_length */
		  st[1].length,			/* p_length */
		  (*cb->env)->async_ctx.nextValue =
		  GET_LONG((const char*)PARSER_GET_STRING(st, 0)), /* v */
		  GET_LONG((const char*)PARSER_GET_STRING(st, 3)), /* n */
		  ctx->id
		}; 
	  zend_stack_push(&ctx->containers, &stack_elem, sizeof stack_elem);
      }
	  setResultFromArray(tmp_retval);
	  break;
	}
  case 'X':
	GET_RESULT(1);
	{
      struct stack_elem stack_elem = { ctx->id, *PARSER_GET_STRING(st, 0) };
	  zend_stack_push(&ctx->containers, &stack_elem, sizeof stack_elem);
	  setResultFromArray(ctx->id);
	  break;
	}
  case 'P':
	{ 
      struct stack_elem *stack_elem;
	  zend_stack_top(&ctx->containers, (void**)&stack_elem);
	  if(stack_elem->composite_type=='H') { /* hash table */
		if(*PARSER_GET_STRING(st, 0)=='N')	/* number */
		  ctx->id=hashIndexUpdate(stack_elem->container, GET_LONG((const char*)PARSER_GET_STRING(st, 1)));
		else
		  ctx->id=hashUpdate(stack_elem->container, PARSER_GET_STRING(st, 1), st[1].length);
	  }
	  else {						/* array */
		ctx->id=nextElement(stack_elem->container);
	  }
	  break;
	}
  case 'S':
	GET_RESULT(1);
	setResultFromString(ctx->id, PARSER_GET_STRING(st, 0), st[0].length);
	break;
  case 'B':
	GET_RESULT(1);
	setResultFromBoolean(ctx->id, *PARSER_GET_STRING(st, 0)=='T');
	break;
#ifndef DISABLE_HEX
  case 'L':
	GET_RESULT(2);
	assert(*PARSER_GET_STRING(st, 1)=='O' || *PARSER_GET_STRING(st, 1)=='A');
	setResultFromLong(ctx->id, GET_LONG((const char*)PARSER_GET_STRING(st, 0)), *PARSER_GET_STRING(st, 1)!='O');
	break;
#else
  case 'L':
	GET_RESULT(1);
	setResultFromLong(ctx->id, GET_LONG((const char*)PARSER_GET_STRING(st, 0)));
	break;
#endif
  case 'D':
	GET_RESULT(1);
	setResultFromDouble(ctx->id, EXT_GLOBAL(strtod)((const char*)PARSER_GET_STRING(st, 0), NULL));
	break;
  case 'N':
	GET_RESULT(0);
	ZVAL_NULL(ctx->id);
	break;
  case 'O':
	GET_RESULT(2);
	assert((((*tag[1].strings[0].string)[tag[1].strings[0].off])=='v')&&
		   (((*tag[1].strings[1].string)[tag[1].strings[1].off])=='p')&&
		   (((*tag[1].strings[2].string)[tag[1].strings[2].off])=='i'));

	setResultFromObject(ctx->id, (*cb->env)->async_ctx.nextValue=GET_LONG((const char*)PARSER_GET_STRING(st, 0)), *PARSER_GET_STRING(st, 1));
	break;
  case 'F': break;
  case 'E':
	{
	  unsigned char *stringRepresentation=PARSER_GET_STRING(st, 1);
	  size_t len=st[1].length;
	  long obj = GET_LONG((const char*)PARSER_GET_STRING(st, 0));
	  GET_RESULT(2);
	  setException(ctx->id, (*cb->env)->async_ctx.nextValue=obj, stringRepresentation, len);
	  break;
	}
	default:
	  {
		short i;
		char *hosts;
		char *servlet;
		TSRMLS_FETCH();
		hosts = JG(hosts); 
		servlet = JG(servlet); 
		assert(((*cb->env)->pos) < RECV_SIZE);
#ifndef __MINGW32__
		php_write((*cb->env)->recv_buf, (*cb->env)->pos TSRMLS_CC);
#endif
		for(i=0; i<(*cb->env)->pos; i++) {
		  char c = (*cb->env)->recv_buf[i];
		  if(c<32) (*cb->env)->recv_buf[i] = '?';
		}
		php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Protocol violation at pos %d while trying to connect to %s(%s). Please check that the back-end (JavaBride.war) is deployed or please switch off the java.servlet option. Received bytes: %*s\n", 88, (*cb->env)->c, hosts?hosts:"null", servlet?servlet:"null", (*cb->env)->pos, (*cb->env)->recv_buf);
	  }
  }
}
static void end(parser_string_t st[1], parser_cb_t *cb){
  char c = (*(st[0].string)[st[0].off]);
  switch (c) {
  case 'X': 
	{ 
	  int err;
	  struct parse_ctx *ctx=(struct parse_ctx*)cb->ctx;
	  err=zend_stack_del_top(&ctx->containers);
	  assert(SUCCESS==err);
	}
	break;
  }
}
static void remove_pipe(proxyenv*env) {
  struct pipe *pipe = &((*env)->pipe);
  if((*env)->is_shared) return;

  unlink(pipe->in); unlink(pipe->out);
  close(pipe->lockfile); unlink(pipe->channel);
}
/**
 * Server agreed that we can re-use the connection for a different web
 * context.
 */
static void share_connection(proxyenv*env, char*redirect_port TSRMLS_DC) {
  assert(redirect_port);
  if(!(*env)->servlet_ctx) /* shouldn't happen */
	(*env)->servlet_ctx=JG(servlet_ctx);

  (*env)->peer = JG(peer);
  if(*redirect_port=='/') {		/* pipe */
	remove_pipe(env);
	(*env)->peerr = JG(peerr);
	EXT_GLOBAL(redirect_pipe)(env);
  }
  (*env)->is_shared=1;
  (*env)->must_reopen=2;		/* send a header */
}


#ifndef __MINGW32__
static void redirect(proxyenv*env, char*redirect_port, char*channel_in, char*channel_out TSRMLS_DC) {
  assert(redirect_port);
  if(*redirect_port!='/') { /* socket */
	char *server = EXT_GLOBAL(test_server)(&(*env)->peer, 0, 0 TSRMLS_CC);
	assert(server); if(!server) exit(9);
	free(server);

	/* the default peer */
	if(JG(peer)==-1) JG(peer)=(*env)->peer;
  } else {						/* pipe */
	(*env)->peerr = open(channel_in, O_RDONLY);
	(*env)->peer = open(channel_out, O_WRONLY);
	if((-1==(*env)->peerr) || (-1==(*env)->peer)) {
	  php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Fatal: could not open comm. pipe.",92);
	  exit(9);
	}
	EXT_GLOBAL(redirect_pipe)(env);

	/* we can unlink the channel_in and channel_out right here because
	   the above open() calls block until both the server and the
	   client are connected. Unix will automatically remove the inodes
	   as soon as the channel isn't used anymore. */
	EXT_GLOBAL(unlink_channel)(env);

	/* the default peer */
	if(JG(peer)==-1) JG(peer)=(*env)->peer;
	if(JG(peerr)==-1) JG(peerr)=(*env)->peerr;
  }
}
#else
static void redirect(proxyenv*env, char*redirect_port, char*channel_in, char*channel_out TSRMLS_DC) {
  char *server = EXT_GLOBAL(test_server)(&(*env)->peer, 0, 0 TSRMLS_CC);
  assert(server); if(!server) exit(9);
  free(server);

  /* the default peer */
  if(JG(peer)==-1) JG(peer)=(*env)->peer;
}
#endif

static const char key_hosts[]="java.hosts";
static const char key_servlet[] = "java.servlet";
static void begin_header(parser_tag_t tag[3], parser_cb_t *cb){
  proxyenv *ctx=(proxyenv*)cb->env;
  char *str=(char*)PARSER_GET_STRING(tag[0].strings, 0);
  TSRMLS_FETCH();
  switch (*str) {
  case 'S'://Set-Cookie:
	{
	  char *cookie, *cookie_name, *path;
	  static const char setcookie[]="Set-Cookie";
	  if(strcasecmp(str, setcookie)) return;
	  cookie_name = (char*)PARSER_GET_STRING(tag[1].strings, 0);
	  cookie = (char*)PARSER_GET_STRING(tag[2].strings, 0);
	  if((path=strchr(cookie, ';'))) { /* strip off path */
		char*end;
		*path++=0;
		if((path=strchr(path, '='))) path++;
		if((end=strchr(path, ';'))) *end=0;
	  }
	  EXT_GLOBAL(setResultWith_context)(cookie_name, cookie, path);
	  break;
	}

  case 'C'://Content-Length or Connection
	{
	  static const char con_connection[]="Connection", con_close[]="close";
	  if(!strcasecmp(str, con_connection)&&!strcasecmp((char*)PARSER_GET_STRING(tag[1].strings, 0), con_close)) {
		if(!(*ctx)->must_reopen) (*ctx)->must_reopen = 1;
	  }
	  break;
	}
  case 'X':// Redirect
	{
	  char *key;
	  static const char context[] = "X_JAVABRIDGE_CONTEXT";
	  static const char redirect[]= "X_JAVABRIDGE_REDIRECT";
	  if(!(*ctx)->peer_redirected && !strcasecmp(str, redirect)) {
		char *key = (char*)PARSER_GET_STRING(tag[1].strings, 0);
		size_t key_len = tag[1].strings[0].length;
		char *name = (*ctx)->server_name;
		char *idx = strchr(name, ':');
		size_t len = idx ? idx-name : strlen(name);
		char *server_name = malloc(len+1+key_len+1);
		char *pos = server_name;
		assert(server_name); if(!server_name) exit(9);

		memcpy(server_name, name, len); pos+=len;
		*pos=':';
		JG(redirect_port)=pos+1;
		memcpy(pos+1, key, key_len); pos+=key_len+1;
		*pos=0;

		if(JG(hosts)) free(JG(hosts));
		JG(hosts)=server_name;

		(*ctx)->must_reopen = 2;
	  } else if((!(*ctx)->servlet_ctx)&&(!strcasecmp(str, context))) {
		key = (char*)PARSER_GET_STRING(tag[1].strings, 0);
		(*ctx)->servlet_ctx = strdup(key);
		if(!JG(servlet_ctx)) JG(servlet_ctx)=(*ctx)->servlet_ctx;

	  }

	  break;
	}
  }
}

/* asyncronuous cb */
static short handle_cached(proxyenv *env) {
  struct async_ctx *ctx = &(*env)->async_ctx;
  setResultFromObject(ctx->result, ++ctx->nextValue, 'O');
  return 1;
}  

/* synchronuous cb */
static short handle_request(proxyenv *env) {
  short rc;
  short tail_call;
  struct parse_ctx ctx = {0};
  parser_cb_t cb = {begin, end, &ctx, env};
  struct stack_elem *stack_elem;

  TSRMLS_FETCH();
 handle_request:
  if(!(*env)->is_local && IS_OVERRIDE_REDIRECT(env)) {
	parser_cb_t cb_header = {begin_header, 0, 0, env};
	rc = EXT_GLOBAL (parse_header) (env, &cb_header);
	if(!rc) return 0;
  }
  zend_stack_init(&ctx.containers);
  rc = EXT_GLOBAL (parse) (env, &cb);
  if(!rc) { zend_stack_destroy(&ctx.containers); return 0; }
  /* pull off A, if any */
  if(SUCCESS==zend_stack_top(&ctx.containers, (void**)&stack_elem))	{
	int err;
	assert(stack_elem->m); if(!stack_elem->m) exit(9);
	assert(stack_elem->p); if(!stack_elem->p) exit(9);
	setResultFromApply(stack_elem->retval, stack_elem->p, stack_elem->p_length, stack_elem->m, stack_elem->m_length, (zval*)stack_elem->v, stack_elem->container);
	free(stack_elem->m);
	free(stack_elem->p);
	zval_ptr_dtor(&stack_elem->container);
	err=zend_stack_del_top(&ctx.containers);
	assert(SUCCESS==err);
	tail_call = 1;
  } else {
	tail_call = 0;
  }
  assert(zend_stack_is_empty(&ctx.containers));
  zend_stack_destroy(&ctx.containers);

  /* revert override redirect */
  if((*env)->peer0!=-1) {

	(*env)->f_close(env);
	(*env)->redirect(env);

	(*env)->peer = (*env)->peer0;
	(*env)->f_recv = (*env)->f_recv0;
	(*env)->f_send = (*env)->f_send0;
	(*env)->peer0 = -1;
  } else {	 /* Override redirect opens a secondary channel to the
			  backend. Skip the following if an override redirect
			  happened in the middle of redirect/reopen handling. */
	switch(((*env)->must_reopen)) {
	  /* re-open a closed HTTP connection */
	  char*server;
	case 2: // redirect
	  (*env)->peer_redirected = 1;
	  JG(ini_user)&=~(U_SERVLET|U_SOCKNAME);
	  
	  assert((*env)->peer!=-1); 

	  if((*env)->peer!=-1) { (*env)->f_close(env); (*env)->peer=-1; }
	  (*env)->redirect(env);

	  if((*env)->must_share) 
		share_connection(env, JG(redirect_port) TSRMLS_CC);
	  else
		redirect(env, JG(redirect_port), (*env)->pipe.in, (*env)->pipe.out TSRMLS_CC);
	  break;
	case 1: // reopen 
	  assert((*env)->peer!=-1); 
	  if((*env)->peer!=-1) (*env)->f_close(env);
	  server = EXT_GLOBAL(test_server)(&(*env)->peer, 0, 0 TSRMLS_CC);
	  assert(server); if(!server) exit(9);
	  free(server);
	  break;
	}
  }

  if(tail_call) {
	memset(&ctx, 0, sizeof ctx);
	goto handle_request;
  }
  return 1;
}



unsigned char EXT_GLOBAL (get_mode) () {
#ifndef ZEND_ENGINE_2
  // we want arrays as values
  static const unsigned char compat = 2;
#else
#ifdef DISABLE_HEX
# error not available
#else
  static const unsigned char compat = 1;
#endif
#endif
  unsigned short is_level = ((EXT_GLOBAL (ini_user)&U_LOGLEVEL)!=0);
  unsigned short level = 0;
  if (is_level)
	level = EXT_GLOBAL(cfg)->logLevel_val>7?7:EXT_GLOBAL(cfg)->logLevel_val;
  
  return (is_level<<7)|64|(level<<2)|compat;
}

/**
 * Adjust the standard environment for the current request before we
 * connect to the back-end. Used by Fast CGI and Apache so that we can
 * connect back to the current VM.
 * 
 * Checks [HTTP_]XJAVABRIDGE_OVERRIDE_HOSTS_REDIRECT and adjusts JG(hosts).
 * Must be called after clone(cfg).
 */
void EXT_GLOBAL(override_ini_for_redirect)(TSRMLS_D) {
  static const char name[] = "override_ini_for_redirect";
  static const char override[] = "(array_key_exists('HTTP_X_JAVABRIDGE_OVERRIDE_HOSTS_REDIRECT', $_SERVER)?$_SERVER['HTTP_X_JAVABRIDGE_OVERRIDE_HOSTS_REDIRECT']:(array_key_exists('X_JAVABRIDGE_OVERRIDE_HOSTS_REDIRECT', $_SERVER)?$_SERVER['X_JAVABRIDGE_OVERRIDE_HOSTS_REDIRECT']:null));";

  zval val;
  if((SUCCESS==zend_eval_string((char*)override, &val, (char*)name TSRMLS_CC)) && (Z_TYPE(val)==IS_STRING)) {
	/* request servlet -> fast cgi server: connect back to servlet */

	char *tmp, *kontext, *hosts;
	size_t len;
	tmp = Z_STRVAL(val);
	len = Z_STRLEN(val);
	if((tmp[0]=='s' || tmp[0]=='h') && tmp[1]==':') {
	  if(*tmp=='s') 
		JG(ini_user) |= U_SECURE; 
	  else 
		JG(ini_user) &= ~U_SECURE;
	  tmp+=2;
	  len-=2;
	}
	hosts = malloc(len+1);
	strncpy(hosts, tmp, len);
	hosts[len]=0;
	if(JG(hosts)) free(JG(hosts));
	JG(hosts)=hosts;
	kontext = strchr(hosts, '/');
	if(kontext) {
	  *kontext++=0;
	  assert(JG(servlet));
	  free(JG(servlet));
	  JG(servlet) = strdup(kontext);
	  JG(ini_user)|=U_SERVLET;
	  JG(java_socket_inet) = 1;
	}
	JG(ini_user)|=U_HOSTS;
  } else {
	/* request HTTP -> fast cgi or apache module: connect to java_hosts  */

	/* Coerce a http://xyz.com/kontext/foo.php request to the back
	   end: http://xyz.com:{java_hosts[0]}/kontext/foo.php.  For
	   example if we receive a request:
	   http://localhost/sessionSharing.php and java.servlet is On and
	   java.hosts is "127.0.0.1:8080" the code would connect to the
	   back end:
	   http://127.0.0.1:8080/sessionSharing.phpjavabridge. This
	   creates a cookie with PATH value "/".  If java_servlet is User
	   the request http://localhost/myContext/sessionSharing.php the
	   code would connect to
	   http://127.0.0.1/myContext/sessionSharing.phpjavabridge and a
	   cookie with a PATH value "/myContext" would be created.
	*/
	char *kontext = EXT_GLOBAL (get_servlet_context) (TSRMLS_C);
	if(kontext && *kontext!='/') { /* only if context not hardcoded via "On" or "/kontext/foo.php" */
	  static const char bridge_ext[] = "javabridge";
	  static const char default_ext[] = "";
	  static const char default_servlet[] = DEFAULT_SERVLET;
	  static const char name[] = "get_self";
	  static const char override[] = "(array_key_exists('PHP_SELF', $_SERVER) && \n\
array_key_exists('HTTP_HOST', $_SERVER)) ?$_SERVER['PHP_SELF']:null;";
	  const char *bridge_extension = bridge_ext;
	  size_t bridge_extension_size = sizeof(bridge_ext);
	  char *tmp, *strval;
	  size_t len = 0;
	  if((SUCCESS==zend_eval_string((char*)override, &val, (char*)name TSRMLS_CC)) && (Z_TYPE(val)==IS_STRING) && Z_STRLEN(val)) {
		strval = Z_STRVAL(val);
		len = Z_STRLEN(val);
		if(len && *strval!='/') len=0;
	  }
	  if(!len) {
		strval = (char*)default_servlet;
		bridge_extension = default_ext;
		bridge_extension_size = sizeof(default_ext);
		len = sizeof(default_servlet)-1;
	  }
	  assert(JG(servlet));
	  free(JG(servlet));
	  JG(servlet) = tmp = malloc(len+bridge_extension_size);
	  assert(tmp); if(!tmp) exit(9);
	  strcpy(tmp, strval);
	  strcat(tmp, bridge_extension);
	  JG(ini_user)|=U_SERVLET;
	  JG(java_socket_inet) = 1;
	}
  }
}
/**
 * Adjust the standard environment for the current request (used for a
 * servlet backend only).  Sets the servlet_ctx value, which
 * corresponds to the Session/ContextFactory on the server side.
 * 
 * @@param proxyenv The java context.  
 *
 * @@return The adjusted java
 * context.  
 * 
 * @@see php.java.servlet.PhpJavaServlet#getContextFactory(HttpServletRequest,
 * HttpServletResponse)
 */
static proxyenv*adjust_servlet_environment(proxyenv *env, char*servlet_context_string TSRMLS_DC) {
  static const char name[] = "adjust_environment";
  static const char context[] = "(array_key_exists('HTTP_X_JAVABRIDGE_CONTEXT', $_SERVER)?$_SERVER['HTTP_X_JAVABRIDGE_CONTEXT']:(array_key_exists('X_JAVABRIDGE_CONTEXT', $_SERVER)?$_SERVER['X_JAVABRIDGE_CONTEXT']:null));";

  zval val;

  if((SUCCESS==zend_eval_string((char*)context, &val, (char*)name TSRMLS_CC)) && (Z_TYPE(val)==IS_STRING)) {
	(*env)->current_servlet_ctx = strdup(Z_STRVAL(val));
    if(!(*env)->servlet_ctx) (*env)->servlet_ctx = (*env)->current_servlet_ctx;
	if(!JG(servlet_ctx)) JG(servlet_ctx) = (*env)->servlet_ctx;
								/* back-end must have created a session
								   proxy, otherwise we wouldn't see a
								   context. */
	(*env)->backend_has_session_proxy = 1;	
  }
  return env;
}

static char empty[] = "";
static size_t get_context_len(char *context) {
  register char *s = context;
  register size_t len=0;
  if(*s == '/') { s++; len++; }
  for(;*s && *s!='/'; s++) len++;
  return len+1;					/* include terminating \0 or / so that
								   len is always >0 */
}
static proxyenv*recycle_connection(char *context TSRMLS_DC) {
  proxyenv **penv;
  size_t len;
  if(!EXT_GLOBAL(cfg)->persistent_connections) return 0;

  if(!context) context = empty;
  len = get_context_len(context);
  
  if(SUCCESS==zend_hash_find(&JG(connections), context, len, (void**)&penv)){
	proxyenv*env = *penv;
	EXT_GLOBAL(activate_connection)(env TSRMLS_CC);
	(*env)->backend_has_session_proxy = 0;
	if(!(*env)->is_local && context) {
	  env = adjust_servlet_environment(env, context TSRMLS_CC);
	}
	(*env)->must_reopen=2;		/* send a header */
	return env;
  }
  return 0;
}
/**
 * Send the header, if this is a new connection.
 */
static void add_header(proxyenv *env) {
  unsigned char mode = EXT_GLOBAL (get_mode) ();
  (*env)->send_len=2; 
  ((*env)->send)[0]=127;
  ((*env)->send)[1]=mode;
}
static void init_channel(proxyenv *env TSRMLS_DC);
/**
 * Return a procedure which can be used to create an environment.
 */
static environment_factory *getEnvironmentFactory(TSRMLS_D) {
  return (JG(ini_user) & U_SECURE) ? 
	EXT_GLOBAL(createSecureEnvironment) :
	EXT_GLOBAL(createEnvironment);
}
/**
 * Create a new connection to the server or re-use a previous
 * connection.
 */
static proxyenv*create_connection(char *context_string TSRMLS_DC) {
  environment_factory *factory = getEnvironmentFactory(TSRMLS_C);
  char *server, *context;
  int sock;
  proxyenv *jenv;
  short is_local;
  size_t len;
  if(!(context = context_string)) context = empty;
  len = get_context_len(context);

  jenv = 
	(*factory)(handle_request, handle_cached, &is_local);

  if(jenv) {
	if(! (is_local || !context_string)) init_channel(jenv TSRMLS_CC);
	if(EXT_GLOBAL(cfg)->persistent_connections)
	  zend_hash_update(&JG(connections), context, len, &jenv, sizeof(proxyenv *), 0);
	if(is_local || !context_string) {
	  /* "standard" local backend, send the protocol header */
	  add_header(jenv);
	} else {
	  /* create a jenv for a servlet backend, aquire a context then
		 redirect */
	  if(!((*jenv)->servlet_context_string=strdup(context))) exit(9);
	  jenv = adjust_servlet_environment(jenv, context TSRMLS_CC);
	}
  }
  return jenv;
}
static proxyenv *try_connect_to_server(short bail TSRMLS_DC) {
  char *host_string = 0;
  proxyenv *jenv =JG(jenv);
  if(jenv) return jenv;

  EXT_GLOBAL(clone_cfg)(TSRMLS_C);

  if(!EXT_GLOBAL(cfg)->is_cgi_servlet || EXT_GLOBAL(cfg)->is_fcgi_servlet) {
	EXT_GLOBAL(override_ini_for_redirect)(TSRMLS_C);
  }
  host_string = EXT_GLOBAL (get_servlet_context) (TSRMLS_C);

  if(JG(is_closed)) {
	php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Could not connect to server: Session is closed. -- This usually means that you have tried to access the server in your class' __destruct() method.",51);
	EXT_GLOBAL(destroy_cloned_cfg)(TSRMLS_C);
	return 0;
  }
  
  jenv = create_connection(host_string TSRMLS_CC);
  if(!jenv) {
	if (bail) 
	  EXT_GLOBAL(sys_error)("Could not connect to server. Have you started the "/**/EXT_NAME()/**/" back-end (either a servlet engine, an application server, JavaBridge.jar or MonoBridge.exe) and set the "/**/EXT_NAME()/**/".socketname or "/**/EXT_NAME()/**/".hosts option?", 52);
	EXT_GLOBAL(destroy_cloned_cfg)(TSRMLS_C);
	return 0;
  }
  return JG(jenv) = jenv;
}
proxyenv *EXT_GLOBAL(connect_to_server)(TSRMLS_D) {
  return try_connect_to_server(1 TSRMLS_CC);
}
proxyenv *EXT_GLOBAL(try_connect_to_server)(TSRMLS_D) {
  return try_connect_to_server(0 TSRMLS_CC);
}

#ifdef __MINGW32__
/* named pipes are not available on windows */
static void init_channel(proxyenv *env TSRMLS_DC) {
  (*env)->pipe.in = (*env)->pipe.out = (*env)->pipe.channel = 0;
}
void EXT_GLOBAL(unlink_channel)(proxyenv *env) {
}

#else

static const char in[] = ".i";
static const char out[] = ".o";
static short create_pipe(char*sockname) {
  if((mkfifo(sockname, 0) == -1) || chmod(sockname, 0666) == -1) return 0;
  return 1;
}
static short create_pipes(proxyenv*env, char*basename, size_t basename_len) {
  char *e = basename+basename_len;
  short success;
  if(((*env)->pipe.lockfile = mkstemp(basename)) == -1) return 0;
  if(!create_pipe(strcat(basename, in))) {
	*e=0;
	unlink(basename);
	return 0;
  }
  *e=0;
  success = create_pipe(strcat(basename, out));
  assert(success); if(!success) exit(6);
  (*env)->pipe.out = strdup(basename);
  *e=0;
  (*env)->pipe.in = strdup(strcat(basename, in));
  *e=0;
  (*env)->pipe.channel = basename;

  return 1;
}
/* same as init_channel, but doesn't use a tmpdir */
static void init_channel_raw(proxyenv*env TSRMLS_DC) {
  static const char sockname[] = SOCKNAME;
  static const char sockname_shm[] = SOCKNAME_SHM;
  static const size_t length = sizeof(sockname)>sizeof(sockname_shm)?sizeof(sockname):sizeof(sockname_shm);
  char *pipe;

  /* pipe communication channel only available in servlets */
  (*env)->pipe.channel=0;
  if(!EXT_GLOBAL(option_set_by_user) (U_SERVLET, JG(ini_user))) return;

  pipe=malloc(length+2); /* "name.i" */
  assert(pipe); if(!pipe) exit(6);
  
  create_pipes(env, strcpy(pipe,sockname_shm), sizeof(sockname_shm)-1) ||
	create_pipes(env, strcpy(pipe,sockname), sizeof(sockname)-1);

  if(!(*env)->pipe.channel) free(pipe);
}
/* create named pipe channel in tmpdir */
static void init_channel(proxyenv*env TSRMLS_DC) {
  static const char sockname[] = "/php_XXXXXX";
  char *pipe;
  size_t length;
  if(!EXT_GLOBAL(cfg)->tmpdir) { init_channel_raw(env TSRMLS_CC); return; }

  /* pipe communication channel only available in servlets */
  (*env)->pipe.channel=0;
  if(!EXT_GLOBAL(option_set_by_user) (U_SERVLET, JG(ini_user))) return;
  length=strlen(EXT_GLOBAL(cfg)->tmpdir)+sizeof(sockname);
  pipe=malloc(length+2); /* "name.i" */
  assert(pipe); if(!pipe) exit(6);
  
  strcpy(pipe, EXT_GLOBAL(cfg)->tmpdir); strcat(pipe, sockname);
  create_pipes(env, pipe, length-1);
  if(!(*env)->pipe.channel) free(pipe);
}
/**
 * Remove the link to the pipe. Note that this does not destroy
 * the channel, it only removes its name
 */
void EXT_GLOBAL(unlink_channel)(proxyenv*env) {
  char *channel = (*env)->pipe.channel;
  if(!channel || !(*env)->pipe.in) return;

  remove_pipe(env);

  free((*env)->pipe.in); free((*env)->pipe.out);

  (*env)->pipe.in = (*env)->pipe.out = 0;
}
#endif
const char *EXT_GLOBAL(get_channel) (proxyenv*env) {
  static const char empty[] = "";
  char *channel = (*env)->pipe.channel;
  if(channel) return channel;
  return empty;
}
void EXT_GLOBAL(passivate_connection)(proxyenv *env TSRMLS_DC) {
  (*env)->cfg.ini_user=JG(ini_user);
  (*env)->cfg.java_socket_inet=JG(java_socket_inet);
  if((*env)->cfg.hosts) free(((*env)->cfg.hosts));
  if(!((*env)->cfg.hosts=strdup(JG(hosts)))) exit(9);
  if((*env)->cfg.servlet) free(((*env)->cfg.servlet));
  if(!((*env)->cfg.servlet=strdup(JG(servlet)))) exit(9);
}
/* see override_ini_for_redirect */
void EXT_GLOBAL(activate_connection)(proxyenv *env TSRMLS_DC) {
  JG(ini_user)=(*env)->cfg.ini_user;
  JG(java_socket_inet)=(*env)->cfg.java_socket_inet;

  //assert(!JG(hosts));
  if(JG(hosts)) free(JG(hosts)); 
  if(!(JG(hosts)=strdup((*env)->cfg.hosts))) exit(9);

  //assert(!JG(servlet));
  if(JG(servlet)) free(JG(servlet)); 
  if(!(JG(servlet)=strdup((*env)->cfg.servlet))) exit(9);
}

#ifndef PHP_WRAPPER_H
#error must include php_wrapper.h
#endif

#endif
@


1.116
log
@Release-4-3-0
@
text
@@


1.115
log
@Release-4-1-8
@
text
@d43 1
a43 1
#if !defined(ZEND_ENGINE_2) || EXTENSION == MONO
@


1.114
log
@Release-4-1-7
@
text
@d41 4
d987 1
a987 1
  char *servlet_context_string = 0;
d996 2
a997 4
  servlet_context_string = EXT_GLOBAL (get_servlet_context) (TSRMLS_C);
  jenv = recycle_connection(servlet_context_string TSRMLS_CC);
  if(jenv) return JG(jenv) = jenv;
  
d1004 1
a1004 1
  jenv = create_connection(servlet_context_string TSRMLS_CC);
a1113 8
void EXT_GLOBAL(clone_cfg)(TSRMLS_D) {
  JG(ini_user)=EXT_GLOBAL(ini_user);
  JG(java_socket_inet) = EXT_GLOBAL(cfg)->java_socket_inet;
  if(JG(hosts)) free(JG(hosts));
  if(!(JG(hosts)=strdup(EXT_GLOBAL(cfg)->hosts))) exit(9);
  if(JG(servlet)) free(JG(servlet));
  if(!(JG(servlet)=strdup(EXT_GLOBAL(cfg)->servlet))) exit(9);
}
a1134 8
void EXT_GLOBAL(destroy_cloned_cfg)(TSRMLS_D) {
  if(JG(hosts)) free(JG(hosts));
  if(JG(servlet)) free(JG(servlet));
  JG(ini_user)=0;
  JG(java_socket_inet)=0;
  JG(hosts)=0;
  JG(servlet)=0;
}
d1139 2
@


1.113
log
@Release-4-1-0
@
text
@a634 1
	  static const char kontext[]= "X_JAVABRIDGE_CONTEXT_DEFAULT";
d660 1
a660 2
	  } else if(!strcasecmp(str, kontext)) {
		assert(JG(servlet_ctx));
a661 2
		(*ctx)->must_share = 1;
	  }
a1148 5
char *EXT_GLOBAL(getDefaultSessionFactory)(TSRMLS_D) {
  static const char invalid[] = "0";
  register char *context = JG(servlet_ctx);
  return context?context:(char*)invalid;
}
@


1.112
log
@Release-3-0-8
@
text
@d543 3
a545 1
  (*env)->servlet_ctx=JG(servlet_ctx);
d553 1
a553 1
  (*env)->must_reopen=0;		/* do not send a header */
d930 1
a930 1

@


1.111
log
@Files update 3.2.2 to 4.0.1. Extracted from the src.tar.gz downloaded from sf.net, uploaded by Jost Boekemeier. Update to repository by Andre Felipe Machado.
@
text
@d820 1
d869 1
d942 1
a942 1
static void init_channel(proxyenv *env);
d969 1
a969 1
	if(! (is_local || !context_string)) init_channel(jenv);
d1022 1
a1022 1
static void init_channel(proxyenv *env) {
d1057 1
a1057 1
static void init_channel_raw(proxyenv*env) {
d1065 1
a1065 1
  if(!EXT_GLOBAL(option_set_by_user) (U_SERVLET, EXT_GLOBAL(ini_user))) return;
d1076 1
a1076 1
static void init_channel(proxyenv*env) {
d1080 1
a1080 1
  if(!EXT_GLOBAL(cfg)->tmpdir) { init_channel_raw(env); return; }
d1084 1
a1084 1
  if(!EXT_GLOBAL(option_set_by_user) (U_SERVLET, EXT_GLOBAL(ini_user))) return;
d1116 1
d1124 1
d1133 1
d1147 1
@


1.110
log
@Release-3-2-1
@
text
@d5 1
a5 1
  Copyright (C) 2006 Jost Boekemeier
d539 1
a539 2
 * context.  See ContextRunner.recycle() and ABOUT.HTM#global-servlet
 * for details.
@


1.109
log
@Release-3-1-8
@
text
@d534 1
a535 1
  unlink(pipe->in); unlink(pipe->out);
d1098 1
a1098 1
  if(!channel) return;
d1102 1
a1102 1
  free(channel); free((*env)->pipe.in); free((*env)->pipe.out);
d1104 1
a1104 1
  (*env)->pipe.in = (*env)->pipe.out = (*env)->pipe.channel = 0;
@


1.108
log
@Release-3-1-8rc3
@
text
@d260 1
d263 1
d265 1
a266 1
	(*jenv)->writeResultEnd(jenv);
@


1.107
log
@Release-3-1-8rc
@
text
@d935 3
a937 2
  (*env)->send_len=1; 
  *(*env)->send=mode;
@


1.106
log
@Release-3-1-8devel1
@
text
@d246 16
a261 1
	(*jenv)->writeResultBegin(jenv, presult);
d263 1
d295 40
d713 4
a716 1
	close((*env)->peer);
d732 4
a735 1
	  if((*env)->peer!=-1) { close((*env)->peer); (*env)->peer=-1; }
d743 1
a743 1
	  if((*env)->peer!=-1) close((*env)->peer);
d763 1
a763 1
  static const unsigned char compat = 3;
d766 1
a766 1
  static const unsigned char compat = 0;
d795 15
a809 4
	char *kontext, *hosts;
	hosts = malloc(Z_STRLEN(val)+1+100);
	strncpy(hosts, Z_STRVAL(val), Z_STRLEN(val));
	hosts[Z_STRLEN(val)]=0;
d824 6
a829 5
	/* Coerce a http://xyz.com/kontext/foo.php request to the backend:
	   http://xyz.com:{java_hosts[0]}/kontext/foo.php.  For example if
	   we receive a request: http://localhost/sessionSharing.php and
	   java.servlet is On and java.hosts is "127.0.0.1:8080" the code
	   would connect to the backend:
d831 3
a833 3
	   creates a cookie with PATH value "/".  For a request:
	   http://localhost/myContext/sessionSharing.php the code would
	   connect to
d940 8
d952 1
a955 1
  struct sockaddr saddr;
d961 3
a963 5
  if(!(server=EXT_GLOBAL(test_server)(&sock, &is_local, &saddr TSRMLS_CC))) {
	return 0;
  }
  jenv = EXT_GLOBAL(createSecureEnvironment)
	(sock, handle_request, handle_cached, server, is_local, &saddr);
@


1.105
log
@Release-3-2-0devel
@
text
@d3 38
@


1.104
log
@Release-3-1-7
@
text
@d103 1
d110 1
d118 1
a118 1
	if(type=='A' && 
@


1.103
log
@Release-3-1-6
@
text
@d3 2
d11 1
d13 2
d16 1
a29 1
#include "php_java.h"
d674 1
a674 1
  return (is_level<<7)|64|(level<<2)|compat|EXT_GLOBAL(cfg)->extJavaCompatibility;
d883 1
a883 1
	  EXT_GLOBAL(sys_error)("Could not connect to server %s(%s). Have you started the "/**/EXT_NAME()/**/" back-end (either a servlet engine, an application server, JavaBridge.jar or MonoBridge.exe) and set the "/**/EXT_NAME()/**/".socketname or "/**/EXT_NAME()/**/".hosts option?", 52);
@


1.102
log
@Release-3-1-6
@
text
@d948 1
a948 1
  static const char sockname[] = "/php_java_bridgeXXXXXX";
@


1.101
log
@Release-3-1-6
@
text
@d472 6
d896 1
a896 1
void EXT_GLOBAL(destroy_channel)(proxyenv *env) {
d911 1
a911 1
  if(!create_pipe(strcat(basename, in) TSRMLS_CC)) {
d917 1
a917 1
  success = create_pipe(strcat(basename, out) TSRMLS_CC);
d941 2
a942 3
  create_pipes(env, strcpy(pipe,sockname_shm), sizeof(sockname_shm)-1 
			   TSRMLS_CC) ||
	create_pipes(env, strcpy(pipe,sockname), sizeof(sockname)-1 TSRMLS_CC);
d951 1
a951 1
  if(!EXT_GLOBAL(cfg)->tmpdir) { init_channel_raw(env TSRMLS_CC); return; }
d961 1
a961 1
  create_pipes(env, pipe, length-1 TSRMLS_CC);
d964 5
a968 1
void EXT_GLOBAL(destroy_channel)(proxyenv*env) {
@


1.100
log
@Release-3-1-3
@
text
@d16 3
d427 60
d525 1
d549 6
d611 1
a611 1
  } else	 /* Override redirect opens a secondary channel to the
d613 5
a617 12
			  happened in the middle of redirect/reopen handling, i.e.
			  between "begin redirect" above (must_reopen=2) or "begin
			  reopen" (must_reopen=1) and "redirect finish" or "end
			  reopen" (see must_reopen=0 in function end() and
			  protocol_end() in protocol.c).  In other words: handle
			  override redirect _or_ redirect for one packet, but not
			  both. */

  /* re-open a closed HTTP connection */
  if((*env)->must_reopen) {
	char*server;
	if((*env)->must_reopen==2) { // redirect
d620 1
a620 1

d623 6
a628 2
	  EXT_GLOBAL(redirect)(env, JG(redirect_port), JG(channel_in), JG(channel_out) TSRMLS_CC);
	} else {
d634 1
d637 1
d767 1
d805 13
a817 1
static void init_channel(TSRMLS_D);
d834 1
a834 1
	init_channel(TSRMLS_C);
d839 1
a839 2
	  unsigned char mode = EXT_GLOBAL (get_mode) ();
	  (*jenv)->send_len=1; *(*jenv)->send=mode;
d872 1
a872 1
	  EXT_GLOBAL(sys_error)("Could not connect to server. Have you started the "/**/EXT_NAME()/**/" back-end (either a servlet engine, an application server, JavaBridge.jar or MonoBridge.exe) and set the "/**/EXT_NAME()/**/".socketname or "/**/EXT_NAME()/**/".hosts option?",52);
d887 2
a888 2
static void init_channel(TSRMLS_D) {
  JG(channel_in) = JG(channel_out) = JG(channel) = 0;
d890 1
a890 1
void EXT_GLOBAL(destroy_channel)(TSRMLS_D) {
d897 1
a897 1
static short create_pipe(char*sockname TSRMLS_DC) {
d901 1
a901 1
static short create_pipes(char*basename, size_t basename_len TSRMLS_DC) {
d904 1
a904 1
  if((JG(lockfile) = mkstemp(basename)) == -1) return 0;
d913 1
a913 1
  JG(channel_out) = strdup(basename);
d915 1
a915 1
  JG(channel_in) = strdup(strcat(basename, in));
d917 1
a917 1
  JG(channel) = basename;
d921 2
a922 1
static void init_channel(TSRMLS_D) {
d925 1
a925 1
  static const char length = sizeof(sockname)>sizeof(sockname_shm)?sizeof(sockname):sizeof(sockname_shm);
d929 1
a929 1
  JG(channel)=0;
d935 12
a946 2
  create_pipes(strcpy(pipe,sockname_shm), sizeof(sockname_shm)-1 TSRMLS_CC)||
	create_pipes(strcpy(pipe,sockname), sizeof(sockname)-1 TSRMLS_CC);
d948 10
a957 2
  if(!JG(channel)) free(pipe);
  //assert(JG(channel));
d959 3
d963 3
a965 3
void EXT_GLOBAL(destroy_channel)(TSRMLS_D) {
  char *channel = (JG(channel));
  if(!channel) return;
d967 1
a967 8
  close(JG(lockfile)); unlink(channel);
  unlink(JG(channel_in));
  unlink(JG(channel_out));
  
  free(channel);
  free(JG(channel_in));
  free(JG(channel_out));
  JG(channel_in) = JG(channel_out) = (JG(channel)) = 0;
d970 1
a970 1
const char *EXT_GLOBAL(get_channel) (TSRMLS_D) {
d972 1
a972 1
  char *channel = JG(channel);
d1009 5
@


1.99
log
@Release-3-1-2
@
text
@d668 1
a668 1
	  JG(servlet) = tmp = malloc(len+bridge_extension_size+100);
@


1.98
log
@Release-3-1-0
@
text
@d162 3
a164 1
  int retval;
d173 7
a179 6
  JG(object)=object;
  JG(func)=func;
  JG(retval_ptr)=retval_ptr;
  JG(func_params)=func_params;

  JG(exception)=0;
d190 3
a192 1
  if(JG(exception)&&Z_TYPE_P(JG(exception))!=IS_NULL) {
d196 1
a196 1
	EXT_GLOBAL(get_jobject_from_object)(JG(exception), &result TSRMLS_CC);
d201 1
a201 1
	zval_ptr_dtor(&JG(exception));
d220 5
a226 2
  if(!handle_exception(presult TSRMLS_CC)) 
	EXT_GLOBAL(result)(retval_ptr, 0, presult TSRMLS_CC);
d492 1
a492 1
static void handle_cached(proxyenv *env) {
d495 1
d499 2
a500 1
static void handle_request(proxyenv *env) {
d510 2
a511 1
	EXT_GLOBAL (parse_header) (env, &cb_header);
d514 2
a515 1
  EXT_GLOBAL (parse) (env, &cb);
d517 1
a517 1
  if(SUCCESS==zend_stack_top(&ctx.containers, (void**)&stack_elem))	{ 
d573 1
@


1.97
log
@Release-3-1-0
@
text
@d10 1
d36 6
d50 1
d55 9
a63 1

d270 1
a270 1
#define GET_RESULT(pos) if(!ctx->id) {ctx->id=(zval*)strtol((const char*)PARSER_GET_STRING(st, pos), 0, 10);}
d305 2
a306 2
		  strtol((const char*)PARSER_GET_STRING(st, 0), 0, 10), /* v */
		  strtol((const char*)PARSER_GET_STRING(st, 3), 0, 10), /* n */
d328 1
a328 1
		  ctx->id=hashIndexUpdate(stack_elem->container, strtol((const char*)PARSER_GET_STRING(st, 1), 0, 10));
d345 7
d354 1
a354 1
	setResultFromLong(ctx->id, strtol((const char*)PARSER_GET_STRING(st, 0), 0, 10));
d356 1
d371 1
a371 1
	setResultFromObject(ctx->id, (*cb->env)->async_ctx.nextValue=strtol((const char*)PARSER_GET_STRING(st, 0), 0, 10), *PARSER_GET_STRING(st, 1));
d378 1
a378 1
	  long obj = strtol((const char*)PARSER_GET_STRING(st, 0), 0, 10);
d385 3
d389 2
a393 3
		php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Protocol violation at pos %d, please check that the backend (JavaBride.war) is deployed or please switch off the java.servlet option.\n", 88, (*cb->env)->c);
#else
		php_error(E_ERROR, "%*s\nphp_mod_"/**/EXT_NAME()/**/"(%d): Protocol violation at pos %d, please check that the backend (JavaBride.war) is deployed or please switch off the java.servlet option.\n", (*cb->env)->pos, (*cb->env)->recv_buf, 88, (*cb->env)->c);
d395 5
d428 1
a428 1
	  if(strcmp(str, setcookie)) return;
d444 1
a444 1
	  if(!strcmp(str, con_connection)&&!strcmp((char*)PARSER_GET_STRING(tag[1].strings, 0), con_close)) {
d454 1
a454 1
	  if(!(*ctx)->peer_redirected && !strcmp(str, redirect)) {
d474 1
a474 1
	  } else if((!(*ctx)->servlet_ctx)&&(!strcmp(str, context))) {
d570 1
d572 3
d586 5
a590 1
 * connect to the backend. Used by Fast CGI.
d592 1
a592 1
static void override_ini_for_redirect(TSRMLS_D) {
d601 1
a601 1
	hosts = malloc(Z_STRLEN(val)+1);
d639 1
d650 1
d655 1
a655 1
	  JG(servlet) = tmp = malloc(len+sizeof(bridge_extension));
a701 1
static void override_ini_from_stored_cfg(proxyenv *env TSRMLS_DC);
d712 1
a712 1
	override_ini_from_stored_cfg(env TSRMLS_CC);
d723 2
a724 2
static proxyenv*create_connection(char *context TSRMLS_DC) {
  char *server;
d730 1
a730 1
  if(!context) context = empty;
d742 1
a742 1
	if(is_local || !context) {
d763 1
a763 1
	override_ini_for_redirect(TSRMLS_C);
d778 1
a778 1
	  EXT_GLOBAL(sys_error)("Could not connect to server. Have you started the "/**/EXT_NAME()/**/" backend (either a servlet engine, an application server, JavaBridge.jar or MonoBridge.exe) and set the "/**/EXT_NAME()/**/".socketname or "/**/EXT_NAME()/**/".hosts option?",52);
d869 1
d871 1
d874 1
a874 1
void EXT_GLOBAL(save_cfg)(proxyenv *env TSRMLS_DC) {
d876 1
d878 1
d882 1
a882 1
static void override_ini_from_stored_cfg(proxyenv *env TSRMLS_DC) {
d885 2
a886 2
  if(JG(hosts)) 
	free(JG(hosts)); 
d889 3
a891 3
  if(JG(servlet)) 
	free(JG(servlet)); 
  if(!(JG(servlet)=strdup(EXT_GLOBAL(cfg)->servlet))) exit(9);
@


1.96
log
@Release-3-1-0
@
text
@d365 3
a368 1
		php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Protocol violation at pos %d, please check that the backend (JavaBride.war) is deployed or please switch off the java.servlet option.\n", 88, (*cb->env)->c);
@


1.95
log
@Release-3-1-0
@
text
@a638 3
  if(!((*env)->servlet_context_string=strdup(servlet_context_string))) 
	exit(9);

d640 2
a641 1
	(*env)->servlet_ctx = strdup(Z_STRVAL(val));
d672 4
d707 1
@


1.94
log
@Release-3-1-0
@
text
@d349 1
d658 2
a659 1
  return len;
@


1.93
log
@Release-3-1-0
@
text
@a61 1
  pval *handle;
a74 1
  pval *handle;
d612 1
a612 1
	  assert(tmp); if(!tmp) exit(6);
d632 1
a632 1
static proxyenv*adjust_servlet_environment(proxyenv *env TSRMLS_DC) {
a636 1
  char *servlet_context_string = EXT_GLOBAL (get_servlet_context) (TSRMLS_C);
d638 3
a640 2
  if(servlet_context_string)
	(*env)->servlet_context_string = strdup(servlet_context_string);
d651 25
d677 1
a677 1
static proxyenv *try_connect_to_server(short bail TSRMLS_DC) {
d680 2
d683 27
a709 1
  struct sockaddr saddr;
d715 1
a715 1
  if(!EXT_GLOBAL(cfg)->is_cgi_servlet || EXT_GLOBAL(cfg)->is_fcgi_servlet) 
d717 5
a721 1

d727 3
a729 1
  if(!(server=EXT_GLOBAL(test_server)(&sock, &is_local, &saddr TSRMLS_CC))) {
a734 15

  init_channel(TSRMLS_C);

  jenv = EXT_GLOBAL(createSecureEnvironment)
	(sock, handle_request, handle_cached, server, is_local, &saddr);
  
  if(is_local || !EXT_GLOBAL (get_servlet_context) (TSRMLS_C)) {
	/* "standard" local backend, send the protocol header */
	unsigned char mode = EXT_GLOBAL (get_mode) ();
	(*jenv)->send_len=1; *(*jenv)->send=mode;
  } else {
	/* create a jenv for a servlet backend, aquire a context then
	   redirect */
	jenv = adjust_servlet_environment(jenv TSRMLS_CC);
  }
a740 1
  
d777 2
d822 19
a840 2
  JG(hosts)=strdup(EXT_GLOBAL(cfg)->hosts);
  JG(servlet)=strdup(EXT_GLOBAL(cfg)->servlet);
@


1.92
log
@Release-3-1-0
@
text
@d514 2
a515 1
	  assert((*env)->peer!=-1); if((*env)->peer!=-1) close((*env)->peer);
d518 2
a519 1
	  assert((*env)->peer!=-1); if((*env)->peer!=-1) close((*env)->peer);
d531 2
d645 1
a645 1
								/* backend must have created a session
d652 2
d662 2
d669 1
d675 1
d679 2
d705 1
a705 1
void EXT_GLOBAL(init_channel)(TSRMLS_D) {
d737 1
a737 1
void EXT_GLOBAL(init_channel)(TSRMLS_D) {
d777 12
@


1.91
log
@Release-3.0.8
@
text
@d675 1
a675 1
	send(sock, &mode, sizeof mode, 0); 
@


1.90
log
@Release-3.0.8rc
@
text
@d3 1
a3 1
/* execve */
d6 1
d589 1
d594 1
d604 1
d609 1
a609 1
	  JG(servlet) = tmp = malloc(len+sizeof(bridge_ext));
d612 1
a612 1
	  strcat(tmp, bridge_ext);
d704 1
a704 1
  if((mknod(sockname, S_IFIFO, 0) == -1) || chmod(sockname, 0666) == -1) return 0;
@


1.90.2.1
log
@Release-3-0-8-1
@
text
@d3 1
a3 1
/* execve, mkfifo */
a5 1
#include <sys/stat.h>
a587 1
	  static const char default_ext[] = "";
a591 1
	  const char *bridge_extension = bridge_ext;
a600 1
		bridge_extension = default_ext;
d605 1
a605 1
	  JG(servlet) = tmp = malloc(len+sizeof(bridge_extension));
d608 1
a608 1
	  strcat(tmp, bridge_extension);
d700 1
a700 1
  if((mkfifo(sockname, 0) == -1) || chmod(sockname, 0666) == -1) return 0;
@


1.90.2.2
log
@Release-3-0-8-1
@
text
@a723 1
  return 1;
@


1.90.2.3
log
@Release-3-0-8-1
@
text
@d366 1
a367 3
#else
		php_error(E_ERROR, "%*s\nphp_mod_"/**/EXT_NAME()/**/"(%d): Protocol violation at pos %d, please check that the backend (JavaBride.war) is deployed or please switch off the java.servlet option.\n", (*cb->env)->pos, (*cb->env)->recv_buf, 88, (*cb->env)->c);
#endif
d675 1
a675 1
	(*jenv)->send_len=1; *(*jenv)->send=mode;
@


1.89
log
@Release-3.0.8test1
@
text
@d363 1
d365 1
@


1.88
log
@Release-3.0.8test1
@
text
@d439 3
a441 5
	  } else if(!strcmp(str, context)) {
		if(!(*ctx)->servlet_ctx) {
		  key = (char*)PARSER_GET_STRING(tag[1].strings, 0);
		  (*ctx)->servlet_ctx = strdup(key);
		}
@


1.87
log
@Release-3.0.8pre2
@
text
@d177 4
a180 8
	if(!result)
	  php_error(E_WARNING, "Exception is not a JavaException object.");
	else {
	  has_exception=1;
	  (*jenv)->writeResultBegin(jenv, presult);
	  (*jenv)->writeException(jenv, result, "php exception.", 0);
	  (*jenv)->writeResultEnd(jenv);
	}
d194 1
a194 1
  
d201 1
@


1.86
log
@Release-3.0.8pre2
@
text
@d422 1
a422 1
	  if(!strcmp(str, redirect)) {
d491 1
d497 1
d499 9
a507 1
  }
@


1.85
log
@Release-3.0.8pre
@
text
@d292 1
d351 1
a351 1
	setResultFromObject(ctx->id, strtol((const char*)PARSER_GET_STRING(st, 0), 0, 10), *PARSER_GET_STRING(st, 1));
d359 1
a359 1
	  setException(ctx->id, obj, stringRepresentation, len);
d453 7
d659 1
a659 1
	(sock, handle_request, server, is_local, &saddr);
@


1.84
log
@Release-3.0.7
@
text
@d563 2
a564 2
	   http://127.0.0.1:8080/sessionSharing.php. This creates a cookie
	   with PATH value "/".  For a request:
d566 2
a567 1
	   connect to http://127.0.0.1/myContext/sessionSharing.php and a
d572 1
d590 1
a590 1
	  JG(servlet) = tmp = malloc(len+1);
d593 1
@


1.83
log
@Release-3.0.7
@
text
@d643 1
a643 1
	  EXT_GLOBAL(sys_error)("Could not connect to server. Have you started the "/**/EXT_NAME()/**/" backend (either a servlet engine, an application server, JavaBridge.jar or MonoBridge.exe) and set the "/**/EXT_NAME()/**/".socketname or "/**/EXT_NAME()/**/".hosts option? If you want use the HTTP tunnel, set java.servlet=On (in php.ini) and set allow_http_tunnel to On (in the web.xml).",52);
@


1.82
log
@Release-3.0.6
@
text
@d73 1
a73 1
static void setResultFromObject (pval *presult, long value, char type, long class_id) {
d102 1
a102 1
static void setResultFromObject (pval *presult, long value, char type, long class_id) {
d345 1
a345 1
	GET_RESULT(3);
d348 1
a348 2
		   (((*tag[1].strings[2].string)[tag[1].strings[2].off])=='n')&&
		   (((*tag[1].strings[3].string)[tag[1].strings[3].off])=='i'));
d350 1
a350 1
	setResultFromObject(ctx->id, strtol((const char*)PARSER_GET_STRING(st, 0), 0, 10), *PARSER_GET_STRING(st, 1), 0l);
d634 1
a634 1
  if(!EXT_GLOBAL(cfg)->is_cgi_servlet) 
@


1.81
log
@Release-3.0.5
@
text
@d346 5
d362 7
a368 3
  default:
	assert(((*cb->env)->c) < RECV_SIZE);
	php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Protocol violation, please check that the backend (JavaBride.war) is deployed or please switch off the java.servlet option. Dump of the recv_buf follows:\n%*s", 88, (int)(0xFFFF&(*cb->env)->c), (*cb->env)->recv_buf);
a529 22
 * Adjust the standard environment for the current request.  Sets the
 * servlet_ctx value, which corresponds to the Session/ContextFactory
 * on the server side.
 * @@param proxyenv The java context.
 * @@return The adjusted java context.
 * @@see php.java.servlet.PhpJavaServlet#getContextFactory(HttpServletRequest, HttpServletResponse)
 */
static proxyenv* adjust_environment(proxyenv *env TSRMLS_DC) {
  static const char name[] = "adjust_environment";
  static const char context[] = "(array_key_exists('HTTP_X_JAVABRIDGE_CONTEXT', $_SERVER)?$_SERVER['HTTP_X_JAVABRIDGE_CONTEXT']:(array_key_exists('X_JAVABRIDGE_CONTEXT', $_SERVER)?$_SERVER['X_JAVABRIDGE_CONTEXT']:null));";

  zval val;
  char *servlet_context_string = EXT_GLOBAL (get_servlet_context) (TSRMLS_C);

  if(servlet_context_string) (*env)->servlet_context_string = strdup(servlet_context_string);
  if((SUCCESS==zend_eval_string((char*)context, &val, (char*)name TSRMLS_CC)) && (Z_TYPE(val)==IS_STRING)) {
	(*env)->servlet_ctx = strdup(Z_STRVAL(val));
  }
  return env;
}

/**
d596 31
d644 1
a644 1
	  EXT_GLOBAL(sys_error)("Could not connect to server. Have you started the "/**/EXT_NAME()/**/" backend (either a servlet engine, an application server, JavaBridge.jar or MonoBridge.exe) and set the "/**/EXT_NAME()/**/".socketname or "/**/EXT_NAME()/**/".hosts option?",52);
d648 3
d652 1
d655 4
d660 1
a660 2

  return JG(jenv) = adjust_environment(EXT_GLOBAL(createSecureEnvironment)(sock, handle_request, server, is_local, &saddr) TSRMLS_CC);
d689 1
a689 1
  if(mkstemp(basename) == -1) return 0;
d728 1
a728 1
  unlink(channel);
@


1.80
log
@Release-3.0.5(pre)
@
text
@a71 1
#endif
d73 1
a73 1
static  void  setResultFromObject  (pval *presult, long value, char type, long class_id) {
d99 14
a112 1
#ifndef ZEND_ENGINE_2
d119 1
a119 2
#else
  EXT_GLOBAL(store_jobject)(presult, value TSRMLS_CC);
d121 1
a121 1
}
d517 1
a517 1
  return (is_level<<7)|64|(level<<2)|compat;
@


1.79
log
@Release-3.0.4
@
text
@d64 1
d74 1
a74 1
static  void  setResultFromObject  (pval *presult, long value) {
d80 10
a89 1
	object_init_ex(presult, EXT_GLOBAL(class_entry));
d91 7
a97 1
    presult->refcount=1;
d329 4
d334 2
a335 6
	GET_RESULT(1);
	if(!st[0].length) {
	  ZVAL_NULL(ctx->id);
	} else {
	  setResultFromObject(ctx->id, strtol((const char*)PARSER_GET_STRING(st, 0), 0, 10));
	}
@


1.78
log
@Release-3.0.4
@
text
@d638 1
a638 1
  if(!create_pipe(strcat(basename, in TSRMLS_CC))) {
d640 1
d644 1
a644 1
  success = create_pipe(strcat(basename, out));
d659 1
a664 1
  JG(channel)=0;
d667 3
a669 2
  assert(JG(channel));
  if(!(JG(channel))) exit(6);
@


1.77
log
@Release-3.0.3
@
text
@d560 1
a560 1
	  static const char override[] = "(array_key_exists('PHP_SELF', $_SERVER) \n\
@


1.76
log
@Release-3.0.3
@
text
@d464 1
a464 1
	  EXT_GLOBAL(redirect)(env, JG(redirect_port) TSRMLS_CC);
d557 1
a557 1
	if(kontext && *kontext!='/') {
d560 2
a561 1
	  static const char override[] = "array_key_exists('PHP_SELF', $_SERVER)?$_SERVER['PHP_SELF']:null;";
d618 73
@


1.75
log
@Release-3-0-2
@
text
@d398 1
d452 1
d464 1
a464 3
	  server = EXT_GLOBAL(test_server)(&(*env)->peer, 0, 0 TSRMLS_CC);
	  assert(server); if(!server) exit(9);
	  free(server);
d525 2
d543 2
@


1.74
log
@Release-3-0-2
@
text
@d534 2
a535 1
	  if(JG(servlet)) free(JG(servlet));
d553 2
a554 1
	if(kontext) {
d557 2
d560 7
a566 7
		if(JG(servlet)) free(JG(servlet));

		JG(servlet) = malloc(Z_STRLEN(val)+1);
		strncpy(JG(servlet), Z_STRVAL(val), Z_STRLEN(val)); 
		JG(servlet)[Z_STRLEN(val)]=0;

		JG(ini_user)|=U_SERVLET;
d568 6
@


1.73
log
@Release-3.0.0pre1
@
text
@d69 1
a69 7

  ALLOC_ZVAL(handle);
  Z_TYPE_P(handle) = IS_LONG;
  Z_LVAL_P(handle) = value;
  pval_copy_constructor(handle);
  INIT_PZVAL(handle);
  zend_hash_index_update(Z_OBJPROP_P(presult), 0, &handle, sizeof(pval *), NULL);
d84 1
d91 3
a93 1

d140 1
a140 1
 * Check for exception and communication the exception back to the
d392 1
a392 1
		char *server_name = emalloc(len+1+key_len+1);
d401 1
a401 1
		if(JG(hosts)) efree(JG(hosts));
d481 1
a481 1
  static const unsigned char arraysAsValues = 2;
d483 1
a483 1
  static const unsigned char arraysAsValues = 0;
d490 1
a490 1
  return (is_level<<7)|64|(level<<2)|arraysAsValues;
d493 7
a499 2
/*
 * adjust the standard environment for the current request.
d503 1
a503 1
  static const char context[] = "(array_key_exists('X_JAVABRIDGE_CONTEXT', $_SERVER)?$_SERVER['X_JAVABRIDGE_CONTEXT']:null);";
a508 1

d515 4
d521 1
a521 1
  static const char override[] = "(array_key_exists('X_JAVABRIDGE_OVERRIDE_HOSTS_REDIRECT', $_SERVER)?$_SERVER['X_JAVABRIDGE_OVERRIDE_HOSTS_REDIRECT']:null);";
d525 5
a529 2
	char *kontext, *hosts = estrndup(Z_STRVAL(val), Z_STRLEN(val));
	if(JG(hosts)) efree(JG(hosts));
d534 2
a535 2
	  if(JG(servlet)) efree(JG(servlet));
	  JG(servlet) = estrdup(kontext);
d539 26
@


1.72
log
@Version-3.0.0pre
@
text
@d501 1
a501 5
  static const char context[] = "\
array_key_exists('X_JAVABRIDGE_CONTEXT', $_SERVER)\
?$_SERVER['X_JAVABRIDGE_CONTEXT']\
:(array_key_exists('HTTP_X_JAVABRIDGE_CONTEXT', $_SERVER)?$_SERVER['HTTP_X_JAVABRIDGE_CONTEXT']:null);\
";
d516 2
a517 4
  static const char override[] = "\
array_key_exists('X_JAVABRIDGE_OVERRIDE_HOSTS', $_SERVER)	\
?$_SERVER['X_JAVABRIDGE_OVERRIDE_HOSTS']								\
:(array_key_exists('HTTP_X_JAVABRIDGE_OVERRIDE_HOSTS', $_SERVER)?$_SERVER['HTTP_X_JAVABRIDGE_OVERRIDE_HOSTS']:null);";
@


1.71
log
@Version-3.0(pre)
@
text
@d334 2
a335 1
	php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Protocol violation, please check that the backend (JavaBride.war) is deployed or please switch off the java.servlet option", 88);
d355 1
a355 1
  proxyenv *ctx=(proxyenv*)cb->ctx;
d422 1
a422 1
  parser_cb_t cb = {begin, end, &ctx};
d428 1
a428 1
	parser_cb_t cb_header = {begin_header, 0, env};
d526 1
d528 8
a535 1
	JG(hosts)=estrndup(Z_STRVAL(val), Z_STRLEN(val));
@


1.70
log
@Version 2.0.8RC4 fixes PR1291191, PR 1291175 and PR1286643
@
text
@d450 1
a450 1
  if((*env)->peer0) {
d453 1
a453 1
	(*env)->peer0 = 0;
d463 1
a463 1
	  assert((*env)->peer); if((*env)->peer) close((*env)->peer);
d468 1
a468 1
	  assert((*env)->peer); if((*env)->peer) close((*env)->peer);
d499 1
d511 1
a511 1
  if((SUCCESS==zend_eval_string((char*)context, &val, "context" TSRMLS_CC)) && (Z_TYPE(val)==IS_STRING)) {
d516 14
d537 4
@


1.69
log
@2.0.8RC2 fixes PR1283148 and 1281189.
@
text
@d251 1
d334 1
a334 1
	assert(0);
@


1.68
log
@2.0.8RC1 fixes PR1276889, 1275899, 1274526, 1202896
@
text
@d527 1
a527 1
	  php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Could not connect to server: %s -- Have you started the "/**/EXT_NAME()/**/" backend (either a servlet engine, an application server, JavaBridge.jar or MonoBridge.exe) and set the "/**/EXT_NAME()/**/".socketname option?",52, strerror(errno));
@


1.67
log
@Release-2.0.8(pre4)
@
text
@d28 1
a170 1
  short has_exception=0;
a171 5
  char *name;
  zend_class_entry *ce = 0;
  int key_type;
  char *string_key;
  ulong num_key;
d214 1
a214 1
  zend_hash_update(Z_ARRVAL_P(handle), key, len+1, &result, sizeof(zval *), NULL);
d313 1
a313 1
	setResultFromDouble(ctx->id, zend_string_to_double((const char*)PARSER_GET_STRING(st, 0), st[0].length));
d367 2
a368 2
		if(path=strchr(path, '=')) path++;
		if(end=strchr(path, ';')) *end=0;
a458 2
	  static const char key_sockname[] = "java.socketname";
	  static const char key_off[] = "Off";
a502 4
  static const char override[] = "\
array_key_exists('X_JAVABRIDGE_OVERRIDE_HOSTS', $_SERVER)\
?$_SERVER['X_JAVABRIDGE_OVERRIDE_HOSTS']\
:(array_key_exists('HTTP_X_JAVABRIDGE_OVERRIDE_HOSTS', $_SERVER)?$_SERVER['HTTP_X_JAVABRIDGE_OVERRIDE_HOSTS']:null);";
a503 1
  static const char key_on[] = "1";
d527 1
a527 1
	  php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Could not connect to server: %s -- Have you started the "/**/EXT_NAME()/**/" bridge and set the "/**/EXT_NAME()/**/".socketname option?",52, strerror(errno));
@


1.66
log
@compiles under freebsd
@
text
@a523 7
  if((SUCCESS==zend_eval_string((char*)override, &val, "override" TSRMLS_CC)) && (Z_TYPE(val)==IS_STRING)) {
	if(JG(hosts)) efree(JG(hosts));     
	JG(hosts)=estrdup(Z_STRVAL(val));

	if(JG(servlet)) free(JG(servlet)); 
	JG(servlet)=strdup(key_on);
  }
@


1.65
log
@Release-2.0.8(pre4)
@
text
@d265 1
d277 1
a277 1

@


1.64
log
@Release-2.0.8(pre3)
@
text
@a255 1
  
d359 1
a359 1

d397 1
a397 1
		char *server_name = malloc(len+1+key_len+1);
d405 4
a408 3
		zend_alter_ini_entry((char*)key_hosts, sizeof key_hosts, 
							 server_name, len+1+key_len,
							 ZEND_INI_SYSTEM, PHP_INI_STAGE_RUNTIME);
a409 1
		free(server_name);
d427 1
a432 1

a451 1

d466 1
a466 6
	  zend_alter_ini_entry((char*)key_servlet, sizeof key_servlet, 
						   (char*)key_off, sizeof key_off, 
						   ZEND_INI_SYSTEM, PHP_INI_STAGE_RUNTIME);
	  zend_alter_ini_entry((char*)key_sockname, sizeof key_sockname, 
						   (char*)key_off, sizeof key_off, 
						   ZEND_INI_SYSTEM, PHP_INI_STAGE_RUNTIME);
d469 1
a469 1
	  server = EXT_GLOBAL(test_server)(&(*env)->peer, 0, 0);
d474 1
a474 1
	  server = EXT_GLOBAL(test_server)(&(*env)->peer, 0, 0);
a478 1

d514 1
a514 1
  static const char key_on[] = "On";
d516 1
a516 1
  char *servlet_context_string = EXT_GLOBAL (get_servlet_context) ();
d524 5
a528 7
	zend_alter_ini_entry((char*)key_hosts, sizeof key_hosts, 
						 Z_STRVAL(val), Z_STRLEN(val), 
						 ZEND_INI_SYSTEM, PHP_INI_STAGE_RUNTIME);
	zend_alter_ini_entry((char*)key_servlet, sizeof key_servlet, 
						 (char*)key_on, sizeof key_on, 
						 ZEND_INI_SYSTEM, PHP_INI_STAGE_RUNTIME);
	
a538 1

d543 1
a543 1
  if(!(server=EXT_GLOBAL(test_server)(&sock, &is_local, &saddr))) {
d549 1
a549 1
  if(is_local || !EXT_GLOBAL (get_servlet_context) ()) {
@


1.63
log
@Release-2.0.8-pre3
@
text
@a24 1
#include "SAPI.h"
a353 21
static void set_cookie(char*key, size_t key_len, char*val, size_t val_len) {
  static const char prefix[] = "Set-Cookie: ";
  static const char eq[] = "=";
  sapi_header_line ctr = {0};
  size_t len = sizeof(prefix)+key_len+sizeof(eq)-1+val_len;
  char *pos, *cookie = malloc(len);
  
  TSRMLS_FETCH();

  assert(cookie); if(!cookie) exit(6);
  pos = cookie;
  memcpy(pos, prefix, sizeof(prefix)-1); pos+=sizeof(prefix)-1;
  memcpy(pos, key, key_len); pos+=key_len;
  memcpy(pos, eq, sizeof(eq)-1); pos+=sizeof(eq)-1;
  memcpy(pos, val, val_len); pos+=val_len;
  *pos=0;
  ctr.line=cookie;
  ctr.line_len=len-1;
  sapi_header_op(SAPI_HEADER_ADD, &ctr TSRMLS_CC);
  free(cookie);
}
d369 7
a375 3
	  // if((path=strchr(cookie, ';'))) *path=0;	/* strip off path */
	  set_cookie(cookie_name, tag[1].strings[0].length, 
				 cookie, tag[2].strings[0].length);
d383 1
a383 1
		(*ctx)->must_reopen = 1;
a458 1
	(*env)->must_reopen = 0;
a478 1
	  EXT_GLOBAL(send_context)(env);
a484 1
	(*env)->must_reopen = 0;
d512 10
a521 2
  static const char context[] = "$_SERVER['X_JAVABRIDGE_CONTEXT']?$_SERVER['X_JAVABRIDGE_CONTEXT']:$_SERVER['HTTP_X_JAVABRIDGE_CONTEXT'];";
  static const char override[] = "$_SERVER['X_JAVABRIDGE_OVERRIDE_HOSTS'];";
@


1.62
log
@Release-2.0.8-pre2
@
text
@d25 1
d141 1
a145 1

d355 21
d384 13
d411 13
a423 1
		key = (char*)PARSER_GET_STRING(tag[1].strings, 0);
d425 1
a425 1
							 key, tag[1].strings[0].length+1, 
d428 1
d447 1
a447 1
  if(!(*env)->is_local && EXT_GLOBAL (get_servlet_context) ()) {
d472 8
a482 6

	assert((*env)->peer); if((*env)->peer) close((*env)->peer);
	server = EXT_GLOBAL(test_server)(&(*env)->peer, 0);
	assert(server); if(!server) exit(9);
	free(server);

d486 1
d493 5
d499 5
a504 1

d533 1
a533 1
  static const char context[] = "$_SERVER['X_JAVABRIDGE_CONTEXT'];";
d537 4
d559 1
d567 1
a567 1
  if(!(server=EXT_GLOBAL(test_server)(&sock, &is_local))) {
d578 1
a578 1
  return JG(jenv) = adjust_environment(EXT_GLOBAL(createSecureEnvironment)(sock, handle_request, server, is_local) TSRMLS_CC);
@


1.61
log
@Release-2.0.8-preview
@
text
@a73 3
#ifndef ZEND_ENGINE_2
  zval_add_ref(&handle); // FIXME, this should be unnecessary
#endif
a93 3
#ifndef ZEND_ENGINE_2
  zval_add_ref(&handle); // FIXME, this should be unnecessary
#endif
d200 1
a200 2
  zval_add_ref(&handle);
  ALLOC_ZVAL(result);
a201 1
  zval_add_ref(&result);
d208 1
a208 2
  zval_add_ref(&handle);
  ALLOC_ZVAL(result);
a209 1
  zval_add_ref(&result);
d216 1
a216 3
  pval pkey;
  zval_add_ref(&handle);
  ALLOC_ZVAL(result);
a217 1
  setResultFromString(&pkey, key, len);
d219 1
a219 2
  zval_add_ref(&result);
  zend_hash_update(Z_ARRVAL_P(handle), Z_STRVAL(pkey), Z_STRLEN(pkey)+1, &result, sizeof(zval *), NULL);
d414 1
@


1.60
log
@Release-2.0.8(pre)
@
text
@d104 71
a174 1
static void setResultFromApply(zval *presult, unsigned char *cname, size_t clen, unsigned char*fname, size_t flen, zval *object, zval *params)
d176 2
a177 2
  zval ***func_params, *func, *retval_ptr;
  HashTable *func_params_ht;
a178 2
  int count;
  int current = 0;
d189 1
a189 11
  func_params_ht = Z_ARRVAL_P(params);
  count = zend_hash_num_elements(func_params_ht);
  func_params = safe_emalloc(sizeof(zval **), count, 0);
  for (zend_hash_internal_pointer_reset(func_params_ht);
	   zend_hash_get_current_data(func_params_ht, (void **) &func_params[current]) == SUCCESS;
	   zend_hash_move_forward(func_params_ht)
	   ) {
	current++;
  }

  if (call_user_function_ex(object?0:EG(function_table), &object, func, &retval_ptr, count, func_params, 0, NULL TSRMLS_CC) != SUCCESS) {
d192 5
a196 10
#ifdef ZEND_ENGINE_2
  if(EG(exception)) {
	php_error(E_WARNING, "php_mod_"/**/EXT_NAME()/**/"(%d): Unhandled exception during callback in user function: %s.", 25, fname);
	zend_clear_exception(TSRMLS_C);
  }
#endif

  EXT_GLOBAL(result)(retval_ptr, 0, presult TSRMLS_CC);
  if(retval_ptr) zval_ptr_dtor(&retval_ptr);
  efree(func_params);
d369 2
a370 1
static const char context[] = "X_JAVABRIDGE_CONTEXT";
a375 14
  case 'S'://Set-Cookie:
	{
	  char *cookie, *path;
	  static const char setcookie[]="Set-Cookie";
	  if(strcmp(str, setcookie) || ((*ctx)->cookie_name)) return;
	  (*ctx)->cookie_name = strdup((char*)PARSER_GET_STRING(tag[1].strings, 0));
	  cookie = (char*)PARSER_GET_STRING(tag[2].strings, 0);
	  if((path=strchr(cookie, ';'))) *path=0;	/* strip off path */
	  (*ctx)->cookie_value = strdup(cookie);
	  assert((*ctx)->cookie_name && (*ctx)->cookie_value);
	  if(!(*ctx)->cookie_name || !(*ctx)->cookie_value) exit(6);
	  break;
	}

d387 2
a388 2
	  static const char redirect[]="X_JAVABRIDGE_REDIRECT";
	  static const char key_hosts[]="java.hosts";
d396 1
a396 1
		if(!(*ctx)->servlet_redirect) {
d398 1
a398 1
		  (*ctx)->servlet_redirect = strdup(key);
a448 1
	  static const char key_servlet[] = "java.servlet";
d486 16
a501 16
  static const char server[] = "_SERVER";
  zval **data, **entry;

/*   if (ht && zend_hash_find(&EG(symbol_table), (char*)server, sizeof server, (void **) &data)!=FAILURE */
/* 	  && (Z_TYPE_PP(data)==IS_ARRAY)) { */
/* 	/\* If we got a X_JAVABRIDGE_CONTEXT, modify the */
/* 	   environment *\/ */
/* 	if (zend_hash_find(Z_ARRVAL_PP(data), (char*)context, sizeof context, (void **) &entry)!=FAILURE */
/* 		&& (Z_TYPE_PP(entry)==IS_STRING)) { */
/* 	  (*env)->servlet_redirect = strdup(Z_STRVAL_PP(entry)); */
/* 	} */
/*   } */

  char *ctx = getenv(context);
  if(ctx) (*env)->servlet_redirect = strdup(ctx);

@


1.59
log
@PHP/JSP session sharing
@
text
@d316 1
d346 2
a347 1
	  char *hosts;
d349 12
a360 8
	  static const char redirect[]="X_JAVABRIDGE_OVERRIDE_HOSTS";
	  if(strcmp(str, redirect)) return;
	  hosts = (char*)PARSER_GET_STRING(tag[1].strings, 0);
	  zend_alter_ini_entry((char*)key_hosts, sizeof key_hosts, 
						   hosts, tag[1].strings[0].length+1, 
						   ZEND_INI_SYSTEM, PHP_INI_STAGE_RUNTIME);

	  (*ctx)->must_reopen = 2;
d365 1
d401 5
d407 2
a409 2
	  static const char key_off[] = "Off";
	  static const char key_sockname[] = "java.socketname";
d416 1
d418 1
a419 4
	assert((*env)->peer); if((*env)->peer) close((*env)->peer);
	server = EXT_GLOBAL(test_server)(&(*env)->peer, 0);
	assert(server); if(!server) exit(9);
	free(server);
d443 22
d487 1
a487 1
  return JG(jenv) = EXT_GLOBAL(createSecureEnvironment)(sock, handle_request, server, is_local);
@


1.58
log
@PR1243638: Running php and jsp side by side
@
text
@d229 2
a230 2
		  /*FIXME*/    strdup(PARSER_GET_STRING(st, 2)), /* m */
		  /*FIXME*/    strdup(PARSER_GET_STRING(st, 1)), /* p */
d232 1
a232 1
		  st[1].length,			/* m_length */
a236 1

d343 14
d376 2
d379 2
d393 12
d407 1
a407 1
	server = EXT_GLOBAL(test_server)(&(*env)->peer, 0); /* FIXME: this is not very efficient */
@


1.57
log
@gtk, swing and swt examples added
@
text
@d130 1
a130 1
  
d132 1
a132 1
	php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d): Could not call user function: %s.", 23, fname);
d396 6
a401 6
	unsigned short is_level = ((EXT_GLOBAL (ini_last_updated)&U_LOGLEVEL)!=0);
	unsigned short level = 0;
	if (is_level)
	  level = EXT_GLOBAL(cfg)->logLevel_val>7?7:EXT_GLOBAL(cfg)->logLevel_val;

	return (is_level<<7)|64|(level<<2)|arraysAsValues;
@


1.56
log
@Release-2.0.8pre
@
text
@d104 1
a104 1
static void setResultFromApply(zval *presult, long pos, unsigned char*fname, size_t len, zval *object, zval *params)
a117 14
  if(object) {
	ce = Z_OBJCE_P(object);
	zend_hash_internal_pointer_reset(&ce->function_table);
	while ((key_type = zend_hash_get_current_key(&ce->function_table, &string_key, &num_key, 1)) != HASH_KEY_NON_EXISTANT) {
	  if (key_type == HASH_KEY_IS_STRING) {
		if(!pos) break;
		pos--;
	  }
	  zend_hash_move_forward(&ce->function_table);
	}
	fname = (unsigned char*)string_key;
	len = strlen(string_key);
  }

d119 1
a119 2
  setResultFromString(func, fname, len);
  
a123 1
  
a132 2
  } else {
	EXT_GLOBAL(result)(retval_ptr, 0, presult TSRMLS_CC);
d134 9
a142 2
  
  zval_ptr_dtor(&retval_ptr);
d205 3
a207 3
  unsigned char *m;						/* see Apply in PROTOCOL.TXT */
  size_t m_length;
  long v, p, n;
d229 2
a230 1
		  /*FIXME*/		  strdup(PARSER_GET_STRING(st, 2)), /* m */
d232 1
a233 1
		  strtol((const char*)PARSER_GET_STRING(st, 1), 0, 10), /* p */
a305 11
  case 'A': 
	{ 
	  int err;
	  struct parse_ctx *ctx=(struct parse_ctx*)cb->ctx;
      struct stack_elem *stack_elem;
	  zend_stack_top(&ctx->containers, (void**)&stack_elem);
	  setResultFromApply(stack_elem->retval, stack_elem->p, stack_elem->m, stack_elem->m_length, (zval*)stack_elem->v, stack_elem->container);
	  err=zend_stack_del_top(&ctx->containers);
	  assert(SUCCESS==err);

	}
d313 1
d347 1
d350 1
d352 1
d360 10
d383 4
@


1.55
log
@Release-2.0.7
@
text
@d104 53
d213 1
a213 1
  zval *container;
d215 5
d230 23
d314 13
a326 1
  switch (*(st[0].string)[st[0].off]) {
@


1.54
log
@Release-2.0.7(pre)
@
text
@a15 1
#include <assert.h>
d19 1
a19 1
#include "php_wrapper.h"
a29 1
#include "php_java.h"
@


1.53
log
@Release-2.0.7pre
@
text
@d311 1
a311 1
	  level = EXT_GLOBAL(cfg)->logLevel_val>4?4:EXT_GLOBAL(cfg)->logLevel_val;
@


1.52
log
@Release-2.0.7-pre
@
text
@a105 1
#ifndef ZEND_ENGINE_2
d131 1
a131 1
static pval*hashUpdate  (pval *handle, char *key, size_t len) {
a142 1
#endif
d172 1
a172 1

a174 1
#ifndef ZEND_ENGINE_2
a181 3
#else
	  assert(0);
#endif
a182 1
#ifndef ZEND_ENGINE_2
d188 1
a188 1
		  ctx->id=hashIndexUpdate(stack_elem->container, strtol(PARSER_GET_STRING(st, 1), 0, 10));
a196 3
#else
	  assert(0);
#endif
d237 6
a242 10
#ifndef ZEND_ENGINE_2
  { 
    int err;
	struct parse_ctx *ctx=(struct parse_ctx*)cb->ctx;
    err=zend_stack_del_top(&ctx->containers);
    assert(SUCCESS==err);
  }
#else
	assert(0);
#endif
d248 1
a248 1
  char *str=PARSER_GET_STRING(tag[0].strings, 0);
d256 3
a258 3
	  (*ctx)->cookie_name = strdup(PARSER_GET_STRING(tag[1].strings, 0));
	  cookie = PARSER_GET_STRING(tag[2].strings, 0);
	  if(path=strchr(cookie, ';')) *path=0;	/* strip off path */
d268 1
a268 1
	  if(!strcmp(str, con_connection)&&!strcmp(PARSER_GET_STRING(tag[1].strings, 0), con_close)) {
d279 1
a279 1
  if(EXT_GLOBAL (get_servlet_context) ()) {
d291 1
a291 1
	char*server; int sock;
d316 1
a316 1
static proxyenv *try_connect_to_server(short bail, unsigned char spec TSRMLS_DC) {
d319 1
d327 1
a327 1
  if(!(server=EXT_GLOBAL(test_server)(&sock, spec))) {
d333 1
a333 1
  if(!EXT_GLOBAL (get_servlet_context) ()) {
d338 1
a338 1
  return JG(jenv) = EXT_GLOBAL(createSecureEnvironment)(sock, handle_request, server);
d341 1
a341 1
  return try_connect_to_server(1, 0 TSRMLS_CC);
d345 1
a345 1
  return try_connect_to_server(0, 0 TSRMLS_CC);
@


1.51
log
@Tomcat 5
@
text
@d33 1
a33 1
ZEND_EXTERN_MODULE_GLOBALS(java)
d61 1
a61 1
  /* wrap the java object in a pval object */
d66 1
a66 1
	object_init_ex(presult, php_java_exception_class_entry);
d84 1
a84 1
  /* wrap the java object in a pval object */
d89 1
a89 1
	object_init_ex(presult, php_java_class_entry);
d116 1
d126 1
d137 1
d171 1
a171 1
void begin(parser_tag_t tag[3], parser_cb_t *cb){
d260 1
a260 1
void begin_header(parser_tag_t tag[3], parser_cb_t *cb){
d262 1
d264 1
a264 1
  switch ((*tag[0].strings[0].string)[tag[0].strings[0].off]) {
d267 11
a277 1
	  assert(!strcmp(PARSER_GET_STRING(tag[0].strings, 0), "Set-Cookie"));
d279 6
a284 2
	  (*ctx)->cookie_name = estrdup(PARSER_GET_STRING(tag[1].strings, 0));
	  (*ctx)->cookie_value = estrdup(PARSER_GET_STRING(tag[2].strings, 0));
d293 3
a295 4
  if(get_servlet_context()) {
								/* set cookie only once */
	parser_cb_t cb_header = {(*env)->cookie_name?0:begin_header, 0, env};
	parse_header(env, &cb_header);
d299 1
a299 1
  parse(env, &cb);
d302 26
d337 1
a337 1
	php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: Session is closed. -- This usually means that you have tried to access the server in your class' __destruct() method.",51);
d340 1
a340 1
  if(!(server=java_test_server(&sock, spec))) {
d342 1
a342 1
	  php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge and set the java.socketname option?",52, strerror(errno));
d346 3
a348 9
  if(!get_servlet_context()) {
	unsigned short level = (cfg->logLevel_val)>4?4:cfg->logLevel_val;
#ifndef ZEND_ENGINE_2
  // we want arrays as values
	unsigned char c=128|64|(level<<2)|2;
	#else
	unsigned char c=128|64|(level<<2)|0;
#endif
	send(sock, &c, sizeof c, 0); 
d351 1
a351 1
  return JG(jenv) = java_createSecureEnvironment(sock, handle_request, server);
d353 1
a353 1
proxyenv *java_connect_to_server(TSRMLS_D) {
d356 1
a356 1
proxyenv *java_try_connect_to_server(TSRMLS_D) {
a359 4
proxyenv *java_connect_to_mono(TSRMLS_D) {
  
  return try_connect_to_server(1, 'M' TSRMLS_CC);
}
@


1.50
log
@Tomcat 5 support / multicasts removed
@
text
@d263 2
d276 2
a277 1
	parser_cb_t cb_header = {begin_header, 0, env};
d302 3
d307 3
a309 1
  if(!get_servlet_context()) { char c=2; send(sock, &c, sizeof c, 0); }
d311 2
@


1.49
log
@Version 2.0.6 (windows)
@
text
@d256 13
d273 5
a286 1
  short no_multicast;
d294 1
a294 2
  no_multicast = (spec=='m' || spec=='j');
  if(!(server=no_multicast?java_test_server_no_multicast(&sock, spec TSRMLS_CC):java_test_server(&sock, spec))) {
d301 1
a301 1
  { char c=2; send(sock, &c, sizeof c, 0); }
a316 8
proxyenv *java_connect_to_server_no_multicast(TSRMLS_D) {
  
  return try_connect_to_server(1, 'j' TSRMLS_CC);
}
proxyenv *java_connect_to_mono_no_multicast(TSRMLS_D) {
  
  return try_connect_to_server(1, 'm' TSRMLS_CC);
}
@


1.48
log
@tests for PR1174918
@
text
@d36 1
a36 1
static void setResultFromString (pval *presult, char*s, size_t len){
d143 1
a143 1
static  void  setException  (pval *presult, long value, char *strValue, size_t len) {
d159 1
a159 1
#define GET_RESULT(pos) if(!ctx->id) {ctx->id=(zval*)strtol(PARSER_GET_STRING(st, pos), 0, 10);}
d214 1
a214 1
	setResultFromLong(ctx->id, strtol(PARSER_GET_STRING(st, 0), 0, 10));
d218 1
a218 1
	setResultFromDouble(ctx->id, zend_string_to_double(PARSER_GET_STRING(st, 0), st[0].length));
d225 1
a225 1
	  setResultFromObject(ctx->id, strtol(PARSER_GET_STRING(st, 0), 0, 10));
d230 1
a230 1
	  char *stringRepresentation=PARSER_GET_STRING(st, 1);
d232 1
a232 1
	  long obj = strtol(PARSER_GET_STRING(st, 0), 0, 10);
@


1.47
log
@PR1174918: first start bug with charset
@
text
@d284 2
a285 5
  // we want arrays as values and UTF-8 strings
  { char c=3; send(sock, &c, sizeof c, 0); }
#else
  // we want UTF-8 strings
  { char c=1; send(sock, &c, sizeof c, 0); }
@


1.46
log
@PR1187636 ] java_get_session support
@
text
@d278 1
a278 1
  if(!(server=no_multicast?java_test_server_no_multicast(&sock, spec):java_test_server(&sock, spec))) {
@


1.45
log
@PHP5
@
text
@d269 1
d277 2
a278 2

  if(!(server=java_test_server(&sock, spec))) {
d304 8
@


1.44
log
@multicast: ignore outdated packets
@
text
@d180 2
a184 2
	  break;
	}
d199 2
a203 2
	  break;
	}
d243 3
a245 1
  case 'X': { 
a246 1
#ifndef ZEND_ENGINE_2
@


1.43
log
@*** empty log message ***
@
text
@a246 1
    struct stack_elem *stack_elem;
d278 1
a278 1
	  php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge and set the java.socketname or java.hosts option?",52, strerror(errno));
@


1.42
log
@PR1176523
@
text
@d36 1
a36 1
	 static void setResultFromString (pval *presult, char*s, size_t len){
@


1.41
log
@use a real stack instead of a 5 element array
@
text
@a249 3
	if(SUCCESS==zend_stack_top(&ctx->containers, (void**)&stack_elem))
	  //setResultFromArray(stack_elem->container);
	  ;
d257 1
a257 1
  struct parse_ctx ctx = {0,0,0};
@


1.40
log
@PR1176522
@
text
@d23 2
d36 1
a36 1
static void setResultFromString (pval *presult, char*s, size_t len){
d160 4
d165 2
a166 2
  char composite_type;			/* A|H */
  zval*id, *container;
d176 4
a179 2
	setResultFromArray(ctx->container=ctx->id);
	ctx->composite_type=*PARSER_GET_STRING(st, 0);
d181 1
a181 1
	assert(0);
d183 2
a184 2

	break;
d187 12
a198 9
	if(ctx->composite_type=='H') { /* hash table */
	  if(*PARSER_GET_STRING(st, 0)=='N')	/* number */
		ctx->id=hashIndexUpdate(ctx->container, strtol(PARSER_GET_STRING(st, 1), 0, 10));
	  else
		ctx->id=hashUpdate(ctx->container, PARSER_GET_STRING(st, 1), st[1].length);
	}
	else {						/* array */
	  ctx->id=nextElement(ctx->container);
	}
d200 1
a200 1
	assert(0);
d202 2
a203 1
	break;
d241 18
d261 3
a263 1
  parser_cb_t cb = {begin, 0, &ctx};
d265 2
d276 2
a277 2
		php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: Session is closed. -- This usually means that you have tried to access the server in your class' __destruct() method.",51);
		return 0;
d281 3
a283 3
	  if (bail) 
		php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge and set the java.socketname or java.hosts option?",52, strerror(errno));
	  return 0;
@


1.39
log
@PR1174918: wrong charset
@
text
@d241 5
@


1.38
log
@mono
@
text
@d247 5
a251 2
  // we want arrays as values
  { char c=2; send(sock, &c, sizeof c, 0); }
@


1.37
log
@LOCALE fixes
@
text
@a179 1
	  GET_RESULT(2);
a185 1
	  GET_RESULT(1);
d235 1
a235 1
static proxyenv *try_connect_to_server(short bail TSRMLS_DC) {
d241 1
a241 1
  if(!(server=java_test_server(&sock))) {
d254 1
a254 1
  return try_connect_to_server(1 TSRMLS_CC);
d258 5
a262 1
  return try_connect_to_server(0 TSRMLS_CC);
@


1.36
log
@windows fixes
@
text
@d208 1
a208 1
	setResultFromDouble(ctx->id, atof(PARSER_GET_STRING(st, 0)));
@


1.35
log
@Release 2.0
@
text
@d237 1
a237 1
proxyenv *java_connect_to_server(TSRMLS_D) {
d244 2
a245 1
	  php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge and set the java.socketname or java.hosts option?",52, strerror(errno));
a247 1
  free(server);
d253 8
a260 1
  return JG(jenv) = java_createSecureEnvironment(sock, handle_request);
@


1.34
log
@do not change the channel if server was forked by the httpd
@
text
@d71 1
a71 1
  Z_LVAL_P(handle) = zend_list_insert(value, le_jobject);
d94 1
a94 1
  Z_LVAL_P(handle) = zend_list_insert((void*)value, le_jobject);
d250 1
a250 1
  { char c=2; write(sock, &c, sizeof c); }
@


1.33
log
@Protocol update
@
text
@d244 1
a244 1
	  php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge?",52, strerror(errno));
@


1.32
log
@Protocol update
@
text
@d149 1
a149 2

  setResultFromObject(presult, value); /* discarded */
d151 1
a164 1
  pval *id;
d218 11
d231 1
a231 1
static int handle_request(proxyenv *env) {
a236 37
static int try_servers() {
  if(cfg->hosts && strlen(cfg->hosts)) {
	char *host, *hosts = strdup(cfg->hosts);
	
	assert(hosts); if(!hosts) return 0;
	for(host=strtok(hosts, ";"); host; host=strtok(0, ";")) {
	  struct sockaddr_in addr;
	  char *_port = strrchr(host, ':');
	  int port = 0, sock;

	  if(_port) { 
		*_port++=0;
		if(strlen(_port)) port=atoi(_port);
	  }
	  if(!port) port=DEFAULT_PORT;
	  cfg->saddr.sin_family = AF_INET;
	  cfg->saddr.sin_port=htons(port);
	  if(!isdigit(*host)) {
		struct hostent *hostent = gethostbyname(host);
		if(hostent) {
		  memcpy(&cfg->saddr.sin_addr,hostent->h_addr,sizeof(struct in_addr));
		} else {
		  inet_aton(host, &cfg->saddr.sin_addr);
		}
	  }
	  sock = socket (PF_INET, SOCK_STREAM, 0);
	  if(sock==-1) continue;
	  if(-1!=connect(sock,(struct sockaddr*)&cfg->saddr, sizeof cfg->saddr)) {
		free(hosts);
		return sock;
	  }
	}
	free(hosts);
  }
  return 0;
}

d238 2
a239 1
  int sock, n=-1;
a240 2
  zval *map;

d243 1
a243 10
  if(!(sock=try_servers())) {
#ifndef CFG_JAVA_SOCKET_INET
	sock = socket (PF_LOCAL, SOCK_STREAM, 0);
#else
	sock = socket (PF_INET, SOCK_STREAM, 0);
#endif
	if(sock!=-1) {
	  n = connect(sock,(struct sockaddr*)&cfg->saddr, sizeof cfg->saddr);
	}
	if(n==-1) { 
a245 1
	}
d247 1
@


1.31
log
@Replaced JNI with XML protocol
@
text
@d9 2
d157 1
d160 1
a160 2
  zval*id;
  pval*val;
d169 3
a171 2
	ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 2), 0, 10);
	setResultFromArray(ctx->id);
d173 4
a176 1
	ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 1), 0, 10);
d179 1
d181 1
a181 1
	  ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 2), 0, 10);
d183 1
a183 1
		ctx->val=hashIndexUpdate(ctx->id, strtol(PARSER_GET_STRING(st, 1), 0, 10));
d185 1
a185 1
		ctx->val=hashUpdate(ctx->id, PARSER_GET_STRING(st, 1), st[1].length);
d188 2
a189 3
	  ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 1), 0, 10);
	  ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 0), 0, 10);
	  ctx->id=nextElement(ctx->id);
d191 3
d196 1
a196 1
	ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 1), 0, 10);
d200 2
a201 2
	ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 1), 0, 10);
	setResultFromBoolean(ctx->id, *PARSER_GET_STRING(st, 0)!='0');
d204 1
a204 1
	ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 1), 0, 10);
d208 1
a208 1
	ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 1), 0, 10);
d212 1
a212 1
	ctx->id=(zval*)strtol(PARSER_GET_STRING(st, 1), 0, 10);
d227 37
d267 1
d271 1
d273 1
a273 1
  sock = socket (PF_LOCAL, SOCK_STREAM, 0);
d275 1
a275 1
  sock = socket (PF_INET, SOCK_STREAM, 0);
d277 7
a283 6
  if(sock!=-1) {
	n = connect(sock,(struct sockaddr*)&cfg->saddr, sizeof cfg->saddr);
  }
  if(n==-1) { 
	php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge?",52, strerror(errno));
	return 0;
d285 4
@


1.30
log
@Replaced JNI with XML protocol
@
text
@d163 8
a170 6
  zval*id=(zval*)strtol(st[0].string, 0, 16);
  if(id) ctx->id=id;
  switch (tag[0].strings[0].string[0]) {
  case 'C':
	setResultFromArray((pval*)id);
	ctx->composite_type=*st[1].string;
d174 3
a176 2
	  if(*st[1].string=='N')	/* number */
		ctx->val=hashIndexUpdate(ctx->id, strtol(st[2].string, 0, 10));
d178 1
a178 1
		ctx->val=hashUpdate(ctx->id, st[2].string, st[2].length);
d181 2
d187 2
a188 1
	setResultFromString(ctx->id, st[1].string, st[1].length);
d191 2
a192 1
	setResultFromBoolean(ctx->id, *st[1].string!='0');
d195 2
a196 1
	setResultFromLong(ctx->id, strtol(st[1].string, 0, 10));
d199 2
a200 1
	setResultFromDouble(ctx->id, atof(st[1].string));
d203 2
a204 1
	if(!st[1].length) {
d207 1
a207 1
	  setResultFromObject(ctx->id, strtol(st[1].string, 0, 16));
d213 3
a215 2
  parser_cb_t cb;
  parse((*env)->peer, &cb);
a219 1
  SFILE *peer;
a235 6
  peer = SFDOPEN(sock, "r+");
  assert(peer);
  if(!peer) { 
	php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge?",53, strerror(errno));
	return 0;
  }
d237 1
a237 1
  return java_createSecureEnvironment(peer, handle_request);
@


1.29
log
@Release-1.0.8
@
text
@a16 3
/* jni */
#include <jni.h>

d24 2
d32 1
a32 12
#define swrite java_swrite
extern void java_swrite(const  void  *ptr,  size_t  size,  size_t  nmemb,  SFILE *stream);

#define sread java_sread
extern void java_sread(void *ptr, size_t size, size_t nmemb, SFILE *stream);

#define id java_id
extern void java_id(proxyenv *env, char id);

static void setResultFromString (proxyenv *jenv,  pval *presult, jbyteArray jvalue){
  jboolean isCopy;
  jbyte *value = (*jenv)->GetByteArrayElements(jenv, jvalue, &isCopy);
d34 1
a34 1
  Z_STRLEN_P(presult)=(*jenv)->GetArrayLength(jenv, jvalue);
d36 1
a36 1
  memcpy(Z_STRVAL_P(presult), value, Z_STRLEN_P(presult));
a37 1
  if (isCopy) (*jenv)->ReleaseByteArrayElements(jenv, jvalue, value, 0);
d39 1
a39 1
static  void  setResultFromLong  (proxyenv *jenv,  pval *presult, jlong value) {
d41 1
a41 1
  Z_LVAL_P(presult)=(long)value;
d45 1
a45 1
static void  setResultFromDouble  (proxyenv *jenv,  pval *presult, jdouble value) {
d50 1
a50 1
static  void  setResultFromBoolean  (proxyenv *jenv, pval *presult, jboolean value) {
d56 1
a56 1
static  void  setResultFromException  (proxyenv *jenv,  pval *presult, jthrowable value) {
a57 1
  jobject _ob;
d69 1
a69 2
  _ob= (*jenv)->NewGlobalRef(jenv, value);
  Z_LVAL_P(handle) = zend_list_insert(_ob, le_jobject);
d79 1
a79 1
static  void  setResultFromObject  (proxyenv *jenv,  pval *presult, jobject value) {
a80 1
  jobject _ob;
d92 1
a92 2
  _ob= (*jenv)->NewGlobalRef(jenv, value);
  Z_LVAL_P(handle) = zend_list_insert(_ob, le_jobject);
d103 1
a103 1
static  void  setResultFromArray  (proxyenv *jenv,  pval *presult) {
d108 1
a108 1
static  pval*nextElement  (proxyenv *jenv,  pval *handle) {
d117 1
a117 1
static  pval*hashIndexUpdate  (proxyenv *jenv,  pval *handle, jlong key) {
d126 1
a126 1
static pval*hashUpdate  (proxyenv *jenv, pval *handle, jbyteArray key) {
d131 1
a131 1
  setResultFromString(jenv, &pkey, key);
d139 1
a139 1
static  void  setException  (proxyenv *jenv,  pval *presult, jthrowable value, jbyteArray strValue) {
d141 1
a141 1
  setResultFromString(jenv, presult, strValue);
d148 1
a148 1
  setResultFromObject(jenv, presult, value); /* discarded */
d150 1
a150 1
  setResultFromException(jenv, exception, value); 
d155 44
a198 64

static int handle_request(proxyenv *env) {
  jlong result;
  char c;
  SFILE *peer=(*env)->peer;
  sread(&c, 1, 1, peer);

  switch(c) {
  case PROTOCOL_END: {
	return 0;
  }
  case SETRESULTFROMSTRING: {
	jbyteArray jvalue;
	sread(&result, sizeof result, 1, peer);
	sread(&jvalue, sizeof jvalue, 1, peer);
	if(jvalue)
	  setResultFromString(env, (pval*)(long)result, jvalue);
	else
	  ZVAL_NULL((pval*)(long)result);
	break;
  }
  case SETRESULTFROMLONG: {
	jlong jvalue;
	sread(&result, sizeof result, 1, peer);
	sread(&jvalue, sizeof jvalue, 1, peer);
	setResultFromLong(env, (pval*)(long)result, jvalue);
	break;
  }
  case SETRESULTFROMDOUBLE: {
	jdouble jvalue;
	sread(&result, sizeof result, 1, peer);
	sread(&jvalue, sizeof jvalue, 1, peer);
	setResultFromDouble(env, (pval*)(long)result, jvalue);
	break;
  }
  case SETRESULTFROMBOOLEAN: {
	jboolean jvalue;
	sread(&result, sizeof result, 1, peer);
	sread(&jvalue, sizeof jvalue, 1, peer);
	setResultFromBoolean(env, (pval*)(long)result, jvalue);
	break;
  }
  case SETRESULTFROMOBJECT: {
	jobject jvalue;
	sread(&result, sizeof result, 1, peer);
	sread(&jvalue, sizeof jvalue, 1, peer);
	setResultFromObject(env, (pval*)(long)result, jvalue);
	break;
  }
  case SETRESULTFROMARRAY: {
	jobject jvalue;
#ifdef ZEND_ENGINE_2
	static const jboolean send_content = JNI_FALSE;
#else
	static const jboolean send_content = JNI_TRUE;
#endif
 	sread(&result, sizeof result, 1, peer);
 	sread(&jvalue, sizeof jvalue, 1, peer);
	swrite(&send_content, sizeof send_content, 1, peer);
#ifdef ZEND_ENGINE_2
	setResultFromObject(env, (pval*)(long)result, jvalue);
#else
	setResultFromArray(env, (pval*)(long)result);
#endif
a200 54

/*
 * The following is from Sam Ruby's original PHP 4 bridge. When the
 * result was an array or Hashtable, the ext/java extension copied the
 * entire(!) array or hash to the PHP interpreter.  Since PHP 5 this
 * is dead code.
 */
#ifndef ZEND_ENGINE_2
  case NEXTELEMENT: {
	sread(&result, sizeof result, 1, peer);
	result=(jlong)(long)nextElement(env, (pval*)(long)result);
	id(env, 0);
	swrite(&result, sizeof result, 1, peer);
	break;
  }
  case HASHINDEXUPDATE: {
	jlong jvalue;
	sread(&result, sizeof result, 1, peer);
	sread(&jvalue, sizeof jvalue, 1, peer);
	result=(jlong)(long)hashIndexUpdate(env, (pval*)(long)result, jvalue);
	id(env, 0);
	swrite(&result, sizeof result, 1, peer);
	break;
  }
  case HASHUPDATE: {
	jbyteArray jvalue;
	sread(&result, sizeof result, 1, peer);
	sread(&jvalue, sizeof jvalue, 1, peer);
	result=(jlong)(long)hashUpdate(env, (pval*)(long)result, jvalue);
	id(env, 0);
	swrite(&result, sizeof result, 1, peer);
	break;
  }
#endif
  case SETEXCEPTION: {
	jthrowable jvalue;
	jbyteArray jstrValue;
	sread(&result, sizeof result, 1, peer);
	sread(&jvalue, sizeof jvalue, 1, peer);
	sread(&jstrValue, sizeof jstrValue, 1, peer);
	setException(env, (pval*)(long)result, jvalue, jstrValue);
	break;
  }
  default: {
	php_error(E_ERROR, "php_mod_java(%d): %s, %i",61, "protocol error: ", (unsigned int)c);
	id(env, 0);
	return 0;
  }
  }

  // acknowledge
  id(env, 0); 
  
  return 1;
d202 3
a204 5
static int handle_requests(proxyenv *env) {
  // continue to handle server requests until the server says the
  // packet is finished (one of the three main methods has sent 0)
  while(handle_request(env));
  return 0;
a206 4
#define JAVA_METHOD(name, strname, class, param) \
  JG(name) = (*jenv)->GetMethodID(jenv, JG(class), strname, param);\
  if(!JG(name)) exit(9) 		/* out of memory or some other fatal error */

a207 2
  jobject local_php_reflect;
  jclass local_class;
d233 1
a233 40
  jenv=java_createSecureEnvironment(peer, handle_requests);
  assert(jenv); 

  if(jenv&&SFREAD(&local_php_reflect, sizeof local_php_reflect, 1, peer)!=1) {
	php_error(E_ERROR, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge?",58, strerror(errno));
	return 0;
  }

  BEGIN_TRANSACTION(jenv);
  /* java bridge class */
  local_class = (*jenv)->FindClass(jenv, "JavaBridge");
  if(!local_class) exit(9);
  JG(reflect_class) = (*jenv)->NewGlobalRef(jenv, local_class);
  if(!JG(reflect_class)) exit(9);
  
  /* java bridge instance */
  JG(php_reflect) = (*jenv)->NewGlobalRef(jenv, local_php_reflect);
  if(!JG(php_reflect)) exit(9);

  JAVA_METHOD(setJarPath, "setJarLibraryPath", reflect_class, "(Ljava/lang/String;)V");
  JAVA_METHOD(clearEx, "clearException", reflect_class, "()V");
  JAVA_METHOD(lastEx, "lastException", reflect_class, "(JJ)V");
  JAVA_METHOD(getPhpMap, "getPhpMap", reflect_class, "(Ljava/lang/Object;)LJavaBridge$PhpMap;");

  local_class = (*jenv)->FindClass(jenv, "JavaBridge$PhpMap");
  if(!local_class) exit(9);
  JG(iterator_class) = (*jenv)->NewGlobalRef(jenv, local_class);
  if(!JG(iterator_class)) exit(9);

  JAVA_METHOD(moveForward, "moveForward", iterator_class, "()Ljava/lang/Object;");
  JAVA_METHOD(hasMore, "hasMore", iterator_class, "()Ljava/lang/Object;");
  JAVA_METHOD(getType, "getType", iterator_class, "()Ljava/lang/Object;");
  
  JAVA_METHOD(invoke, "Invoke", reflect_class, "(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;JJ)V");
  JAVA_METHOD(gsp, "GetSetProp", reflect_class, "(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;JJ)V");
  JAVA_METHOD(co, "CreateObject", reflect_class, "(Ljava/lang/String;Z[Ljava/lang/Object;JJ)V");

  END_TRANSACTION(jenv);

  return JG(jenv)=jenv;
@


1.28
log
@Release-1.0.8
@
text
@d162 3
@


1.27
log
@ZTS
@
text
@d30 1
a30 1
ZEND_DECLARE_MODULE_GLOBALS(java)
a31 23
#ifdef JAVA_COMPILE_DEBUG
static int check_error(proxyenv *jenv, char*msg TSRMLS_DC) {
  jthrowable error = (*(jenv))->ExceptionOccurred(jenv);
  jvalue args[0];
  jclass errClass;
  jmethodID toString;
  jobject errString;
  const char *errAsUTF;
  jboolean isCopy;
  if(!error) return 0;
  (*jenv)->ExceptionClear(jenv);
  errClass = (*jenv)->GetObjectClass(jenv, error);
  toString = (*jenv)->GetMethodID(jenv, errClass, "toString", "()Ljava/lang/String;");
  errString = (*jenv)->CallObjectMethodA(0, jenv, error, toString, args);
  errAsUTF = (*jenv)->GetStringUTFChars(jenv, errString, &isCopy);
  fprintf(stdout, "php_mod_java(%s): %s",msg, errAsUTF);
  php_error(E_ERROR, "php_mod_java(%s): %s",msg, errAsUTF);
  if(isCopy) (*jenv)->ReleaseStringUTFChars(jenv, errString, errAsUTF);
  return 1;
}
#else
#define check_error(a, b) 0
#endif
d299 1
a299 1
  if(check_error(jenv, strname TSRMLS_CC)) return 0;
d340 1
a340 1
  if(check_error(jenv, "local_php_class" TSRMLS_CC)) return 0;
d342 1
a342 1
  if(check_error(jenv, "reflect_class" TSRMLS_CC)) return 0;
d346 1
a346 1
  if(check_error(jenv, "php_reflect" TSRMLS_CC)) return 0;
d354 1
a354 1
  if(check_error(jenv, "local_iterator_class" TSRMLS_CC)) return 0;
d356 1
a356 1
  if(check_error(jenv, "iterator_class" TSRMLS_CC)) return 0;
@


1.26
log
@use java security instead of dropping the process privileges
@
text
@a11 6
/* wait */
#include <sys/types.h>
#include <sys/wait.h>
/* poll */
#include <sys/poll.h>

a319 38
static int java_do_test_server(struct cfg*cfg TSRMLS_DC) {
  char term=0;
  int sock;
  int n, c, e;
  jobject ob;

#ifndef CFG_JAVA_SOCKET_INET
  sock = socket (PF_LOCAL, SOCK_STREAM, 0);
#else
  sock = socket (PF_INET, SOCK_STREAM, 0);
#endif
  if(sock==-1) return FAILURE;
  n = connect(sock,(struct sockaddr*)&cfg->saddr, sizeof cfg->saddr);
  if(n!=-1) {
	c = read(sock, &ob, sizeof ob);
	c = (c==sizeof ob) ? write(sock, &term, sizeof term) : 0;
  }
  e = close(sock);

  return (n!=-1 && e!=-1 && c==1)?SUCCESS:FAILURE;
}
int java_test_server(struct cfg*cfg TSRMLS_DC) {
  struct pollfd pollfd[1] = {{cfg->err, POLLIN, 0}};
  int count=15;

  if(java_do_test_server(cfg TSRMLS_CC)==SUCCESS) return SUCCESS;

  /* wait for the server that has just started */
  while(cfg->cid && (java_do_test_server(cfg TSRMLS_CC)==FAILURE) && --count) {
	if(cfg->err && poll(pollfd, 1, 0)) 
	  return FAILURE; /* server terminated with error code */
	php_error(E_NOTICE, "php_mod_java(%d): waiting for server another %d seconds",57, count);
	
	sleep(1);
  }
  return (cfg->cid && count)?SUCCESS:FAILURE;
}

d324 1
a324 1
proxyenv *java_connect_to_server(struct cfg*cfg TSRMLS_DC) {
@


1.25
log
@secure mode
@
text
@a324 33
#ifdef HAVE_STRUCT_UCRED
static int send_cred(int sock) {
  int ret;
  struct msghdr msg = {0};
  struct cmsghdr *cmsg;
  struct ucred *p_ucred, ucred = {getpid(), getuid(), getgid()};
  char buf[CMSG_SPACE(sizeof ucred)];  /* ancillary data buffer */

  msg.msg_control = buf;
  msg.msg_controllen = sizeof buf;

  cmsg = CMSG_FIRSTHDR(&msg);
  cmsg->cmsg_level = SOL_SOCKET;
  cmsg->cmsg_type = SCM_CREDENTIALS;
  cmsg->cmsg_len = CMSG_LEN(sizeof ucred);

  /* Initialize the payload: */
  p_ucred = (struct ucred *)CMSG_DATA(cmsg);
  memcpy(p_ucred, &ucred, sizeof *p_ucred);

  /* Sum of the length of all control messages in the buffer: */
  msg.msg_controllen = cmsg->cmsg_len;

  ret = sendmsg(sock, &msg, 0);
#ifdef JAVA_COMPILE_DEBUG
  return ret;
#else
  return 0;
#endif
}
#else
#define send_cred(a) 0
#endif
a339 2
	if(-1==send_cred(sock)) 
	  php_error(E_WARNING, "php_mod_java(%d): Could not send credentials: %s",81, strerror(errno));
d365 2
a366 2
  JG(name) = (*JG(jenv))->GetMethodID(JG(jenv), JG(class), strname, param);\
  if(check_error(JG(jenv), strname TSRMLS_CC)) return FAILURE;
d368 1
a368 1
int java_connect_to_server(struct cfg*cfg TSRMLS_DC) {
d373 3
a384 2
  if(-1==send_cred(sock)) 
	php_error(E_WARNING, "php_mod_java(%d): Could not send credentials: %s",82, strerror(errno));
d386 2
a387 2
	php_error(E_WARNING, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge?",52, strerror(errno));
	return FAILURE;
d391 4
a394 1
  if(!peer) return FAILURE;
d396 2
a397 1
  JG(jenv)=java_createSecureEnvironment(peer, handle_requests);
d399 3
a401 3
  if(SFREAD(&local_php_reflect, sizeof local_php_reflect, 1, peer)!=1) {
	php_error(E_WARNING, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge?",58, strerror(errno));
	return FAILURE;
d404 1
a404 1
  BEGIN_TRANSACTION(JG(jenv));
d406 4
a409 4
  local_class = (*JG(jenv))->FindClass(JG(jenv), "JavaBridge");
  if(check_error(JG(jenv), "local_php_class" TSRMLS_CC)) return FAILURE;
  JG(reflect_class) = (*JG(jenv))->NewGlobalRef(JG(jenv), local_class);
  if(check_error(JG(jenv), "reflect_class" TSRMLS_CC)) return FAILURE;
d412 2
a413 2
  JG(php_reflect) = (*JG(jenv))->NewGlobalRef(JG(jenv), local_php_reflect);
  if(check_error(JG(jenv), "php_reflect" TSRMLS_CC)) return FAILURE;
d420 4
a423 4
  local_class = (*JG(jenv))->FindClass(JG(jenv), "JavaBridge$PhpMap");
  if(check_error(JG(jenv), "local_iterator_class" TSRMLS_CC)) return FAILURE;
  JG(iterator_class) = (*JG(jenv))->NewGlobalRef(JG(jenv), local_class);
  if(check_error(JG(jenv), "iterator_class" TSRMLS_CC)) return FAILURE;
d433 3
a435 2
  END_TRANSACTION(JG(jenv));
  return SUCCESS;
@


1.24
log
@release 1.0.7
@
text
@d325 34
a370 3
#ifdef CFG_JAVA_SOCKET_ANON
  *cfg->saddr.sun_path=0;
#endif
a371 3
#ifdef CFG_JAVA_SOCKET_ANON
  *cfg->saddr.sun_path='@@';
#endif
d373 2
a414 3
#ifdef CFG_JAVA_SOCKET_ANON	
	*cfg->saddr.sun_path=0;
#endif
a415 3
#ifdef CFG_JAVA_SOCKET_ANON	
	*cfg->saddr.sun_path='@@';
#endif
d417 2
@


1.23
log
@release 1.0.7
@
text
@a22 4
#ifdef ZEND_ENGINE_2
#include "zend_exceptions.h"
#endif

d28 3
a30 1

d38 1
a38 1

d58 3
a214 1
#ifdef ZEND_ENGINE_2
a216 1
#endif
d353 1
a353 1
  struct pollfd pollfd[1] = {cfg->err, POLLIN, 0};
@


1.22
log
@trampoline
@
text
@d43 1
d53 1
a53 1
  errString = (*jenv)->CallObjectMethod(0, jenv, error, toString);
d103 1
a103 2
  if ((Z_TYPE_P(presult) != IS_OBJECT) 
	  || (zend_get_class_entry(presult) != php_java_exception_class_entry)) {
d115 3
a117 1
  zval_add_ref(&handle);
d140 3
a142 1
  zval_add_ref(&handle);
d190 3
a192 5
  setResultFromException(jenv, presult, value);
  MAKE_STD_ZVAL(exception);
  memcpy(exception, presult, sizeof *exception);
  zval_copy_ctor(exception);
  INIT_PZVAL(exception);
d441 4
@


1.21
log
@trampoline
@
text
@d31 1
a31 1
#include "php.h"
d374 1
d409 3
a411 1
  JG(reflect_class) = (*JG(jenv))->FindClass(JG(jenv), "JavaBridge");
d423 3
a425 1
  JG(iterator_class) = (*JG(jenv))->FindClass(JG(jenv), "JavaBridge$PhpMap");
@


1.20
log
@php 5
@
text
@d23 4
a97 1
  jlong result;
d143 1
d178 1
d374 1
a374 2
  jmethodID init;
  int sock, s, i, n=-1, len;
d406 1
d431 1
@


1.19
log
@PHP5 iterator/array
@
text
@d258 8
d291 1
d366 1
@


1.18
log
@php 4/5
@
text
@d37 1
a37 1
static int check_error(proxyenv *jenv, int nr TSRMLS_DC) {
d50 2
a51 2
  fprintf(stdout, "php_mod_java(%d): %s",nr, errAsUTF);
  php_error(E_ERROR, "php_mod_java(%d): %s",nr, errAsUTF);
d205 6
a210 1
	setResultFromString(env, (pval*)(long)result, jvalue);
d242 6
d249 5
d255 1
d353 4
d394 1
a394 1
  if(check_error(JG(jenv), 3 TSRMLS_CC)) return FAILURE;
d398 1
a398 1
  if(check_error(JG(jenv), 5 TSRMLS_CC)) return FAILURE;
d400 15
a414 15
  /* library path */
  JG(setJarPath) = (*JG(jenv))->GetMethodID(JG(jenv), JG(reflect_class), 
										"setJarLibraryPath", 
										"(Ljava/lang/String;)V");
  if(check_error(JG(jenv), 7 TSRMLS_CC)) return FAILURE;

  /* clear exeption */
  JG(clearEx) = (*JG(jenv))->GetMethodID(JG(jenv), JG(reflect_class), 
										 "clearException", "()V");
  if(check_error(JG(jenv), 9 TSRMLS_CC)) return FAILURE;

  /* last exception */
  JG(lastEx) = (*JG(jenv))->GetMethodID(JG(jenv), JG(reflect_class), 
										"lastException", "(JJ)V");
  if(check_error(JG(jenv), 11 TSRMLS_CC)) return FAILURE;
@


1.17
log
@php 4/5
@
text
@d321 1
a327 1
	struct pollfd pollfd[1] = {cfg->err, POLLIN, 0};
@


1.16
log
@php 4/5
@
text
@d15 2
d322 1
d324 1
d326 4
a329 1
  while(cfg->cid && (java_do_test_server(cfg TSRMLS_CC)==FAILURE) && count--) {
d331 1
@


1.15
log
@Version 1.1
@
text
@d297 1
a297 1
#ifdef CFG_JAVA_SOCKET_INET
@


1.14
log
@php 5
@
text
@d89 26
d173 3
a175 2
static  void  setException  (proxyenv *jenv,  pval *presult, jbyteArray value) {
  setResultFromString(jenv, presult, value);
d177 9
d265 2
a266 1
	jbyteArray jvalue;
d269 2
a270 1
	setException(env, (pval*)(long)result, jvalue);
@


1.13
log
@PHP 5 support
@
text
@d324 2
d329 1
d333 17
a349 1
   return SUCCESS;
@


1.12
log
@win32/mingw
@
text
@d54 2
d57 2
a58 15
static void swrite(const  void  *ptr,  size_t  size,  size_t  nmemb,  SFILE *stream) {
  int n = SFWRITE(ptr, size, nmemb, stream);
  //printf("write char:::%d\n", (unsigned int) ((char*)ptr)[0]);
  assert(n==nmemb);
  if(n!=nmemb) exit(6);
}
static void sread(void *ptr, size_t size, size_t nmemb, SFILE *stream) {
  int n = SFREAD(ptr, size, nmemb, stream);
  //printf("read char:::%d\n", (unsigned int) ((char*)ptr)[0]);
  assert(n==nmemb);
  if(n!=nmemb) exit(7);
}
static void id(proxyenv *env, char id) {
  swrite(&id, sizeof id, 1, (*env)->peer);
}
d60 2
d96 1
a96 1
	object_init_ex(presult, &php_java_class_entry);
d296 1
a296 1
#ifdef CFG_JAVA_SOCKET_INET
@


1.11
log
@Added support for Slowlaris' broken stdio:
SFREAD SFWRITE SFDOPEN SFCLOSE SFEOF SFERROR: Use these instead of the stdio
versions.  On Solaris these functions access the raw socket, which is slow
but at least it works
@
text
@a2 8
/* socket */
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
/* select */
#include <sys/select.h>

a6 3
/* dynamic loader */
#include <dlfcn.h>

a11 3
/* posix threads implementation */
#include <pthread.h>

d268 5
a272 1
  sock = socket (PF_UNIX, SOCK_STREAM, 0);
d305 5
a309 1
  sock = socket (PF_UNIX, SOCK_STREAM, 0);
@


1.10
log
@Fixed a bug that appeared on Slowlaris 9 stdio implementations.

From the BSD fopen(3) manpage (solaris' own manpage is pretty useless):

     Reads and writes may be intermixed on read/write streams in any order,
     and do not require an intermediate seek as in previous versions of stdio.
     This is not portable to other systems, however; ANSI C requires that a
     file positioning function intervene between output and input, unless an
     input operation encounters end-of-file.


One of these "other systems" is solaris 9. From Linux' manpage:

       Reads  and writes may be intermixed on read/write streams in any order.
       Note that ANSI C requires that a file  positioning  function  intervene
       between  output and input, unless an input operation encounters end-of-
       file.  (If this condition is not met, then a read is allowed to  return
       the result of writes other than the most recent.)  Therefore it is good
       practice (and indeed sometimes necessary under Linux) to put  an  fseek
       or  fgetpos  operation  between  write  and  read  operations on such a
       stream.  This operation may be an apparent no-op (as in fseek(...,  0L,
       SEEK_CUR) called for its synchronizing side effect.

The problem is that the above paragraph does not apply to fdopen'ed streams
because these streams are not seekable.  Applying a seek operation on a
socket stream generates an error:

From Nathan Kurz:

 Ok, so I'll put one in.  But everything I try comes back with an error that the
 operation is not permitted.  I've tried all the combinations of fseek() and
 fsetpos() that I can think of (to the current position, to the beginning, the
 end) but (logically enough) none are supported.


So one cannot use fseek on sockets streams. That's why *all* stdio
implementations, except Solaris' do *not* require fseek() anymore.


But that still does not solve our problem; we must rewind the Solaris stdio
buffers somehow.  fseek() does not work, but fortunately fflush() does
what we want. In other words, this is a hack that Sun invented to make
stdio buffers work with socket streams.  Die, sun, DIE!

Bugfix:  Call fflush right before fwrite and fread so that the
Sun stdio implementation rewinds the bufer pointers.
@
text
@d69 2
a70 4
static void swrite(const  void  *ptr,  size_t  size,  size_t  nmemb,  FILE *stream) {
  int n;
  fflush(stream);
  n = fwrite(ptr, size, nmemb, stream);
d75 2
a76 4
static void sread(void *ptr, size_t size, size_t nmemb, FILE *stream) {
  int n;
  fflush(stream);
  n = fread(ptr, size, nmemb, stream);
d179 1
a179 1
  FILE *peer=(*env)->peer;
d313 1
a313 1
  FILE *peer;
d329 1
a329 1
  peer = fdopen(sock, "r+");
d335 1
a335 1
  if(fread(&local_php_reflect, sizeof local_php_reflect, 1, peer)!=1) {
@


1.9
log
@more expressive error messages
@
text
@d70 3
a72 1
  int n = fwrite(ptr, size, nmemb, stream);
d78 3
a80 1
  int n = fread(ptr, size, nmemb, stream);
@


1.9.2.1
log
@workaround for broken sparc stdio
@
text
@a42 1
#include "jfile.h"
d69 2
a70 2
static void swrite(const  void  *ptr,  size_t  size,  size_t  nmemb,  JFILE *stream) {
  int n = java_fwrite(ptr, size, nmemb, stream);
d75 2
a76 2
static void sread(void *ptr, size_t size, size_t nmemb, JFILE *stream) {
  int n = java_fread(ptr, size, nmemb, stream);
d179 1
a179 1
  JFILE *peer=(*env)->peer;
d313 1
a313 1
  JFILE *peer;
d329 1
a329 1
  peer = java_fdopen(sock, "r+");
d335 1
a335 1
  if(java_fread(&local_php_reflect, sizeof local_php_reflect, 1, peer)!=1) {
@


1.8
log
@gcc2
@
text
@d345 1
a345 8
  init =
	(*JG(jenv))->GetMethodID(JG(jenv), JG(reflect_class), "<init>", "()V");
  if(check_error(JG(jenv), 5 TSRMLS_CC)) return FAILURE;

  (*JG(jenv))->CallVoidMethod(0, JG(jenv), JG(php_reflect), init);
  if(check_error(JG(jenv), 5 TSRMLS_CC)) return FAILURE;

  return SUCCESS;
@


1.7
log
@The client receives the bridge instance as the first element.  This fixes the classpath bug.
@
text
@a50 1
  if(!error) return 0;
d56 1
d114 1
d126 1
a126 1
  jobject _ob= (*jenv)->NewGlobalRef(jenv, value);
d310 1
d313 1
a313 1
  FILE *fd;
d329 1
a329 1
  FILE *peer = fdopen(sock, "r+");
a334 1
  jobject local_php_reflect;
@


1.6
log
@anon socket: use abstract namespace
@
text
@d279 2
d290 4
a293 1
  if(n!=-1) c = write(sock, &term, sizeof term);
a312 5
  if(java_do_test_server(cfg TSRMLS_CC)==FAILURE) {
	php_error(E_WARNING, "php_mod_java(%d): Could not connect to server: %s -- Have you started the java bridge?",56, strerror(errno));
	return FAILURE;
  }

d332 6
a337 1
  
a340 3
  jobject local_php_reflect = (*JG(jenv))->AllocObject(JG(jenv), JG(reflect_class));
  if(check_error(JG(jenv), 4 TSRMLS_CC)) return FAILURE;
  
@


1.5
log
@java_set_jar_library_path added
@
text
@d73 1
d79 1
d280 4
a283 2
  assert(sock);
  if(!sock) return FAILURE;
d285 3
d305 1
a305 1
  int sock, s, i, n, len;
d308 4
a311 1
  if(java_do_test_server(cfg TSRMLS_CC)==FAILURE) return FAILURE;
d314 9
a322 2
  assert(sock);
  n = connect(sock,(struct sockaddr*)&cfg->saddr, sizeof cfg->saddr);
d329 1
@


1.4
log
@Close the socket in rshutdown
@
text
@d49 1
a49 1
static int abort_on_error(proxyenv *jenv, int nr TSRMLS_DC) {
d276 1
a276 1
  int n, c;
d282 1
a282 1
  close(sock);
d284 1
a284 1
  return (n!=-1 && c==1)?SUCCESS:FAILURE;
d297 1
d316 1
a316 1
  if(abort_on_error(JG(jenv), 3 TSRMLS_CC)) return FAILURE;
d319 1
a319 1
  if(abort_on_error(JG(jenv), 4 TSRMLS_CC)) return FAILURE;
d322 9
a330 1
  if(abort_on_error(JG(jenv), 5 TSRMLS_CC)) return FAILURE;
@


1.3
log
@Start java in a separate process and give pval's a proper reference count.
@
text
@a292 1
	if(waitpid(cfg->cid, NULL, WNOHANG))  cfg->cid=0; // child died
d299 3
@


1.2
log
@Initialize pval's correctly so that they start with the correct ref-count.
@
text
@d127 1
d139 1
d148 1
d150 2
a151 4
  if(key) {
	zval_add_ref(&result);
	zend_hash_index_update(Z_ARRVAL_P(handle), (unsigned long)key, &result, sizeof(zval *), NULL);
  }
d158 1
d161 3
a163 4
  if(key) {
	zval_add_ref(&result);
	zend_hash_update(Z_ARRVAL_P(handle), Z_STRVAL(pkey), Z_STRLEN(pkey)+1, &result, sizeof(zval *), NULL);
  }
@


1.1
log
@Initial revision
@
text
@d133 1
d139 1
d147 4
a150 1
  zend_hash_index_update(Z_ARRVAL_P(handle), (unsigned long)key, &result, sizeof(zval *), NULL);
d159 4
a162 1
  zend_hash_update(Z_ARRVAL_P(handle), Z_STRVAL(pkey), Z_STRLEN(pkey)+1, &result, sizeof(zval *), NULL);
@


1.1.1.1
log
@Initial
@
text
@@
