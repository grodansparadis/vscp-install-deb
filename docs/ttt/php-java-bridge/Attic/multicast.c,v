head	1.17;
access;
symbols
	Release-2-0-6-branch:1.15.0.2;
locks; strict;
comment	@ * @;


1.17
date	2005.06.15.20.30.22;	author jost2345;	state dead;
branches;
next	1.16;

1.16
date	2005.06.15.15.18.02;	author jost2345;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.16.17.50.38;	author jost2345;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.15.20.17.35;	author jost2345;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.13.17.40.07;	author jost2345;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.12.19.11.29;	author jost2345;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.11.17.28.48;	author jost2345;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.30.18.57.26;	author jost2345;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.30.14.47.02;	author jost2345;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.27.18.22.17;	author jost2345;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.25.18.40.07;	author jost2345;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.25.18.37.55;	author jost2345;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.18.16.46.33;	author jost2345;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.17.21.01.22;	author jost2345;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.07.17.54.36;	author jost2345;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.07.17.31.31;	author jost2345;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.27.15.45.45;	author jost2345;	state Exp;
branches;
next	;


desc
@@


1.17
log
@*** empty log message ***
@
text
@@


1.16
log
@Tomcat 5 support / multicasts removed
@
text
@@


1.15
log
@Release-2.0.6 branch
@
text
@a0 201
/*-*- mode: C; tab-width:4 -*-*/

#ifndef __MINGW32__
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>

#include "multicast.h"

union php_java_semun {
  int val;
  struct semid_ds *buf;
  unsigned short *array;
};

static void enter(int id) {
  static struct sembuf ops = {0, -1, 0};
  semop(id, &ops, 1);
}
static void leave(int id) {
  static struct sembuf ops = {0, 1, 0};
  semop(id, &ops, 1);
}
static int init() {
  union php_java_semun val;
  struct semid_ds buf;
  int id = semget(0x9168, 1, IPC_CREAT | 0640);
  if(id==-1) return -1;
  val.buf = &buf;
  if(-1==semctl(id, 0, IPC_STAT, val)) return -1;
  if(!buf.sem_otime) {
    val.val=1;
    if(-1==semctl(id, 0, SETVAL, val)) return -1;
  }
  return id;
}

static unsigned long readInt(unsigned char*buf) {
  return (buf[0]&0xFF)<<24|(buf[1]&0xFF)<<16|(buf[2]&0xFF)<<8|(buf[3]&0xFF);
}
static void writeInt(unsigned char*buf, unsigned long i) {
  buf[0]=(i&(0xFF<<24))>>24;
  buf[1]=(i&(0xFF<<16))>>16;
  buf[2]=(i&(0xFF<<8))>>8;
  buf[3]=i&0xFF;
}
#endif
#include <sys/time.h>

int php_java_init_multicast() {
  int sock = -1;
#ifndef __MINGW32__
  long s_true=1;
  long s_false=0;
  struct sockaddr_in saddr;
  struct ip_mreq ip_mreq;

  memset(&ip_mreq, 0, sizeof ip_mreq);
  ip_mreq.imr_multiaddr.s_addr=inet_addr(GROUP_ADDR);
  ip_mreq.imr_interface.s_addr=inet_addr("127.0.0.1");//htonl(INADDR_ANY);

  memset(&saddr, 0, sizeof saddr);
  saddr.sin_family = AF_INET;
  saddr.sin_port = htons(GROUP_PORT);
  saddr.sin_addr.s_addr = inet_addr("127.0.0.1"); //htonl(INADDR_ANY);

  sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if(sock!=-1) {
    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &s_true, sizeof s_true);
    setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP, &s_false, sizeof s_false);
    setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &ip_mreq, sizeof ip_mreq);
    bind(sock, (struct sockaddr*)&saddr, sizeof saddr);
  }
#endif
  return sock;
}

/*
 * Stupid test if there are any backends registered
 */
short php_java_multicast_backends_available() {
  short has_backend = 0;
#ifndef __MINGW32__
  int sock;
  long s_false=0;
  long s_true=1;
  struct sockaddr_in saddr, saddr2;
  struct ip_mreq ip_mreq;

  memset(&saddr, 0, sizeof saddr);
  ip_mreq.imr_multiaddr.s_addr=inet_addr(GROUP_ADDR);
  ip_mreq.imr_interface.s_addr=inet_addr("127.0.0.1");//htonl(INADDR_ANY);

  memset(&saddr, 0, sizeof saddr);
  saddr.sin_family = AF_INET;
  saddr.sin_port = htons(GROUP_PORT);
  saddr.sin_addr.s_addr = inet_addr("127.0.0.1"); //htonl(INADDR_ANY);

  memset(&saddr2, 0, sizeof saddr);
  saddr2.sin_family = AF_INET;
  saddr2.sin_port = htons(GROUP_PORT);
  saddr2.sin_addr.s_addr = inet_addr(GROUP_ADDR); 

  sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if(sock!=-1) {
	int id, err;
	id=init(); 
	if(id != -1) {
      unsigned char c[1] = {'P'}; /* will be rejected as a broken packet */
	  enter(id);
      /* FIXME: Should protect this from signals.  If someone manages
	   to stop the client in this section, one has to remove the
	   semaphore manually (see commands ipcs -S and ipcrm -S). But
	   since the load balancing code will be rewritten in java anyway
	   (this file, large parts of bind.c and three functions in client
	   will go away) I just keep this hack until the new code is in
	   place */
	  has_backend = 1;
	  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &s_false, sizeof s_false);
	  err=bind(sock, (struct sockaddr*)&saddr, sizeof saddr);
	  if(err!=-1) has_backend = 0;
	  if(has_backend) {
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &s_true, sizeof s_true);
		bind(sock, (struct sockaddr*)&saddr, sizeof saddr);
		err = sendto(sock, c, sizeof c, 0, (struct sockaddr*)&saddr2, sizeof saddr2);
		if(err==-1) {
		  has_backend = 0;
		}
	  }
	  close(sock);
	  leave(id);
	} 
  }
#endif
  return has_backend;
}
  
void php_java_sleep_ms(int ms) {
#ifndef __MINGW32__
  struct timeval timeout = {0, ms*1000};
  select(0, 0, 0, 0, &timeout);
#endif
}

void php_java_send_multicast(int sock, unsigned char spec, time_t time) {
#ifndef __MINGW32__
  unsigned char c[18] = {'R', spec, 0xff & getpid()}; //FIXME: use maxtime here
  struct sockaddr_in saddr;
  if(-1==sock) return;

  writeInt(c+3, (unsigned long)time);
  memset(&saddr, 0, sizeof saddr);
  saddr.sin_family = AF_INET;
  saddr.sin_port = htons(GROUP_PORT);
  saddr.sin_addr.s_addr=inet_addr(GROUP_ADDR);  
  sendto(sock, c, sizeof c, 0, (struct sockaddr*)&saddr, sizeof saddr);
#endif
}

int php_java_recv_multicast(int sock, unsigned char spec, time_t time) {
#ifndef __MINGW32__
  unsigned char c[18];
  int n;
  struct timeval timeout = {0, 30000};// FIXME: round trips in the
									  // local network are usually
									  // below 10 ms, 30ms is too
									  // much.

  fd_set set;
  if(-1==sock) return -1;

  FD_ZERO(&set);
  FD_SET(sock, &set);

  do {
    time_t t;
    n = select(sock+1, &set, 0, 0, &timeout);
    if(n<0) return -1;			/* error */
    if(!n) return -1;			/* timeout */
    n=read(sock, c, sizeof c);
    if(n!=sizeof c) continue;	/* broken packet */
    t=(time_t)readInt(c+3);
    if(t!=time) continue;		/* old packet */
  } while(c[0]!='r' || (spec!=0 && spec!=c[1]));

  return (int)(0xffff & readInt(c+7));
#else
  return -1;
#endif
}

@


1.14
log
@Version 2.0.6 (windows)
@
text
@d38 1
d40 1
a40 1
  semctl(id, 0, IPC_STAT, val);
d43 1
a43 1
    semctl(id, 0, SETVAL, val);
d117 6
a122 3
	enter(id=init()); 
   {/* FIXME: Should protect this from signals.  If someone manages to
	   stop the client in this section, one has to remove the
a127 1
	  unsigned char c[1] = {'P'}; /* will be rejected as a broken packet */
d141 1
a142 1
    leave(id);
@


1.13
log
@multicast fix
@
text
@a12 1
#include <sys/time.h>
d15 1
a16 1
#endif
d20 4
a23 10
#if defined(__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED)
/* union semun is defined by including <sys/sem.h> */
#else
/* according to X/OPEN we have to define it ourselves */
union semun {
  int val;                  /* value for SETVAL */
  struct semid_ds *buf;     /* buffer for IPC_STAT, IPC_SET */
  unsigned short *array;    /* array for GETALL, SETALL */
  /* Linux specific part: */
  struct seminfo *__buf;    /* buffer for IPC_INFO */
a24 1
#endif
d35 1
a35 1
  union semun val;
d56 2
d67 1
d71 1
d91 1
a91 1
  int sock = -1;
d93 1
d95 2
a96 1
  struct sockaddr_in saddr;
d99 1
d103 1
d108 5
d117 9
a125 1
    {
d128 9
a139 1
    if(-1==err) return 1;
d142 1
a142 1
  return 0;
d146 1
d149 1
d151 1
a151 1
  
d159 1
@


1.12
log
@load balancer rewrite part#2 and loop problem fixed
@
text
@d5 4
d21 34
a96 1
  long s_true=1;
d110 5
a114 3
    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &s_false, sizeof s_false);
    setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &ip_mreq, sizeof ip_mreq);
    if(-1==bind(sock, (struct sockaddr*)&saddr, sizeof saddr)) {
d116 3
a118 2
	  return 1;
	}
a119 1
  close(sock);
@


1.11
log
@load balancer rewrite
@
text
@d31 1
d45 1
a45 1
    setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP, &s_true, sizeof s_true);
d73 2
d92 1
a92 1
  unsigned char c[18] = {'R', spec, MAX_LOAD};
d108 5
a112 1
  struct timeval timeout = {0, 1000};
@


1.10
log
@solaris9
@
text
@d51 35
d105 1
a105 1
  struct timeval timeout = {1, 0};
@


1.9
log
@Release-2.0.6pre
@
text
@d70 1
a70 1
  struct timeval timeout = {0, 180};
@


1.8
log
@Solaris 9
@
text
@d70 1
a70 1
  struct timeval timeout = {0, 90};
@


1.7
log
@solaris 9
@
text
@d35 1
a35 1
  ip_mreq.imr_interface.s_addr=htonl("127.0.0.1");//htonl(INADDR_ANY);
d39 1
a39 1
  saddr.sin_addr.s_addr = htonl("127.0.0.1"); //htonl(INADDR_ANY);
@


1.6
log
@solaris 9
@
text
@d70 1
a70 1
  struct timeval timeout = {0, 10};
@


1.5
log
@make multicasts 32 bit clean
@
text
@d35 1
a35 1
  ip_mreq.imr_interface.s_addr=htonl(INADDR_ANY);
d39 1
a39 1
  saddr.sin_addr.s_addr = htonl(INADDR_ANY);
@


1.4
log
@multicast: ignore outdated packets
@
text
@d17 1
a17 1
static int readInt(unsigned char*buf) {
d20 1
a20 1
static void writeInt(unsigned char*buf, int i) {
d52 1
a52 1
void php_java_send_multicast(int sock, unsigned char spec, int time) {
d58 1
a58 1
  writeInt(c+3, time);
d66 1
a66 1
int php_java_recv_multicast(int sock, unsigned char spec, int time) {
d78 1
a78 1
    int t;
d84 1
a84 1
    t=readInt(c+3);
d88 1
a88 1
  return readInt(c+7);
@


1.3
log
@PR1176534: PHP/Java Bridge 2.0.5 does not compile on Solaris, OS X, ...
@
text
@d17 9
a29 1
  int n;
d52 1
a52 1
void php_java_send_multicast(int sock, unsigned char spec) {
d54 1
a54 1
  unsigned char c[14] = {'R', spec, MAX_LOAD};
d58 1
d66 1
a66 4
static int readInt(unsigned char*buf) {
  return (buf[0]&0xFF)<<24|(buf[1]&0xFF)<<16|(buf[2]&0xFF)<<8|(buf[3]&0xFF);
}
int php_java_recv_multicast(int sock, unsigned char spec) {
d68 1
a68 1
  unsigned char c[14];
d70 1
a70 1
  struct timeval time = {0, 10};
d78 8
a85 4
    n = select(sock+1, &set, 0, 0, &time);
    if(n<0) return -1;
    if(!n) return -1;
    read(sock, c, sizeof c);
d88 1
a88 1
  return readInt(c+3);
@


1.2
log
@version
@
text
@d24 1
a24 1
  struct ip_mreqn ip_mreqn;
d26 2
a27 3
  ip_mreqn.imr_multiaddr.s_addr=inet_addr(GROUP_ADDR);
  ip_mreqn.imr_address.s_addr=htonl(INADDR_ANY);
  ip_mreqn.imr_ifindex=0;
d36 2
a37 2
    setsockopt(sock, SOL_IP, IP_MULTICAST_LOOP, &s_true, sizeof s_true);
    setsockopt(sock, SOL_IP, IP_ADD_MEMBERSHIP, &ip_mreqn, sizeof ip_mreqn);
@


1.1
log
@mono
@
text
@d3 1
d13 1
d19 2
d34 1
a34 1
  int sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
d41 1
d46 1
d55 1
d62 1
d77 1
a77 1
  } while(c[0]=='R' || (spec!=0 && spec!=c[1]));
d80 3
@

