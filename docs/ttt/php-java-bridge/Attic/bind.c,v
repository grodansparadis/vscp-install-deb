head	1.94;
access;
symbols
	upstream_version_5_3_4:1.93
	debian_version_5_3_4-1:1.93
	ROOT_Release-5-3-4:1.93
	Release-5-3-4:1.93.0.10
	ROOT_Release-5-3-3:1.93
	Release-5-3-3:1.93.0.6
	debian_version_5_3_2_1_2-1:1.93
	upstream_version_5_3_2_1_2:1.93
	debian_version_5_3_2_1_1-1:1.93
	debian_version_5_3_2_1_1:1.93
	upstream_version_5_3_2_1_1:1.93
	Root_Release-5-3-2-1:1.93
	Release-5-3-2-1:1.93
	ROOT_RELEASE-5-3-2-1:1.93
	RELEASE-5-3-2-1:1.93.0.8
	Release-5-3-2:1.93.0.4
	Root_Release-5-3-2:1.93
	Root_Release-5-3-1:1.93
	Release-5-3-1:1.93.0.2
	Release-5-2-3-1:1.92.0.4
	Root_Release-5-2-3-1:1.92
	Release-5-2-2-4:1.92.0.2
	Root_Release-5-2-2-4:1.92
	Release-5-2-2-1:1.91.0.24
	Root_Release-5-2-2-1:1.91
	upstream_version_5_2_2:1.91
	debian_version_5_2_2-1:1.91
	Release-5-2-2:1.91.0.22
	ROOT_Release-5-2-2:1.91
	ROOT_Release-5-2-1:1.91
	Release-5-2-1:1.91.0.20
	Release-5-2-0:1.91.0.18
	ROOT_Release-5-2-0:1.91
	ROOT_Release-5-1-2:1.91
	Release-5-1-2:1.91.0.16
	Version-5-1-1:1.91.0.14
	ROOT_Version-5-1-1:1.91
	debian_version_5_1_0-1:1.91
	upstream_version_5_1_0:1.91
	ROOT_Release-5-1-0:1.91
	Release-5-1-0:1.91.0.12
	ROOT_Release-5-0-0:1.91
	Release-5-0-0:1.91.0.10
	Release-4-3-3:1.91.0.8
	ROOT_Release-4-3-3:1.91
	upstream_version_4_3_2:1.91
	debian_version_4_3_2-1:1.91
	ROOT_Release-4-3-2:1.91
	Release-4-3-2:1.91.0.6
	Release-4-3-1:1.91.0.4
	ROOT_Release-4-3-1:1.91
	debian_version_4_3_0-1:1.91
	upstream_version_4_3_0:1.91
	ROOT_Release-4-3-0:1.91
	Release-4-3-0:1.91.0.2
	debian_version_3_2_1b-2:1.87
	debian_version_4_2_2-1:1.91
	upstream_version_4_2_2:1.91
	debian_version_3_2_1b-1:1.87
	upstream_version_3_2_1b:1.87
	Release-4-1-2:1.90.0.6
	Release-4-0-8:1.90.0.4
	debian_version_4_0_8a-1:1.90
	upstream_version_4_0_8a:1.90
	jostb-debian-ubuntu-patch:1.90.0.2
	debian_version_4_0_8-1:1.89
	upstream_version_4_0_8:1.89
	debian_version_4_0_7-1:1.88
	upstream_version_4_0_7:1.88
	debian_version_4_0_6-1:1.88
	upstream_version_4_0_6:1.88
	debian_version_4_0_2-1:1.88
	upstream_version_4_0_2:1.88
	Release-4-0-2_Root:1.88
	Release-4-0-2:1.88.0.2
	upstream_version_4_0_1:1.88
	debian_version_4_0_1-2:1.88
	Release-3-2-1:1.87.0.4
	Release-3-1-8:1.87.0.2
	Release-3-0-8_root:1.75.2.1
	Release-3-0-8_Root:1.76
	Release-3-0-8:1.75.0.2
	Release-2-0-8:1.63.0.4
	Release-2-0-7_Root:1.54
	Release-2-0-7:1.54.0.2
	Release-2-0-6-branch:1.48.0.2
	Version-1:1.26.0.6
	Version-2:1.26.0.4
	Release-2:1.26.0.2
	PHP-5:1.9.0.6
	Release-1-0-6:1.10.0.2
	sparc-64-test:1.9.0.2
	V-2004-08-28:1.1.1.1
	PHP-JAVA-BRIDGE:1.1.1;
locks; strict;
comment	@ * @;
expand	@k@;


1.94
date	2008.12.11.21.07.10;	author jost_boekemeier;	state dead;
branches;
next	1.93;

1.93
date	2008.10.03.15.48.13;	author jost_boekemeier;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.24.22.24.40;	author jost2345;	state Exp;
branches;
next	1.91;

1.91
date	2007.07.09.14.35.06;	author jost_boekemeier;	state Exp;
branches;
next	1.90;

1.90
date	2007.04.10.13.30.47;	author jost_boekemeier;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.07.16.22.39;	author jost_boekemeier;	state Exp;
branches;
next	1.88;

1.88
date	2007.03.09.20.28.07;	author andremachado;	state Exp;
branches;
next	1.87;

1.87
date	2006.09.10.17.31.11;	author jost2345;	state Exp;
branches;
next	1.86;

1.86
date	2006.09.05.20.40.32;	author jost2345;	state Exp;
branches;
next	1.85;

1.85
date	2006.08.27.14.40.11;	author jost2345;	state Exp;
branches;
next	1.84;

1.84
date	2006.08.21.17.41.52;	author jost2345;	state Exp;
branches;
next	1.83;

1.83
date	2006.08.08.17.20.45;	author jost2345;	state Exp;
branches;
next	1.82;

1.82
date	2006.07.19.15.25.34;	author jost2345;	state Exp;
branches;
next	1.81;

1.81
date	2006.07.16.20.29.25;	author jost2345;	state Exp;
branches;
next	1.80;

1.80
date	2006.06.22.16.25.44;	author jost2345;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.19.20.37.14;	author jost2345;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.15.19.03.29;	author jost2345;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.04.17.48.13;	author jost2345;	state Exp;
branches;
next	1.76;

1.76
date	2006.04.12.17.46.46;	author jost2345;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.19.14.42.44;	author jost2345;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2006.03.16.20.27.00;	author jost2345;	state Exp;
branches;
next	1.73;

1.73
date	2006.03.07.18.59.27;	author jost2345;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.01.19.31.38;	author jost2345;	state Exp;
branches;
next	1.71;

1.71
date	2006.02.13.18.34.16;	author jost2345;	state Exp;
branches;
next	1.70;

1.70
date	2006.02.03.17.41.36;	author jost2345;	state Exp;
branches;
next	1.69;

1.69
date	2006.01.30.19.39.53;	author jost2345;	state Exp;
branches;
next	1.68;

1.68
date	2006.01.16.19.00.10;	author jost2345;	state Exp;
branches;
next	1.67;

1.67
date	2006.01.08.23.44.40;	author jost2345;	state Exp;
branches;
next	1.66;

1.66
date	2005.12.18.18.17.48;	author jost2345;	state Exp;
branches;
next	1.65;

1.65
date	2005.12.11.22.24.40;	author jost2345;	state Exp;
branches;
next	1.64;

1.64
date	2005.12.08.18.41.56;	author jost2345;	state Exp;
branches;
next	1.63;

1.63
date	2005.09.07.21.13.45;	author jost2345;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.23.18.39.30;	author jost2345;	state Exp;
branches;
next	1.61;

1.61
date	2005.08.23.18.20.56;	author jost2345;	state Exp;
branches;
next	1.60;

1.60
date	2005.08.21.11.39.39;	author jost2345;	state Exp;
branches;
next	1.59;

1.59
date	2005.08.18.18.31.39;	author jost2345;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.11.18.08.16;	author jost2345;	state Exp;
branches;
next	1.57;

1.57
date	2005.08.01.16.56.55;	author jost2345;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.25.20.42.27;	author jost2345;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.17.13.46.23;	author jost2345;	state Exp;
branches;
next	1.54;

1.54
date	2005.07.08.17.57.22;	author jost2345;	state Exp;
branches;
next	1.53;

1.53
date	2005.07.01.17.39.05;	author jost2345;	state Exp;
branches;
next	1.52;

1.52
date	2005.06.27.23.13.11;	author jost2345;	state Exp;
branches;
next	1.51;

1.51
date	2005.06.21.20.17.29;	author jost2345;	state Exp;
branches;
next	1.50;

1.50
date	2005.06.19.20.45.40;	author jost2345;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.15.15.18.02;	author jost2345;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.15.20.17.35;	author jost2345;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.14.15.41.46;	author jost2345;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.12.19.11.28;	author jost2345;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.11.17.28.48;	author jost2345;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.01.18.29.35;	author jost2345;	state Exp;
branches;
next	1.43;

1.43
date	2005.04.30.14.47.02;	author jost2345;	state Exp;
branches;
next	1.42;

1.42
date	2005.04.28.17.05.51;	author jost2345;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.27.18.31.58;	author jost2345;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.27.18.23.46;	author jost2345;	state Exp;
branches;
next	1.39;

1.39
date	2005.04.24.17.25.52;	author jost2345;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.23.16.04.26;	author jost2345;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.18.16.46.33;	author jost2345;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.17.21.01.21;	author jost2345;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.27.15.45.45;	author jost2345;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.11.17.34.18;	author jost2345;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.07.19.36.44;	author jost2345;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.05.14.55.38;	author jost2345;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.21.17.53.14;	author jost2345;	state Exp;
branches;
next	1.30;

1.30
date	2005.02.20.12.19.44;	author jost2345;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.19.13.29.25;	author jost2345;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.15.19.10.27;	author jost2345;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.13.21.43.28;	author jost2345;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.29.17.29.16;	author jost2345;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.29.10.09.33;	author jost2345;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.28.17.18.08;	author jost2345;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.28.17.17.39;	author jost2345;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.28.17.16.50;	author jost2345;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.28.16.32.52;	author jost2345;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.02.17.45.12;	author jost2345;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.02.17.13.48;	author jost2345;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.02.14.02.10;	author jost2345;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.12.09.57.25;	author jost2345;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.03.18.35.21;	author jost2345;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.01.20.29.56;	author jost2345;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.29.16.14.33;	author jost2345;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.28.21.12.57;	author jost2345;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.19.16.54.33;	author jost2345;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.16.23.28.17;	author jost2345;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.31.17.08.13;	author jost2345;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.06.16.37.59;	author jost2345;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.04.16.42.50;	author jost2345;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.04.16.27.24;	author jost2345;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.23.13.12.44;	author jost2345;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.22.19.17.48;	author jost2345;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.19.18.45.13;	author jost2345;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.17.19.11.55;	author jost2345;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.10.13.23.50;	author jost2345;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.28.06.05.55;	author jost2345;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.08.28.06.05.55;	author jost2345;	state Exp;
branches;
next	;

1.75.2.1
date	2006.04.23.19.09.08;	author jost2345;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	2006.05.13.16.09.57;	author jost2345;	state Exp;
branches;
next	;


desc
@@


1.94
log
@java autostart removed
@
text
@/*-*- mode: C; tab-width:4 -*-*/

/* bind.c -- create and connect to the PHP/Java Bridge back end.

  Copyright (C) 2003-2007 Jost Boekemeier

  This file is part of the PHP/Java Bridge.

  The PHP/Java Bridge ("the library") is free software; you can
  redistribute it and/or modify it under the terms of the GNU General
  Public License as published by the Free Software Foundation; either
  version 2, or (at your option) any later version.

  The library is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with the PHP/Java Bridge; see the file COPYING.  If not, write to the
  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307 USA.

  Linking this file statically or dynamically with other modules is
  making a combined work based on this library.  Thus, the terms and
  conditions of the GNU General Public License cover the whole
  combination.

  As a special exception, the copyright holders of this library give you
  permission to link this library with independent modules to produce an
  executable, regardless of the license terms of these independent
  modules, and to copy and distribute the resulting executable under
  terms of your choice, provided that you also meet, for each linked
  independent module, the terms and conditions of the license of that
  module.  An independent module is a module which is not derived from
  or based on this library.  If you modify this library, you may extend
  this exception to your version of the library, but you are not
  obligated to do so.  If you do not wish to do so, delete this
  exception statement from your version. */

#include "php_java.h"

/* execve,select */
#ifndef __MINGW32__
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
#endif

/* stat, mkdir */
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

/* opendir */
#ifndef __MINGW32__
#include <dirent.h>
#endif

/* fcntl */
#include <fcntl.h>

/* strings */
#include <string.h>
/* setenv */
#include <stdlib.h>

/* signal */
#include <signal.h>

/* poll */
#ifdef HAVE_SYS_POLL_H
#include <sys/poll.h>
#endif

/* wait */
#include <sys/wait.h>

/* miscellaneous */
#include <stdio.h>
#include <errno.h>
#include <time.h>

/* path separator */
#include "php_wrapper.h"
#include "zend.h"

#include "java_bridge.h"
#include "init_cfg.h"

#ifndef EXTENSION_DIR
#error EXTENSION_DIR must point to the PHP extension directory
#endif

const static char servlet_socket_prefix[]="SERVLET_LOCAL:";
const static char inet_socket_prefix[]="INET_LOCAL:";
const static char local_socket_prefix[]="LOCAL:";
const static char ext_dir[] = "extension_dir";

EXT_EXTERN_MODULE_GLOBALS(EXT)

static short use_wrapper(char*wrapper) {
  struct stat buf;
  short use_wrapper=(EXT_GLOBAL(option_set_by_user) (U_WRAPPER, EXT_GLOBAL(ini_user)));
  if(use_wrapper) return use_wrapper;
#ifndef __MINGW32__
  /* do not change privileges when we are not running as root.
	 The RunJavaBridge and RunMonoBridge contains a similar test */
  if(getuid()) return 0;
  if(!stat(wrapper, &buf) && (S_IFREG&buf.st_mode)) {
	if(getuid()==buf.st_uid)
	  use_wrapper=(S_IXUSR&buf.st_mode);
	else if(getgid()==buf.st_gid)
	  use_wrapper=(S_IXGRP&buf.st_mode);
	else 
	  use_wrapper=(S_IXOTH&buf.st_mode);
  }
#endif
  return use_wrapper;
}
/**
 * Check if the file ext_dir/javabridge.policy exists
 * and return an allocated string containing s+ext_dir/javabridge.policy
 * or NULL.
 * @@param s The prefix, for example "java.security.policy="
 */
static char *check_policy(char *s) {
  struct stat buf;
  short use_policy = 0;
  char *p = 0;
#ifndef __MINGW32__
  const static char bridge[]="/javabridge.policy";
  char *slash, *ext= php_ini_string((char*)ext_dir, sizeof ext_dir, 0);
  size_t slen = strlen(s);
  p=malloc(slen+strlen(ext)+sizeof(bridge)); if(!p) return 0;
  strcpy(p, s); strcat(p, ext);
  slash=p+strlen(p)-1; 	if(*p&&(*slash=='/'||*slash=='\\')) *slash=0;
  strcat(p, bridge);
  /* check if it exists */
  if(!stat(p+slen, &buf) && (S_IFREG&buf.st_mode)) {
	if(getuid()==buf.st_uid)
	  use_policy=(S_IRUSR&buf.st_mode);
	else if(getgid()==buf.st_gid)
	  use_policy=(S_IRGRP&buf.st_mode);
	else 
	  use_policy=(S_IROTH&buf.st_mode);
  }
  if(!use_policy) { free(p); p=0; }
#endif
  return p;
}

/* Windows can handle slashes as well as backslashes so use / everywhere */
static const char path_separator[2] = {ZEND_PATHS_SEPARATOR, 0};
static const char bridge_base[] = "-Dphp.java.bridge.base=";
#if EXTENSION == JAVA
static void EXT_GLOBAL(get_server_args)(char*env[N_SENV], char*args[N_SARGS], short for_display TSRMLS_DC) {
  char *s, *p;
  char*program=EXT_GLOBAL(cfg)->vm;
  char*cp=EXT_GLOBAL(cfg)->classpath;
  char*lib_path=EXT_GLOBAL(cfg)->ld_library_path;
  char*sys_libpath=getenv("LD_LIBRARY_PATH");
  char*home=EXT_GLOBAL(cfg)->vm_home;
  char *ext = php_ini_string((char*)ext_dir, sizeof ext_dir, 0);
  const char* s_prefix = inet_socket_prefix;
  short any_port = 1;			/* let back-end select the port# */
  if(!JG(java_socket_inet)) {
	s_prefix = local_socket_prefix;
	any_port = 0; //for_display
  }
  char *sockname, *cfg_sockname=EXT_GLOBAL(get_sockname)(TSRMLS_C), *cfg_logFile=EXT_GLOBAL(cfg)->logFile;

  /* if socketname is off, show the user how to start a TCP backend */
  if(any_port && !(EXT_GLOBAL(option_set_by_user) (U_SOCKNAME, EXT_GLOBAL(ini_user)))) {
	if(EXT_GLOBAL(option_set_by_user)(U_SERVLET, JG(ini_user))) {
	  static const char default_port[] = "8080";
	  char *s = JG(hosts);
	  char *p = s ? strpbrk(s, "; ") : 0; if(p) *p=0;
	  p = s ? strchr(s, ':') : 0;
	  if(p) p++;
	  cfg_sockname = p ? p : (char*)default_port;
	  s_prefix=servlet_socket_prefix;
	} else {
	  cfg_sockname="0";
	  s_prefix=inet_socket_prefix;
	  //cfg_logFile="";
	}
  }
  /* send a prefix so that the server does not select a different
   protocol */
  sockname = malloc(strlen(s_prefix)+strlen(cfg_sockname)+1);
  strcpy(sockname, s_prefix);
  strcat(sockname, cfg_sockname);

								/* library path usually points to the
								   extension dir */
  if(!(EXT_GLOBAL(option_set_by_user) (U_LIBRARY_PATH, EXT_GLOBAL(ini_user)))) {	/* look into extension_dir then */
	if(ext) lib_path = ext;
  }
  if(!*program) {				/* look into extension_dir then */
	static const char java[] = "/java";
	if(ext) {
	  program = malloc(strlen(ext)+sizeof(java)); assert(program); if(!program) exit(6);
	  strcpy(program, ext); strcat(program, java);
	} else {
	  program = strdup(program);
	}
  } else {
	program = strdup(program);
  }
  
  if(!sys_libpath) sys_libpath="";
  args[0]=program;
  s="-Djava.library.path=";
  p=malloc(strlen(s)+strlen(lib_path)+1);
  strcpy(p, s); strcat(p, lib_path);
  args[1] = p;					/* library path */
  s="-Djava.class.path=";
								/* library path usually points to the
								   extension dir */
  if(ext && !(EXT_GLOBAL(option_set_by_user) (U_CLASSPATH, EXT_GLOBAL(ini_user)))) {	/* look into extension_dir then */
	static char bridge[]="/JavaBridge.jar";
	char *slash;
	p=malloc(strlen(s)+strlen(ext)+sizeof(bridge));
	strcpy(p, s); strcat(p, ext); 
	slash=p+strlen(p)-1;
	if(*p&&(*slash=='/'||*slash=='\\')) *slash=0;
	strcat(p, bridge);
  } else {
	p=malloc(strlen(s)+strlen(cp)+1);
	strcpy(p, s); strcat(p, cp);
  }
  args[2] = p;					/* user classes */

  /* policy */
  s="-Djava.security.policy=="; p=0;
  if(!p && EXT_GLOBAL(option_set_by_user) (U_POLICY, EXT_GLOBAL(ini_user))) {
	char *cp = EXT_GLOBAL(cfg)->policy;
	if(*cp==0||cp[1]==0) {		/* policy=On (stored as '\0' or '1\0') */
	  p = check_policy(s);
	} else {
	  p=malloc(strlen(s)+strlen(cp)+1);
	  strcpy(p, s); strcat(p, cp);
	}
  }
  if(!p) {					/* no policy at all */
	p = strdup("-Djava.awt.headless=true");
  }
  args[3] = p;

								/* base */
  p = malloc(strlen(ext)+sizeof(bridge_base));
  strcpy(p, bridge_base); strcat(p, ext);
  args[4] = p;

  args[5] = strdup("php.java.bridge.Standalone");
  args[6] = sockname;
  args[7] = strdup(EXT_GLOBAL(cfg)->logLevel);
  args[8] = strdup(cfg_logFile);
  args[9] = NULL;

  if(*home) {					/* set VM home */
	s="JAVA_HOME=";
	p=malloc(strlen(s)+strlen(home)+1);
	strcpy(p, s); strcat(p, home);
	env[0] = p;
  } else {						/* VM in PATH; don't set java home */
	env[0] = strdup("");
  }

  s="LD_LIBRARY_PATH=";
  p=malloc(strlen(s)+strlen(lib_path)+1+strlen(sys_libpath)+1);
  strcpy(p, s); strcat(p, lib_path); 
  strcat(p, path_separator); strcat(p, sys_libpath);
  env[1] = p;					/* library path */
  env[2] = NULL;
}
#elif EXTENSION == MONO
static void EXT_GLOBAL(get_server_args)(char*env[N_SENV], char*args[N_SARGS], short for_display TSRMLS_DC) {
  static const char executable[] = "/MonoBridge.exe";
  char *p, *slash;
  char*program=EXT_GLOBAL(cfg)->vm;
  const char* s_prefix = inet_socket_prefix;
  short any_port = 1;			/* let back-end select the port# */
  char *sockname, *cfg_sockname=EXT_GLOBAL(get_sockname)(TSRMLS_C), *cfg_logFile=EXT_GLOBAL(cfg)->logFile;
  char*home = EXT_GLOBAL(cfg)->vm_home;
  if(!JG(java_socket_inet)) {
	s_prefix = local_socket_prefix;
	any_port = 0; //for_display
  }
  if(!(EXT_GLOBAL(option_set_by_user) (U_JAVA_HOME, EXT_GLOBAL(ini_user)))) {	/* look into extension_dir then */
	char *ext = php_ini_string((char*)ext_dir, sizeof ext_dir, 0);
	if(ext) home = ext;
  }
  args[0]=strdup(program);		/* mono */
  p=malloc(strlen(home)+sizeof executable);
  strcpy(p, home); 
  slash=p+strlen(p)-1;
  if(*p&&(*slash=='/'||*slash=='\\')) *slash=0;
  strcat(p, executable);

  args[1] = p;
  /* if socketname is off, show the user how to start a TCP backend */
  if(any_port && !(EXT_GLOBAL(option_set_by_user) (U_SOCKNAME, EXT_GLOBAL(ini_user)))) {
	cfg_sockname="0";
	s_prefix=inet_socket_prefix;
	//cfg_logFile="";
  }
  /* send a prefix so that the server does not select a different */
  /* channel */
  sockname = malloc(strlen(s_prefix)+strlen(cfg_sockname)+1);
  strcpy(sockname, s_prefix);
  strcat(sockname, cfg_sockname);
  args[2] = sockname;
  args[3] = strdup(EXT_GLOBAL(cfg)->logLevel);
  args[4] = strdup(cfg_logFile);
  args[5] = NULL;
  env[0] = NULL;
}
#endif
  
/*
 * Get a string of the server arguments. Useful for display only.
 */
static char*get_server_string(short for_display TSRMLS_DC) {
  short must_use_wrapper = use_wrapper(EXT_GLOBAL(cfg)->wrapper);
  int i;
  char*s;
  char*env[N_SENV];
  char*args[N_SARGS];
  unsigned int length = 0;

  EXT_GLOBAL(get_server_args)(env, args, for_display TSRMLS_CC);
  if(must_use_wrapper)
	length+=strlen(EXT_GLOBAL(cfg)->wrapper)+1;
#ifndef __MINGW32__
  for(i=0; i< (sizeof env)/(sizeof*env); i++) {
	if(!env[i]) break;
	length+=strlen(env[i])+1;
  }
#endif
  for(i=0; i< (sizeof args)/(sizeof*args); i++) {
	size_t l;
	if(!args[i]) break;
	l=strlen(args[i]);
	length+=(l?l:2)+1;
  }
  s=malloc(length+1);
  assert(s); if(!s) exit(9);

  *s=0;
#ifndef __MINGW32__
  for(i=0; i< (sizeof env)/(sizeof*env); i++) {
	if(!env[i]) break;
	strcat(s, env[i]); strcat(s, " ");
	free(env[i]);
  }
#endif
  if(must_use_wrapper) {
	strcat(s, EXT_GLOBAL(cfg)->wrapper);
	strcat(s, " ");
  }
  for(i=0; i< (sizeof args)/(sizeof*args); i++) {
	if(!args[i]) break;
	strcat(s, args[i]);
	strcat(s, " ");
	free(args[i]);
  }
  s[length]=0;
  return s;
}
char*EXT_GLOBAL(get_server_string)(TSRMLS_D) {
  return get_server_string(1 TSRMLS_CC);
}

static void exec_vm(TSRMLS_D) {
  int i, n;
  static char*env[N_SENV];
  static char*_args[N_SARGS+1];
  char **args=_args+1, *cmd;
  EXT_GLOBAL(get_server_args)(env, args, 0 TSRMLS_CC);
  if(N_SENV>2) {
	if(*env[0]) putenv(env[0]);
	if(*env[1]) putenv(env[1]);
  }
  for(i=3, n=dup(1); i<=n; i++) close(i);
  if(use_wrapper(EXT_GLOBAL(cfg)->wrapper)) {
	*--args = strdup(EXT_GLOBAL(cfg)->wrapper);
	execv(args[0], args);
  }
  if(*args[0]=='/') execv(args[0], args); else execvp(args[0], args);

#if EXTENSION == JAVA
  execvp("java", args);
#elif EXTENSION == MONO
  execvp("mono", args);
#endif

  /* exec failed */
  cmd = get_server_string(0 TSRMLS_CC);
  php_error(E_WARNING, "php_mod_"/**/EXT_NAME()/**/"(%d) system error: Could not execute backend: %s: %s", 105, cmd, strerror(errno));
  free(cmd);
}

static const int is_true = 1;
static int test_local_server(TSRMLS_D) {
  int sock, n;
  if(!JG(java_socket_inet)) {
#ifndef CFG_JAVA_SOCKET_INET
	sock = socket (PF_LOCAL, SOCK_STREAM, 0);
#endif
  } else {
	sock = socket (PF_INET, SOCK_STREAM, 0);
	if(sock!=-1) setsockopt(sock, 0x6, TCP_NODELAY, (void*)&is_true, sizeof is_true);
  }
  if(sock==-1) return -1;
  if(JG(java_socket_inet)) {
	n = connect(sock,(struct sockaddr*)&EXT_GLOBAL(cfg)->saddr.in, sizeof EXT_GLOBAL(cfg)->saddr.in);
  } else {
#ifndef CFG_JAVA_SOCKET_INET
	n = connect(sock,(struct sockaddr*)&EXT_GLOBAL(cfg)->saddr.un, sizeof EXT_GLOBAL(cfg)->saddr.un);
#endif
  }
  if(n==-1) { close(sock); return -1; }
  return sock;
}

/*
 * return 0 if user has hard-coded the socketname or if
 * X_JAVABRIDGE_OVERRIDE_HOSTS_REDIRECT is set at run-time.
 */
static short can_fork(TSRMLS_D) {
  return EXT_GLOBAL(cfg)->can_fork && !(EXT_GLOBAL(option_set_by_user) (U_SERVLET, JG(ini_user)));
}

short EXT_GLOBAL(can_fork)(TSRMLS_D) {
  return can_fork(TSRMLS_C);
}

/*
 * Test for a running server.  Return the server name and the socket
 * if _socket!=NULL. If all ckecks fail a local backend is started.
 */
char* EXT_GLOBAL(test_server)(int *_socket, short *local, struct sockaddr*_saddr TSRMLS_DC) {
  int sock;
  short called_from_init = !(local || _socket);

								/* java.servlet=On forces
								   java.socketname Off */
  short socketname_set = EXT_GLOBAL(cfg)->socketname_set &&
	EXT_GLOBAL(option_set_by_user) (U_SOCKNAME, JG(ini_user)) &&
	!(EXT_GLOBAL(option_set_by_user) (U_SERVLET, JG(ini_user)));

  if(local) *local=0;
  /* check for local server if socketname set or (socketname not set
	 and hosts not set), in which case we may have started a local
	 backend ourselfs. Do not check if socketname not set and we are
	 called from init, in which case we know that a local backend is
	 not running. */
  if (((socketname_set || can_fork(TSRMLS_C)) && (socketname_set || !called_from_init))
	  && -1!=(sock=test_local_server(TSRMLS_C)) ) {
	if(_socket) {
	  *_socket=sock;
	} else {
	  close(sock);
	}
	if(local) *local=1;
	return strdup(EXT_GLOBAL(get_sockname)(TSRMLS_C));
  }

  /* host list */
  if(JG(hosts) && *(JG(hosts))) {
	char *host, *hosts = strdup(JG(hosts));
	
	assert(hosts); if(!hosts) return 0;
	for(host=strtok(hosts, "; "); host; host=strtok(0, "; ")) {
	  struct sockaddr_in saddr;
	  char *_port = strrchr(host, ':'), *ret;
	  int port = 0;
	  
	  if(_port) { 
		*_port++=0;
		if(strlen(_port)) port=atoi(_port);
	  }
	  if(!port) port=atoi(DEFAULT_PORT);
	  memset(&saddr, 0, sizeof saddr);
	  saddr.sin_family = AF_INET;
	  saddr.sin_port=htons(port);
#ifndef __MINGW32__
	  if(!isdigit(*host)) {
		struct hostent *hostent = gethostbyname(host);
		if(hostent) {
		  memcpy(&saddr.sin_addr,hostent->h_addr,sizeof(struct in_addr));
		} else {
		  inet_aton(host, &saddr.sin_addr);
		}
	  } else {
		inet_aton(host, &saddr.sin_addr);
	  }
#else
	  saddr.sin_addr.s_addr = inet_addr(host);
#endif

	  sock = socket (PF_INET, SOCK_STREAM, 0);
	  if(-1==sock) continue;
	  if (-1==connect(sock,(struct sockaddr*)&saddr, sizeof (struct sockaddr))) {
		close(sock);
		continue;
	  }
	  if(_socket) {
		*_socket=sock;
		setsockopt(sock, 0x6, TCP_NODELAY, (void*)&is_true, sizeof is_true);
	  }
	  else close(sock);
	  if(_port) _port[-1]=':';
	  ret = strdup(host);
	  free(hosts);
	  if(_saddr) memcpy(_saddr, &saddr, sizeof (struct sockaddr));
	  if(EXT_GLOBAL(cfg)->socketname_set)
		EXT_GLOBAL(cfg)->socketname_set = 0;
	  return ret;
	}
	free(hosts);
  }

  socketname_set = EXT_GLOBAL(option_set_by_user) (U_SOCKNAME, JG(ini_user)) ;
  if (((socketname_set || can_fork(TSRMLS_C)) && (socketname_set || !called_from_init))
	  && -1!=(sock=test_local_server(TSRMLS_C)) ) {
	if(_socket) {
	  *_socket=sock;
	} else {
	  close(sock);
	}
	if(local) *local=1;
	if(!EXT_GLOBAL(cfg)->socketname_set)
	  EXT_GLOBAL(cfg)->socketname_set = 1;
	return strdup(EXT_GLOBAL(get_sockname)(TSRMLS_C));
  }

  return 0;
}
static const long timeout = 50000l; /* ys */
static void sleep_ms() {
  struct timeval timeval = {0l, timeout};
  select(0, 0, 0, 0, &timeval);
}
static int wait_server(TSRMLS_D) {
#ifndef __MINGW32__ 
  static const int wait_count = 30;
  int count=wait_count, sock;

#ifdef HAVE_POLL /* some ancient OS (Darwin, OSX) don't have poll */
  struct pollfd pollfd[1] = {{EXT_GLOBAL(cfg)->err, POLLIN, 0}};
#endif
  
  /* wait for the server that has just started */
  while(EXT_GLOBAL(cfg)->cid && -1==(sock=test_local_server(TSRMLS_C)) && --count) {
#ifdef HAVE_POLL
	if(EXT_GLOBAL(cfg)->err && poll(pollfd, 1, 0)) 
	  return FAILURE; /* server terminated with error code */
#endif
	sleep_ms();
  }
  count=30;
  while(EXT_GLOBAL(cfg)->cid && -1==sock && -1==(sock=test_local_server(TSRMLS_C)) && --count) {
#ifdef HAVE_POLL
	if(EXT_GLOBAL(cfg)->err && poll(pollfd, 1, 0)) 
	  return FAILURE; /* server terminated with error code */
#endif
	php_error(E_NOTICE, "php_mod_"/**/EXT_NAME()/**/"(%d): waiting for server another %d seconds",57, count);
	sleep(1);
  }
#else
  static const int wait_count = 5;
  int count=wait_count, sock;
  while(EXT_GLOBAL(cfg)->cid && -1==(sock=test_local_server(TSRMLS_C)) && --count) {
	Sleep(500);
  }
  count=15;
  while(EXT_GLOBAL(cfg)->cid && -1==sock && -1==(sock=test_local_server(TSRMLS_C)) && --count) {
	php_error(E_NOTICE, "php_mod_"/**/EXT_NAME()/**/"(%d): waiting for server another %d interval",57, count);
	Sleep(500);
  }
#endif
  if(EXT_GLOBAL(cfg)->cid && count) {
	close(sock);
	return SUCCESS;
  } else {
	return FAILURE;
  }
}


/* handle keyboard interrupt */
#ifndef __MINGW32__
static int s_pid=0;
static void s_kill(int sig) {
  if(s_pid) kill(s_pid, SIGTERM);
}
#else
#ifndef _WIN32_WINNT
# define _WIN32_WINNT 0x500
#endif

#include <windows.h>
#include <tchar.h>
#include <stdarg.h>
#include <tlhelp32.h>

static struct s_pid {
  short use_wrapper;
  PROCESS_INFORMATION p;
} s_pid;



/**
 * Unix kill emulation for windows.
 * From http://www.rsdn.ru/?qna/?baseserv/killproc.xml
 */
static BOOL WINAPI KillProcess(IN DWORD dwProcessId)
{
  HANDLE hProcess;
  DWORD dwError;

  // first try to obtain handle to the process without the use of any
  // additional privileges
  hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, dwProcessId);
  if (hProcess == NULL)
    {
      if (GetLastError() != ERROR_ACCESS_DENIED)
		return FALSE;

      OSVERSIONINFO osvi;

      // determine operating system version
      osvi.dwOSVersionInfoSize = sizeof(osvi);
      GetVersionEx(&osvi);

      // we cannot do anything else if this is not Windows NT
      if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT)
		return FALSE;

      // enable SE_DEBUG_NAME privilege and try again

      TOKEN_PRIVILEGES Priv, PrivOld;
      DWORD cbPriv = sizeof(PrivOld);
      HANDLE hToken;

      // obtain the token of the current thread 
      if (!OpenThreadToken(GetCurrentThread(), 
						   TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,
						   FALSE, &hToken))
		{
		  if (GetLastError() != ERROR_NO_TOKEN)
			return FALSE;

		  // revert to the process token
		  if (!OpenProcessToken(GetCurrentProcess(),
								TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,
								&hToken))
			return FALSE;
		}

      assert(ANYSIZE_ARRAY > 0);

      Priv.PrivilegeCount = 1;
      Priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
      LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &Priv.Privileges[0].Luid);

      // try to enable the privilege
      if (!AdjustTokenPrivileges(hToken, FALSE, &Priv, sizeof(Priv),
								 &PrivOld, &cbPriv))
		{
		  dwError = GetLastError();
		  CloseHandle(hToken);
		  return FALSE;
		}

      if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
		{
		  // the SE_DEBUG_NAME privilege is not present in the caller's
		  // token
		  CloseHandle(hToken);
		  return FALSE;
		}

      // try to open process handle again
      hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, dwProcessId);
      dwError = GetLastError();
		
      // restore the original state of the privilege
      AdjustTokenPrivileges(hToken, FALSE, &PrivOld, sizeof(PrivOld),
							NULL, NULL);
      CloseHandle(hToken);

      if (hProcess == NULL)
		return FALSE;
    }

  // terminate the process
  if (!TerminateProcess(hProcess, (UINT)-1))
    {
      dwError = GetLastError();
      CloseHandle(hProcess);
      return FALSE;
    }

  CloseHandle(hProcess);

  // completed successfully
  return TRUE;
}

typedef LONG	NTSTATUS;
typedef LONG	KPRIORITY;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

#define SystemProcessesAndThreadsInformation	5

typedef struct _CLIENT_ID {
  DWORD	    UniqueProcess;
  DWORD	    UniqueThread;
} CLIENT_ID;

typedef struct _UNICODE_STRING {
  USHORT	    Length;
  USHORT	    MaximumLength;
  PWSTR	    Buffer;
} UNICODE_STRING;

typedef struct _VM_COUNTERS {
  SIZE_T	    PeakVirtualSize;
  SIZE_T	    VirtualSize;
  ULONG	    PageFaultCount;
  SIZE_T	    PeakWorkingSetSize;
  SIZE_T	    WorkingSetSize;
  SIZE_T	    QuotaPeakPagedPoolUsage;
  SIZE_T	    QuotaPagedPoolUsage;
  SIZE_T	    QuotaPeakNonPagedPoolUsage;
  SIZE_T	    QuotaNonPagedPoolUsage;
  SIZE_T	    PagefileUsage;
  SIZE_T	    PeakPagefileUsage;
} VM_COUNTERS;

typedef struct _SYSTEM_THREADS {
  LARGE_INTEGER   KernelTime;
  LARGE_INTEGER   UserTime;
  LARGE_INTEGER   CreateTime;
  ULONG			WaitTime;
  PVOID			StartAddress;
  CLIENT_ID	    ClientId;
  KPRIORITY	    Priority;
  KPRIORITY	    BasePriority;
  ULONG			ContextSwitchCount;
  LONG			State;
  LONG			WaitReason;
} SYSTEM_THREADS, * PSYSTEM_THREADS;

// Note that the size of the SYSTEM_PROCESSES structure is different on
// NT 4 and Win2K, but we don't care about it, since we don't access neither
// IoCounters member nor Threads array

typedef struct _SYSTEM_PROCESSES {
  ULONG			NextEntryDelta;
  ULONG			ThreadCount;
  ULONG			Reserved1[6];
  LARGE_INTEGER   CreateTime;
  LARGE_INTEGER   UserTime;
  LARGE_INTEGER   KernelTime;
  UNICODE_STRING  ProcessName;
  KPRIORITY	    BasePriority;
  ULONG			ProcessId;
  ULONG			InheritedFromProcessId;
  ULONG			HandleCount;
  ULONG			Reserved2[2];
  VM_COUNTERS	    VmCounters;
#if _WIN32_WINNT >= 0x500
  IO_COUNTERS	    IoCounters;
#endif
  SYSTEM_THREADS  Threads[1];
} SYSTEM_PROCESSES, * PSYSTEM_PROCESSES;

static BOOL WINAPI KillProcessTreeNtHelper(IN PSYSTEM_PROCESSES pInfo, IN DWORD dwProcessId)
{
  assert(pInfo != NULL);

  PSYSTEM_PROCESSES p = pInfo;

  // kill all children first
  for (;;)
    {
      if (p->InheritedFromProcessId == dwProcessId)
		KillProcessTreeNtHelper(pInfo, p->ProcessId);

      if (p->NextEntryDelta == 0)
		break;

      // find the address of the next process structure
      p = (PSYSTEM_PROCESSES)(((LPBYTE)p) + p->NextEntryDelta);
    }

  // kill the process itself
  if (!KillProcess(dwProcessId))
    return GetLastError();

  return ERROR_SUCCESS;
}

static BOOL WINAPI KillProcessTreeWinHelper(IN DWORD dwProcessId)
{
  HINSTANCE hKernel;
  HANDLE (WINAPI * _CreateToolhelp32Snapshot)(DWORD, DWORD);
  BOOL (WINAPI * _Process32First)(HANDLE, PROCESSENTRY32 *);
  BOOL (WINAPI * _Process32Next)(HANDLE, PROCESSENTRY32 *);

  // get handle to KERNEL32.DLL
  hKernel = GetModuleHandle(_T("kernel32.dll"));
  assert(hKernel != NULL);

  // locate necessary functions in KERNEL32.DLL
  *(FARPROC *)&_CreateToolhelp32Snapshot =
    GetProcAddress(hKernel, "CreateToolhelp32Snapshot");
  *(FARPROC *)&_Process32First =
    GetProcAddress(hKernel, "Process32First");
  *(FARPROC *)&_Process32Next =
    GetProcAddress(hKernel, "Process32Next");

  if (_CreateToolhelp32Snapshot == NULL ||
      _Process32First == NULL ||
      _Process32Next == NULL)
    return ERROR_PROC_NOT_FOUND;

  HANDLE hSnapshot;
  PROCESSENTRY32 Entry;

  // create a snapshot
  hSnapshot = _CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (hSnapshot == INVALID_HANDLE_VALUE)
    return GetLastError();

  Entry.dwSize = sizeof(Entry);
  if (!_Process32First(hSnapshot, &Entry))
    {
      DWORD dwError = GetLastError();
      CloseHandle(hSnapshot);
      return dwError;
    }

  // kill all children first
  do
    {
      if (Entry.th32ParentProcessID == dwProcessId)
		KillProcessTreeWinHelper(Entry.th32ProcessID);

      Entry.dwSize = sizeof(Entry);
    }
  while (_Process32Next(hSnapshot, &Entry));

  CloseHandle(hSnapshot);

  // kill the process itself
  if (!KillProcess(dwProcessId))
    return GetLastError();

  return ERROR_SUCCESS;
}

static BOOL WINAPI KillProcessEx(IN DWORD dwProcessId, IN BOOL bTree)
{
  if (!bTree)
    return KillProcess(dwProcessId);

  OSVERSIONINFO osvi;
  DWORD dwError;

  // determine operating system version
  osvi.dwOSVersionInfoSize = sizeof(osvi);
  GetVersionEx(&osvi);

  if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
      osvi.dwMajorVersion < 5)
    {
      HINSTANCE hNtDll;
      NTSTATUS (WINAPI * _ZwQuerySystemInformation)(UINT, PVOID, ULONG, PULONG);

      // get handle to NTDLL.DLL
      hNtDll = GetModuleHandle(_T("ntdll.dll"));
      assert(hNtDll != NULL);

      // find the address of ZwQuerySystemInformation
      *(FARPROC *)&_ZwQuerySystemInformation =
		GetProcAddress(hNtDll, "ZwQuerySystemInformation");
      if (_ZwQuerySystemInformation == NULL)
		return FALSE;

      // obtain a handle to the default process heap
      HANDLE hHeap = GetProcessHeap();
    
      NTSTATUS Status;
      ULONG cbBuffer = 0x8000;
      PVOID pBuffer = NULL;

      // it is difficult to say a priory which size of the buffer 
      // will be enough to retrieve all information, so we start
      // with 32K buffer and increase its size until we get the
      // information successfully
      do
		{
		  pBuffer = HeapAlloc(hHeap, 0, cbBuffer);
		  if (pBuffer == NULL)
			return FALSE;

		  Status = _ZwQuerySystemInformation(
											 SystemProcessesAndThreadsInformation,
											 pBuffer, cbBuffer, NULL);

		  if (Status == STATUS_INFO_LENGTH_MISMATCH)
			{
			  HeapFree(hHeap, 0, pBuffer);
			  cbBuffer *= 2;
			}
		  else if (!NT_SUCCESS(Status))
			{
			  HeapFree(hHeap, 0, pBuffer);
			  return FALSE;
			}
		}
      while (Status == STATUS_INFO_LENGTH_MISMATCH);

      // call the helper function
      dwError = KillProcessTreeNtHelper((PSYSTEM_PROCESSES)pBuffer, 
										dwProcessId);
		
      HeapFree(hHeap, 0, pBuffer);
    }
  else
    {
      // call the helper function
      dwError = KillProcessTreeWinHelper(dwProcessId);
    }

  return dwError == ERROR_SUCCESS;
}

static void s_kill(int sig) {
  if(!s_pid.use_wrapper) {
								/* we can kill our child directly */
	if(s_pid.p.hProcess) TerminateProcess(s_pid.p.hProcess, 1);
  }
  else {
								/* emulate unix kill behaviour */
	if(s_pid.p.dwProcessId) KillProcessEx(s_pid.p.dwProcessId, 1);
  }
}



#endif
static void make_local_socket_info(short java_socket_inet TSRMLS_DC) {
  if(!java_socket_inet) {
#ifndef CFG_JAVA_SOCKET_INET
	memset(&EXT_GLOBAL(cfg)->saddr.un, 0, sizeof EXT_GLOBAL(cfg)->saddr.un);
	EXT_GLOBAL(cfg)->saddr.un.sun_family = AF_LOCAL;
	memset(EXT_GLOBAL(cfg)->saddr.un.sun_path, 0, sizeof EXT_GLOBAL(cfg)->saddr.un.sun_path);
	strcpy(EXT_GLOBAL(cfg)->saddr.un.sun_path, EXT_GLOBAL(get_sockname)(TSRMLS_C));
#ifdef HAVE_ABSTRACT_NAMESPACE
	*EXT_GLOBAL(cfg)->saddr.un.sun_path=0;
#endif
	assert(EXT_GLOBAL(cfg)->java_socket_inet == 0);
	EXT_GLOBAL(cfg)->java_socket_inet = 0;
#endif
  } else {
	memset(&EXT_GLOBAL(cfg)->saddr.in, 0, sizeof EXT_GLOBAL(cfg)->saddr.in);
	EXT_GLOBAL(cfg)->java_socket_inet = 1;
	EXT_GLOBAL(cfg)->saddr.in.sin_family = AF_INET;
	EXT_GLOBAL(cfg)->saddr.in.sin_port=htons(atoi(EXT_GLOBAL(get_sockname)(TSRMLS_C)));
	EXT_GLOBAL(cfg)->saddr.in.sin_addr.s_addr = inet_addr( "127.0.0.1" );
  }
}

short is_socket_inet(char *old_name, char *name) {
#ifdef CFG_JAVA_SOCKET_INET 
  return 1;
#endif
  return strcmp(old_name, name);
}
//static char line[] = "\na\n\nstr\n\n";
/**
 * Cuts a string into lines. Unlike strtok this can return empty
 * tokens:
 *
 * \na\n\nstr\n
 * -> 
 * -> a
 * -> 
 * -> str
 *
 * @@param s the string or null
 * @@return each new token, may be empty
 */
static char *linesep(char *s) {
  static const char chr = '\n';
  static char *str; if(s) str=s;
  char *pos = str, *c;
  if(pos) { 
    c = strchr(str, chr);
    // if we found a match and it is followed by \0, we're done
    if((str=c) && ((*str++=0),!*str)) str = 0;
  }
  return pos;
}
/**
 * Read "@@channel\n" from the System.out.  Some insane VM
 * implementations (the Sun VM since 1.4.2) incorrectly write debug
 * output to System.out instead of System.err, so we have to deal with
 * this garbage. The Sun 1.5.0 VM for example writes "Listening for
 * transport dt_socket at address: 9147" if it was called with
 * -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:9147,server=y,suspend=n
 * the quiet=y option only exists in 1.6 and higher.
 */
#ifndef __MINGW32__
static char *readChannel(int fd, char*buf, size_t size) {
#else
static char *readChannel(HANDLE fd, char*buf, size_t size) {
  DWORD bwrite;
#endif
  ssize_t err;
  char *line, *next, delim;
  short contLine=0;
#ifndef __MINGW32__
  while((err=read(fd, buf, size-1))>0) {
#else
  while(ReadFile(fd, buf, size-1, &err, NULL) && err>0) {
#endif
    delim = buf[err-1];
    buf[err]=0;
    for(line=linesep(buf); line; line=next) {
      next = linesep(0);
      size_t len = strlen(line);
      if(len && line[0]=='@@' && !contLine) {
		if(next || (delim=='\n')) return line;
		if(size<=len+1) return 0;
		memmove(buf, line, len);
#ifndef __MINGW32__
		err = read(fd, buf+len, size-len); if(err==-1) return 0;
#else
		if((!ReadFile(fd, buf+len, size-len, &err, NULL))||(err<=0)) return 0;
#endif
		len += err;
		next = strchr(buf, '\n'); 
		if(next) *next=0; else buf[len-1]=0;
		return buf;
      } else {
		/* we have recived garbage, most likely debug output from some
		   insane VM implementation, pass it on to System.err */
		size_t len = strlen(line);
		if(len) write(2, line, strlen(line));
		if(next || (!next && delim=='\n')) write(2, "\n", 1);
		contLine = 0;
      }
    }
    contLine = delim!='\n';
  }
  return 0;
}

/**
 * Start a VM as a sub process of the HTTP server
 */
void EXT_GLOBAL(start_server)(TSRMLS_D) {
  int pid=0, err=-1, p[2], st[2], stx;
  char buf[255], *channel = 0;
  char count, *test_server = 0, *name;
#ifndef __MINGW32__
  if(can_fork(TSRMLS_C) && !(test_server=EXT_GLOBAL(test_server)(0, 0, 0 TSRMLS_CC)) && pipe(p)!=-1) {
	if(!(pid=fork())) {		/* daemon */
	  close(p[0]);
	  stx = pipe(st);
	  if(!fork()) {			/* guard */
		setsid();
		if(!(pid=fork())) {	/* java */
		  if(close(p[1])!=-1&& stx!=-1&& close(st[0])!=-1&& dup2(st[1], 1)!=-1)
			exec_vm(TSRMLS_C);
		  exit(105);
		}
		/* protect guard */
		signal(SIGHUP, SIG_IGN); 
		s_pid=pid; signal(SIGINT, s_kill); 
		signal(SIGTERM, SIG_IGN);
		
		write(p[1], &pid, sizeof pid);
		if(stx!=-1 && close(st[1])!=-1)
		  channel = readChannel(st[0], buf, sizeof buf);
		count = 0xFF & strlen(channel);
		write(p[1], &count, 1); if(count) write(p[1], channel, count);

		waitpid(pid, &err, 0);
		write(p[1], &err, sizeof err);
		exit(0);
	  } 
	  exit(0);
	}
	close(p[1]);
	wait(&err);
	if((read(p[0], &pid, sizeof pid))!=(sizeof pid)) pid=0;
	if((read(p[0], &count, 1))!=1) count=0;

	EXT_GLOBAL(cfg)->cid=pid;
	EXT_GLOBAL(cfg)->err=p[0];
	if(count&&((read(p[0], buf, sizeof buf))==count)) {
	  /* received channel # */
	  size_t n = count;
	  short inet;
	  n-=1;
	  name = malloc(n+1); if(!name) exit(9);
	  memcpy(name, buf+1, n); name[n]=0;
	  //php_printf("got server channel: %ld, %s", n, name);
	  inet = is_socket_inet(EXT_GLOBAL(cfg)->default_sockname, name);
	  free(EXT_GLOBAL(cfg)->default_sockname);
	  EXT_GLOBAL(cfg)->default_sockname=name;
	  make_local_socket_info(inet TSRMLS_CC);
	} else {
#ifdef CFG_JAVA_SOCKET_INET 
	  free(EXT_GLOBAL(cfg)->default_sockname);
	  EXT_GLOBAL(cfg)->default_sockname=strdup(DEFAULT_PORT);
	  assert(EXT_GLOBAL(cfg)->default_sockname); if(!EXT_GLOBAL(cfg)->default_sockname) exit(6);
	  make_local_socket_info(1 TSRMLS_CC);
#else
	  make_local_socket_info(0 TSRMLS_CC);
#endif
	  wait_server(TSRMLS_C);
	}
  } else 
#else
	if(can_fork(TSRMLS_C) && !(test_server=EXT_GLOBAL(test_server)(0, 0, 0 TSRMLS_CC))) {
	  char *cmd = get_server_string(0 TSRMLS_CC);
	  DWORD properties = /*CREATE_NEW_CONSOLE | */CREATE_NEW_PROCESS_GROUP;
	  STARTUPINFO su_info;
	  HANDLE read_pipe, write_pipe, read_pipe_dup;
	  SECURITY_ATTRIBUTES pipe_sattr = {sizeof(SECURITY_ATTRIBUTES),NULL,TRUE};
	  HANDLE pid = GetCurrentProcess();
	  DWORD bread;
	  if(!CreatePipe(&read_pipe, &write_pipe, &pipe_sattr, 0)) {
		goto cannot_fork;
	  }
	  if(!DuplicateHandle(pid,read_pipe,pid,&read_pipe_dup,0,FALSE,DUPLICATE_SAME_ACCESS)) {
		CloseHandle(read_pipe);
		goto cannot_fork;
	  }
	  CloseHandle(read_pipe);

	  s_pid.use_wrapper = use_wrapper(EXT_GLOBAL(cfg)->wrapper);

	  ZeroMemory(&su_info, sizeof(STARTUPINFO));
	  su_info.cb = sizeof(STARTUPINFO);
	  su_info.dwFlags = STARTF_USESTDHANDLES;
	  su_info.hStdError	= GetStdHandle(STD_ERROR_HANDLE);
	  su_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	  su_info.hStdOutput = write_pipe;
	  EXT_GLOBAL(cfg)->cid=0;
	  if(CreateProcess(NULL, cmd,
					   NULL, NULL, 1, properties, NULL, NULL, 
					   &su_info, &s_pid.p)) {
		CloseHandle(write_pipe);
		EXT_GLOBAL(cfg)->cid=s_pid.p.dwProcessId;
		if(channel=readChannel(read_pipe_dup, buf, sizeof buf)) {
		  count = strlen(channel)-1;
		  name = malloc(count+1); if(!name) exit(9);
		  memcpy(name, channel+1, count); name[count]=0;
		  free(EXT_GLOBAL(cfg)->default_sockname);
		  EXT_GLOBAL(cfg)->default_sockname=name;
		  make_local_socket_info(1 TSRMLS_CC);
		} else {
		  free(EXT_GLOBAL(cfg)->default_sockname);
		  EXT_GLOBAL(cfg)->default_sockname=strdup(DEFAULT_PORT);
		  assert(EXT_GLOBAL(cfg)->default_sockname); if(!EXT_GLOBAL(cfg)->default_sockname) exit(6);
		  make_local_socket_info(1 TSRMLS_CC);
		  wait_server(TSRMLS_C);
		}
		CloseHandle(s_pid.p.hThread);
		CloseHandle(read_pipe_dup);
	  } else {
	  cannot_fork:
		php_error(E_WARNING, "php_mod_"/**/EXT_NAME()/**/"(%d) system error: Could not start back-end: %s; Code: %ld.", 105, cmd, (long)GetLastError());
		make_local_socket_info(1 TSRMLS_CC);
	  }
	  free(cmd);
	} else
#endif /* MINGW32 */
	  {
#ifdef CFG_JAVA_SOCKET_INET 
		make_local_socket_info(1 TSRMLS_CC);
#else
		make_local_socket_info(0 TSRMLS_CC);
#endif
		EXT_GLOBAL(cfg)->cid=EXT_GLOBAL(cfg)->err=0;
	  }
  if(test_server) free(test_server);
}

static void wait_for_daemon(void) {
#ifndef __MINGW32__
  static const int sig[] = {SIGTERM, SIGKILL};
  fd_set rfds;
  int err, i;

  assert(EXT_GLOBAL(cfg)->err); if(!(EXT_GLOBAL(cfg)->err)) return;
  assert(EXT_GLOBAL(cfg)->cid);

  /* first kill is trapped, second kill is received with default
	 handler. If the server still exists, we send it a -9 */
  kill(EXT_GLOBAL(cfg)->cid, SIGTERM);
  FD_ZERO(&rfds);
  FD_SET(EXT_GLOBAL(cfg)->err, &rfds);
  for(i=0; i<2; i++) {
	struct timeval timeval = {2l, 0};
	if(select(1+EXT_GLOBAL(cfg)->err, &rfds, 0, 0, &timeval) > 0) break;
	kill(EXT_GLOBAL(cfg)->cid, sig[i]);
  }	

  if((read(EXT_GLOBAL(cfg)->err, &err, sizeof err))!=sizeof err) err=0;
  //printf("VM terminated with code: %ld\n", err);
  close(EXT_GLOBAL(cfg)->err);
  EXT_GLOBAL(cfg)->err=0;
#else
  s_kill(0);					/* always -9 on windows */
#endif
}

void EXT_GLOBAL(shutdown_library)() 
{
  if(EXT_GLOBAL(cfg)->cid) wait_for_daemon();
}

void EXT_GLOBAL(sys_error)(const char *str, int code) {
#ifndef __MINGW32__
  php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d) system error: %s. %s.", code, strerror(errno), str);
#else
  php_error(E_ERROR, "php_mod_"/**/EXT_NAME()/**/"(%d) system error code: %ld. %s.", code, (long)GetLastError(), str);
#endif
}

#ifndef PHP_WRAPPER_H
#error must include php_wrapper.h
#endif
@


1.93
log
@Release-5-3-1
@
text
@@


1.92
log
@*** empty log message ***
@
text
@a1249 145
/**
 * Called when the FCGI master has received the kill signal.
 */
static void fcgi_do_rmtmpdir() {
#ifndef __MINGW32__
  extern EXT_GLOBAL(is_parent);
  static const char lck[] = ".lck";
  DIR * dir;
  struct dirent * file;
  size_t len;
  char *name, *lock_name;
  int lock_file, err;

  /* If this is not an fcgi child, do nothing. */
  if(!EXT_GLOBAL(cfg) || !EXT_GLOBAL(cfg)->tmpdir) return;

  len = strlen(EXT_GLOBAL(cfg)->tmpdir);

  lock_name = malloc(len+sizeof lck);
  strcpy(lock_name, (EXT_GLOBAL(cfg)->tmpdir));
  strcat(lock_name, lck);
  lock_file = open(lock_name, O_CREAT | O_EXCL, 0700);
  unlink(lock_name);
  free(lock_name);
  if(lock_file==-1) return;

  dir = opendir(EXT_GLOBAL(cfg)->tmpdir);
  if(!dir) return;
  while(file = readdir(dir)) {
	if(file->d_name[0]!='p') continue;
	name = malloc(len + strlen(file->d_name)+2);
	if(!name) exit(6);
	strcpy(name, (EXT_GLOBAL(cfg)->tmpdir));
	strcat(name, "/");
	strcat(name, file->d_name);
	unlink(name);
	free(name);
  }
  closedir(dir);
  rmdir(EXT_GLOBAL(cfg)->tmpdir);
  free(EXT_GLOBAL(cfg)->tmpdir);
  EXT_GLOBAL(cfg)->tmpdir=0;
#endif
}
/** 
 * Signal handler for FastCGI
 */
static void fcgi_rmtmpdir(int sig) {
  fcgi_do_rmtmpdir();
  exit(0);
}
/**
 * Delete the temp directory which contains the comm. pipes 
 */
static void rmtmpdir () {
#ifndef __MINGW32__
  extern EXT_GLOBAL(is_parent);
  DIR * dir;
  struct dirent * file;
  size_t len;
  char *name;
  int err;
  int lock;

  /* If this is a child, do nothing. */
  if(!EXT_GLOBAL(cfg) || !EXT_GLOBAL(cfg)->tmpdir || EXT_GLOBAL(cfg)->pid!=getpid()) return;
  len = strlen(EXT_GLOBAL(cfg)->tmpdir);
  dir = opendir(EXT_GLOBAL(cfg)->tmpdir);
  if(!dir) { EXT_GLOBAL(sys_error)("Could not open tmpdir", 65); return; }
  while(file = readdir(dir)) {
	if(file->d_name[0]!='p') continue;
	name = malloc(len + strlen(file->d_name)+2);
	if(!name) exit(6);
	strcpy(name, (EXT_GLOBAL(cfg)->tmpdir));
	strcat(name, "/");
	strcat(name, file->d_name);
	php_error(E_NOTICE, "php_mod_"/**/EXT_NAME()/**/"(%d): Removing %s which is not (yet?) connected. ", 66, name);
	unlink(name);
	free(name);
  }
  err = closedir(dir);
  if(err==-1) { EXT_GLOBAL(sys_error)("Could not close tmpdir", 67); return; }

  err = rmdir(EXT_GLOBAL(cfg)->tmpdir);
  if(err==-1) { EXT_GLOBAL(sys_error)("Could not unlink tmpdir", 68); return; }

  free(EXT_GLOBAL(cfg)->tmpdir);
  EXT_GLOBAL(cfg)->tmpdir=0;
#endif
}
/**
 * Called from MSHUTDOWN. This method does nothing if this is a
 * FastCGI servlet, because the FCGI SAPI calls MSHUTDOWN everytime a
 * child is killed, which is nonsense, of course.
 */
void EXT_GLOBAL(rmtmpdir) () {
								/* see FastCGI comment below */
  if(!EXT_GLOBAL(cfg)->is_fcgi_servlet) rmtmpdir();	
}
/**
 * Wrapper for mkdtemp().
 */
#ifndef __MINGW32__
static char *makedtemp(char tmpl[]) {
#ifdef HAVE_MKDTEMP
  char *str = 0, *s = mkdtemp (tmpl);
  if(s) if(!(str=strdup(s))) { rmdir(s); exit(6); }
  return str;
#else
  char *s, *p = strrchr(tmpl, '/');
  char c = *p;
  *p=0; 
  p[6]=0; 
  s = tempnam(tmpl,p+1); 
  *p=c;
  if(!s) return 0;
  if(-1==mkdir(s, 0700)) { free(s); return 0; }
  return s;
#endif
}
#endif
/**
 * Called from MINIT, creates a directory which will contain the
 * comm. pipes on Unix. See rmtmpdir above.
 */
void EXT_GLOBAL(mktmpdir) () {
#ifndef __MINGW32__
  char sockname[] = SOCKNAME;
  char sockname_shm[] = SOCKNAME_SHM;
  char *tmpdir;

  /* The FastCGI SAPI is completely odd, it calls the parent(!)
	 mshutdown for each killed child. Ignore this nonsense and call
	 rmtmpdir ourselfs when the parent exits. */
  if(EXT_GLOBAL(cfg)->is_fcgi_servlet) signal(SIGTERM, fcgi_rmtmpdir); 

  tmpdir = makedtemp(sockname_shm);
  if(!tmpdir) tmpdir = makedtemp(sockname);
  if(!tmpdir) {EXT_GLOBAL(cfg)->tmpdir=0; return;}
  EXT_GLOBAL(cfg)->tmpdir=tmpdir;
  chmod(tmpdir, 01777);
#else  /* There's no standard tmpdir on windows */
  EXT_GLOBAL(cfg)->tmpdir=0;
#endif
}
@


1.91
log
@Release-4-1-8
@
text
@d239 1
a239 1
  s="-Djava.security.policy="; p=0;
@


1.90
log
@Release-3-0-8
@
text
@d439 4
@


1.89
log
@Release-3-0-8
@
text
@d396 6
@


1.88
log
@Files update 3.2.2 to 4.0.1. Extracted from the src.tar.gz downloaded from sf.net, uploaded by Jost Boekemeier. Update to repository by Andre Felipe Machado.
@
text
@d98 1
d170 1
a170 1
  if(!EXT_GLOBAL(cfg)->java_socket_inet) {
d178 13
a190 3
	cfg_sockname="0";
	s_prefix=inet_socket_prefix;
    //cfg_logFile="";
d290 1
a290 1
  if(!EXT_GLOBAL(cfg)->java_socket_inet) {
d403 1
a403 1
static int test_local_server(void) {
d405 1
a405 1
  if(!EXT_GLOBAL(cfg)->java_socket_inet) {
d414 1
a414 1
  if(EXT_GLOBAL(cfg)->java_socket_inet) {
d426 5
a430 4
  return 0 if user has hard-coded the socketname
*/
static short can_fork(void) {
  return EXT_GLOBAL(cfg)->can_fork;
d453 2
a454 2
  if (((socketname_set || can_fork()) && (socketname_set || !called_from_init))
	  && -1!=(sock=test_local_server()) ) {
d520 2
a521 2
  if (((socketname_set || can_fork()) && (socketname_set || !called_from_init))
	  && -1!=(sock=test_local_server()) ) {
d540 1
a540 1
static int wait_server(void) {
d550 1
a550 1
  while(EXT_GLOBAL(cfg)->cid && -1==(sock=test_local_server()) && --count) {
d558 1
a558 1
  while(EXT_GLOBAL(cfg)->cid && -1==sock && -1==(sock=test_local_server()) && --count) {
d569 1
a569 1
  while(EXT_GLOBAL(cfg)->cid && -1==(sock=test_local_server()) && --count) {
d573 1
a573 1
  while(EXT_GLOBAL(cfg)->cid && -1==sock && -1==(sock=test_local_server()) && --count) {
d1072 1
a1072 1
  if(can_fork() && !(test_server=EXT_GLOBAL(test_server)(0, 0, 0 TSRMLS_CC)) && pipe(p)!=-1) {
d1128 1
a1128 1
	  wait_server();
d1132 1
a1132 1
	if(can_fork() && !(test_server=EXT_GLOBAL(test_server)(0, 0, 0 TSRMLS_CC))) {
d1175 1
a1175 1
		  wait_server();
@


1.87
log
@Release-3-1-8
@
text
@d5 1
a5 1
  Copyright (C) 2006 Jost Boekemeier
@


1.86
log
@Release-3-1-8rc3
@
text
@d92 1
d1109 3
a1135 1
	  
d1159 3
@


1.85
log
@Release-3-1-8rc
@
text
@d108 3
d971 83
d1056 2
a1057 1
  char buf[127], count, *test_server = 0, *name;
d1076 4
a1079 3
		if(stx!=-1 && close(st[1])!=-1) err = read(st[0], buf, sizeof buf);
		count = (err==-1) ? 0 : (0xff & err);
		write(p[1], &count, 1); if(count) write(p[1], buf, count);
d1098 1
d1100 1
a1100 1
	  memcpy(name, buf, n); name[n]=0;
d1118 1
a1118 1
	  DWORD properties = CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP;
d1132 1
d1143 1
a1143 1
	  if(CreateProcess(NULL, cmd, 
d1146 1
d1148 4
a1151 4
		if(ReadFile(read_pipe_dup, buf, sizeof(buf), &bread, NULL) && bread) {
		  name = malloc(bread+1); if(!name) exit(9);
		  memcpy(name, buf, bread); name[bread]=0;
		  //php_printf("got server channel: %ld, %s", bread, name);
@


1.84
log
@Release-3-1-8devel1
@
text
@d966 1
a966 1
  return strcmp(old_name, name) ? 0 : 1;
d1019 1
a1019 1
	  make_local_socket_info(1 TSRMLS_C);
d1021 1
a1021 1
	  make_local_socket_info(0 TSRMLS_C);
@


1.83
log
@Release-3-1-7
@
text
@d3 38
a162 1
#ifdef CFG_JAVA_SOCKET_INET
d165 4
a168 4
#else
  const char *s_prefix = local_socket_prefix;
  short any_port = for_display;
#endif
a270 1
#ifdef CFG_JAVA_SOCKET_INET
a272 4
#else
  const char *s_prefix = local_socket_prefix;
  short any_port = for_display;
#endif
d275 4
d390 1
d392 1
a392 4
  sock = socket (PF_LOCAL, SOCK_STREAM, 0);
#else
  sock = socket (PF_INET, SOCK_STREAM, 0);
  if(sock!=-1) setsockopt(sock, 0x6, TCP_NODELAY, (void*)&is_true, sizeof is_true);
d394 4
d399 7
a405 1
  n = connect(sock,(struct sockaddr*)&EXT_GLOBAL(cfg)->saddr, sizeof EXT_GLOBAL(cfg)->saddr);
d940 2
a941 2
static void make_local_socket_info(TSRMLS_D) {
  memset(&EXT_GLOBAL(cfg)->saddr, 0, sizeof EXT_GLOBAL(cfg)->saddr);
d943 9
a951 10
  EXT_GLOBAL(cfg)->saddr.sun_family = AF_LOCAL;
  memset(EXT_GLOBAL(cfg)->saddr.sun_path, 0, sizeof EXT_GLOBAL(cfg)->saddr.sun_path);
  strcpy(EXT_GLOBAL(cfg)->saddr.sun_path, EXT_GLOBAL(get_sockname)(TSRMLS_C));
# ifdef HAVE_ABSTRACT_NAMESPACE
  *EXT_GLOBAL(cfg)->saddr.sun_path=0;
# endif
#else
  EXT_GLOBAL(cfg)->saddr.sin_family = AF_INET;
  EXT_GLOBAL(cfg)->saddr.sin_port=htons(atoi(EXT_GLOBAL(get_sockname)(TSRMLS_C)));
  EXT_GLOBAL(cfg)->saddr.sin_addr.s_addr = inet_addr( "127.0.0.1" );
d953 7
d962 6
d1009 1
d1013 1
d1016 1
a1016 1
	  make_local_socket_info(TSRMLS_C);
d1018 5
a1022 1
	  make_local_socket_info(TSRMLS_C);
d1063 1
a1063 1
		  make_local_socket_info(TSRMLS_C);
d1065 1
a1065 1
		  make_local_socket_info(TSRMLS_C);
d1073 1
a1073 1
		make_local_socket_info(TSRMLS_C);
d1079 5
a1083 1
		make_local_socket_info(TSRMLS_C);
@


1.82
log
@Release-3-1-6
@
text
@d3 2
d15 5
a24 5
/* stat, mkdir */
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

d37 1
d39 1
a52 1
#include "php_java.h"
d329 1
d338 1
d481 1
a481 1
#ifndef __MINGW32__
d484 2
d487 1
d491 1
d494 1
d499 1
d502 1
d1065 3
d1105 2
d1109 3
d1116 3
a1118 1
/* Delete the temp directory which contains the comm. pipes */
d1155 5
d1164 3
d1186 4
@


1.81
log
@Release-3-1-6
@
text
@a11 2
#include <sys/types.h>
#include <unistd.h>
d18 1
a18 1
/* stat */
d20 2
d1052 44
d1105 1
a1108 1

d1119 1
d1137 19
d1162 7
a1168 6
  atexit(rmtmpdir); /* The FastCGI SAPI is completely odd, it calls
					   the parent(!) mshutdown for each killed
					   child. Ignore this nonsense and call rmtmpdir
					   ourselfs, when the parent exits. */
  tmpdir = mkdtemp(sockname_shm);
  if(!tmpdir) tmpdir = mkdtemp(sockname);
d1170 1
a1170 1
  EXT_GLOBAL(cfg)->tmpdir=strdup(tmpdir); if(!EXT_GLOBAL(cfg)->tmpdir) { rmdir(tmpdir); exit(6); }
@


1.80
log
@Release-3-1-2
@
text
@d15 5
d135 1
a135 1
	cfg_logFile="";
d204 1
a204 1
  args[5] = strdup("php.java.bridge.JavaBridge");
d256 1
a256 1
	cfg_logFile="";
d1052 31
d1084 27
@


1.79
log
@Release-3-1-0
@
text
@d119 1
d122 1
d127 1
a127 1
  if(for_display && !(EXT_GLOBAL(option_set_by_user) (U_SOCKNAME, EXT_GLOBAL(ini_user)))) {
d228 1
d231 1
d248 1
a248 1
  if(for_display && !(EXT_GLOBAL(option_set_by_user) (U_SOCKNAME, EXT_GLOBAL(ini_user)))) {
d879 15
d896 2
a897 2
  int pid=0, err=0, p[2];
  char *test_server = 0;
d902 1
d906 2
a907 2
		  close(p[1]);
		  exec_vm(TSRMLS_C); 
d916 4
d929 2
a930 1
	
d933 13
a945 1
	wait_server();
d952 13
d969 4
a972 4
	  //su_info.dwFlags = STARTF_USESTDHANDLES;
	  //su_info.hStdError	= GetStdHandle(STD_ERROR_HANDLE);
	  //su_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	  //su_info.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
d978 13
a990 2
		//CloseHandle(processInformation.hThread);//FIXME?
		wait_server();
d992 3
a994 1
		php_error(E_WARNING, "php_mod_"/**/EXT_NAME()/**/"(%d) system error: Could not start backend: %s; Code: %ld.", 105, cmd, (long)GetLastError());
d1000 1
@


1.78
log
@Release-3-1-0
@
text
@d40 1
a40 1
/* path and dir separators */
d57 48
a105 1
static const char separator = '/';
d107 1
d168 1
a168 1
	if(*p&&*slash==separator) *slash=0;
a174 2
  args[3] = strdup("-Djava.awt.headless=true");
  args[4] = strdup("php.java.bridge.JavaBridge");
d176 26
a201 4
  args[5] = sockname;
  args[6] = strdup(EXT_GLOBAL(cfg)->logLevel);
  args[7] = strdup(cfg_logFile);
  args[8] = NULL;
d239 1
a239 1
  if(*p&&*slash==separator) *slash=0;
a260 18
static short use_wrapper(char*wrapper) {
  struct stat buf;
  short use_wrapper=(EXT_GLOBAL(option_set_by_user) (U_WRAPPER, EXT_GLOBAL(ini_user)));
  if(use_wrapper) return use_wrapper;

#ifndef __MINGW32__
  if(!stat(wrapper, &buf) && (S_IFREG&buf.st_mode)) {
	if(getuid()==buf.st_uid)
	  use_wrapper=(S_IXUSR&buf.st_mode);
	else if(getgid()==buf.st_gid)
	  use_wrapper=(S_IXGRP&buf.st_mode);
	else 
	  use_wrapper=(S_IXOTH&buf.st_mode);
  }
#endif

  return use_wrapper;
}
a316 11
#ifdef CFG_JAVA_INPROCESS
  extern int EXT_GLOBAL(bridge_main)(int argc, char**argv) ;
  static char*env[N_SENV];
  static char*args[N_SARGS];
  EXT_GLOBAL(get_server_args)(env, args, 0);
  if(N_SENV>2) {
	if(*env[0]) putenv(env[0]);
	if(*env[1]) putenv(env[1]);
  }
  EXT_GLOBAL(bridge_main)(N_SARGS, args);
#else
a334 1
#endif
d337 1
a337 1
static const int true = 1;
d344 1
a344 1
  if(sock!=-1) setsockopt(sock, 0x6, TCP_NODELAY, (void*)&true, sizeof true);
d431 1
a431 1
		setsockopt(sock, 0x6, TCP_NODELAY, (void*)&true, sizeof true);
d467 1
a469 1
#ifndef __MINGW32__
d486 2
d489 1
a489 1
	Sleep(timeout/1000);
d494 1
a494 1
	Sleep(1000);
d913 1
a913 1
	  DWORD properties = CREATE_NEW_CONSOLE;
d919 4
d928 1
@


1.77
log
@Release-3-1-0
@
text
@d299 1
a299 1

d306 1
d391 4
a394 1
	  if(_socket) *_socket=sock;
@


1.76
log
@Release-3.0.8
@
text
@d895 1
a895 1
  const static sig[] = {SIGTERM, SIGKILL};
d897 1
a897 1
  int err, c, i;
@


1.75
log
@Release-3.0.8rc
@
text
@d436 1
a436 1
  count=10;
d447 1
a447 1
  count=10;
@


1.75.2.1
log
@Release-3-0-8-1
@
text
@d436 1
a436 1
  count=30;
d447 1
a447 1
  count=15;
@


1.75.2.2
log
@Release-3-0-8-1
@
text
@d299 1
a299 1
static const int true = 1;
a305 1
  if(sock!=-1) setsockopt(sock, 0x6, TCP_NODELAY, (void*)&true, sizeof true);
d390 1
a390 4
	  if(_socket) {
		*_socket=sock;
		setsockopt(sock, 0x6, TCP_NODELAY, (void*)&true, sizeof true);
	  }
@


1.74
log
@Release-3.0.8test1
@
text
@d107 4
a110 2
  p=strdup("-Dphp.java.bridge.default_log_level=2");
  args[1] = p;					/* default log level */
@


1.73
log
@Release-3.0.8pre2
@
text
@d107 2
a108 4
  s="-Djava.library.path=";
  p=malloc(strlen(s)+strlen(lib_path)+1);
  strcpy(p, s); strcat(p, lib_path);
  args[1] = p;					/* library path */
a125 6
  /* disabled due to problems with IBM java, it could not find
	 default mime table anymore */
  //s="-Djava.home=";
  //p=malloc(strlen(s)+strlen(home)+1);
  //strcpy(p, s); strcat(p, home);
  //args[4] = p;					/* java home */
@


1.72
log
@Release-3.0.8pre
@
text
@d443 1
a443 1
  while(EXT_GLOBAL(cfg)->cid && -1==(sock=test_local_server()) && --count) {
d454 1
a454 1
  while(EXT_GLOBAL(cfg)->cid && -1==(sock=test_local_server()) && --count) {
d459 6
a464 2
  close(sock);
  return (EXT_GLOBAL(cfg)->cid && count)?SUCCESS:FAILURE;
d475 348
a822 1
static PROCESS_INFORMATION s_pid;
d824 8
a831 1
  if(s_pid.hProcess) TerminateProcess(s_pid.hProcess, 1);
d833 3
d877 1
a877 3
	  PROCESS_INFORMATION p_info;
	  short must_use_wrapper = use_wrapper(EXT_GLOBAL(cfg)->wrapper);
	  char *command = must_use_wrapper ? EXT_GLOBAL(cfg)->wrapper : cmd;
d882 1
a882 1
	  if(CreateProcess(NULL, command, 
d884 2
a885 2
					   &su_info, &s_pid)) {
		EXT_GLOBAL(cfg)->cid=s_pid.dwProcessId;
d888 1
a888 1
		php_error(E_WARNING, "php_mod_"/**/EXT_NAME()/**/"(%d) system error: Could not start backend: %s; Code: %ld.", 105, command, (long)GetLastError());
@


1.71
log
@Release-3.0.7
@
text
@d3 10
a12 1
/* execve */
a13 1
#include <sys/types.h>
d425 5
a429 1

d431 2
a432 1
  int count=15, sock;
d440 7
a446 2
	if(count<=10) php_error(E_NOTICE, "php_mod_"/**/EXT_NAME()/**/"(%d): waiting for server another %d seconds",57, count);
	
a449 1

d451 5
a455 1
	if(count<=10) php_error(E_NOTICE, "php_mod_"/**/EXT_NAME()/**/"(%d): waiting for server another %d seconds",57, count);
d517 2
d523 3
a525 1
	  if(CreateProcess( NULL, cmd, NULL, NULL, 1, properties, NULL, NULL, &su_info, &s_pid)) {
d529 1
a529 2
		php_error(E_WARNING, "php_mod_"/**/EXT_NAME()/**/"(%d) system error: Could not start backend: %s; Code: %ld.", 105, cmd, (long)GetLastError());
		free(cmd);
d531 1
d542 3
a544 2
  struct pollfd pollfd[1] = {{EXT_GLOBAL(cfg)->err, POLLIN, 0}};
  int err, c;
d546 1
a546 1
  assert(EXT_GLOBAL(cfg)->err);
d551 13
a563 17
  for(c=3; c>0 && EXT_GLOBAL(cfg)->cid; c--) {
	if (!(!EXT_GLOBAL(cfg)->err || (EXT_GLOBAL(cfg)->err && !(err=poll(pollfd, 1, 0))))) break;
	if(c>1) {
	  kill(EXT_GLOBAL(cfg)->cid, SIGTERM);
	  sleep(1);
	  if (!(!EXT_GLOBAL(cfg)->err || (EXT_GLOBAL(cfg)->err && !(err=poll(pollfd, 1, 0))))) break;
	  sleep(4);
	} else {
	  kill(EXT_GLOBAL(cfg)->cid, SIGKILL);
	}
  }
  if(EXT_GLOBAL(cfg)->err) {
	if((read(EXT_GLOBAL(cfg)->err, &err, sizeof err))!=sizeof err) err=0;
	//printf("VM terminated with code: %ld\n", err);
	close(EXT_GLOBAL(cfg)->err);
	EXT_GLOBAL(cfg)->err=0;
  }
d565 1
a565 2
  s_kill(0);
  Sleep(1000);
@


1.70
log
@Release-3.0.7
@
text
@d50 2
a51 2
/* instead of static const char separator[2] = {ZEND_PATHS_SEPARATOR, 0}; */
static const char separator[2] = "/";
a95 3
  if(!*home) {					/* look into extension_dir then */
	if(ext) home = ext;
  }
d112 1
a112 1
	if(*p&&*slash==*separator) *slash=0;
d133 8
a140 4
  s="JAVA_HOME=";
  p=malloc(strlen(s)+strlen(home)+1);
  strcpy(p, s); strcat(p, home);
  env[0] = p;					/* java home */
d145 1
a145 1
  strcat(p, separator); strcat(p, sys_libpath);
d169 1
a169 1
  if(*p&&*slash==*separator) *slash=0;
d180 1
a180 1
  /* protocol */
d271 2
a272 2
	putenv(env[0]);
	putenv(env[1]);
d278 1
a278 1
  char **args=_args+1;
d281 2
a282 2
	putenv(env[0]);
	putenv(env[1]);
d284 10
a293 2
  if(use_wrapper(EXT_GLOBAL(cfg)->wrapper)) *--args = strdup(EXT_GLOBAL(cfg)->wrapper);
  execv(args[0], args);
d502 4
a506 1
	  wait_server();
@


1.69
log
@Release-3.0.7
@
text
@d49 3
a51 1

a53 1
  static const char separator[2] = {ZEND_PATHS_SEPARATOR, 0};
d115 1
a115 1
	if(*p&&*slash==ZEND_PATHS_SEPARATOR) *slash=0;
d168 1
a168 1
  if(*p&&*slash==ZEND_PATHS_SEPARATOR) *slash=0;
a173 1
	static const char zero[] = "0";
@


1.68
log
@*** empty log message ***
@
text
@a212 5
#ifndef __MINGW32__
  static const char quote[] = "'";
#else
  static const char quote[] = "\"";
#endif
a251 1
	if(!strlen(args[i])) strcat(s,quote);
a252 1
	if(!strlen(args[i])) strcat(s,quote);
@


1.67
log
@Release-3.0.5
@
text
@a34 1
#include "ext/session/php_session.h"
@


1.66
log
@Release-3.0.3
@
text
@d85 14
d101 1
a101 1
  args[0]=strdup(program);
d327 2
a328 2
  short socketname_set = 
	(EXT_GLOBAL(option_set_by_user) (U_SOCKNAME, JG(ini_user))) && 
d349 1
a349 1
  if(JG(hosts) && strlen(JG(hosts))) {
d353 1
a353 1
	for(host=strtok(hosts, ";"); host; host=strtok(0, ";")) {
d393 2
d399 15
@


1.65
log
@Release-3-0-2
@
text
@d179 2
a180 1
  short use_wrapper=0;
@


1.64
log
@Release-3-0-2
@
text
@a51 1
static const char* const wrapper = EXTENSION_DIR/**/"/RunJavaBridge";
a134 1
static const char* const wrapper = EXTENSION_DIR/**/"/RunMonoBridge";
d177 1
a177 1
static short use_wrapper(void) {
d204 1
a204 1
  short must_use_wrapper = use_wrapper();
d213 1
a213 1
	length+=strlen(wrapper)+1;
d238 1
a238 1
	strcat(s, wrapper);
d276 1
a276 1
  if(use_wrapper()) *--args = strdup(wrapper);
@


1.63
log
@2.0.8RC2 fixes PR1283148 and 1281189.
@
text
@d396 1
a396 1
	php_error(E_NOTICE, "php_mod_"/**/EXT_NAME()/**/"(%d): waiting for server another %d seconds",57, count);
d403 1
a403 1
	php_error(E_NOTICE, "php_mod_"/**/EXT_NAME()/**/"(%d): waiting for server another %d seconds",57, count);
d433 1
a434 1
		  setsid();
@


1.62
log
@Release-2.0.8(pre4)
@
text
@d519 7
@


1.61
log
@Release-2.0.8(pre4)
@
text
@a285 1
  puts("test local");
@


1.60
log
@Release-2.0.8(pre3)
@
text
@d38 1
d48 3
d53 1
a53 1
static void EXT_GLOBAL(get_server_args)(char*env[N_SENV], char*args[N_SARGS], short for_display) {
d67 1
a67 1
  char *sockname, *cfg_sockname=EXT_GLOBAL(get_sockname)(), *cfg_logFile=EXT_GLOBAL(cfg)->logFile;
d70 1
a70 1
  if(for_display && !(EXT_GLOBAL(option_set_by_user) (U_SOCKNAME))) {
d83 1
a83 1
  if(!(EXT_GLOBAL(option_set_by_user) (U_LIBRARY_PATH))) {	/* look into extension_dir then */
d96 1
a96 1
  if(ext && !(EXT_GLOBAL(option_set_by_user) (U_CLASSPATH))) {	/* look into extension_dir then */
d137 1
a137 1
static void EXT_GLOBAL(get_server_args)(char*env[N_SENV], char*args[N_SARGS], short for_display) {
d146 1
a146 1
  char *sockname, *cfg_sockname=EXT_GLOBAL(get_sockname)(), *cfg_logFile=EXT_GLOBAL(cfg)->logFile;
d148 1
a148 1
  if(!(EXT_GLOBAL(option_set_by_user) (U_JAVA_HOME))) {	/* look into extension_dir then */
d161 1
a161 1
  if(for_display && !(EXT_GLOBAL(option_set_by_user) (U_SOCKNAME))) {
d179 1
a179 1
static short use_wrapper() {
d200 1
a200 1
char*get_server_string(short for_display) {
d213 1
a213 1
  EXT_GLOBAL(get_server_args)(env, args, for_display);
d254 2
a255 2
char*EXT_GLOBAL(get_server_string)() {
  get_server_string(1);
d258 1
a258 1
static void exec_vm() {
d273 1
a273 1
  EXT_GLOBAL(get_server_args)(env, args, 0);
d284 1
a284 1
static int test_local_server() {
d286 1
a286 1

d301 2
a302 5
static short can_fork() {
  return 
	!(EXT_GLOBAL (option_set_by_user) (U_SOCKNAME)) &&
	!(EXT_GLOBAL (option_set_by_user) (U_HOSTS)) &&
	!(EXT_GLOBAL (option_set_by_user) (U_SERVLET));
d309 1
a309 1
char* EXT_GLOBAL(test_server)(int *_socket, short *local, struct sockaddr*_saddr) {
d316 2
a317 2
	(EXT_GLOBAL(option_set_by_user) (U_SOCKNAME)) && 
	!(EXT_GLOBAL(option_set_by_user) (U_SERVLET));
d333 1
a333 1
	return strdup(EXT_GLOBAL(get_sockname)());
d337 2
a338 2
  if(EXT_GLOBAL(cfg)->hosts && strlen(EXT_GLOBAL(cfg)->hosts)) {
	char *host, *hosts = strdup(EXT_GLOBAL(cfg)->hosts);
d388 1
a388 1
static int wait_server() {
d426 1
a426 1
void EXT_GLOBAL(start_server)() {
d430 1
a430 1
  if(can_fork() && !(test_server=EXT_GLOBAL(test_server)(0, 0, 0)) && pipe(p)!=-1) {
d437 1
a437 1
		  exec_vm(); 
d461 2
a462 2
	if(can_fork() && !(test_server=EXT_GLOBAL(test_server)(0, 0, 0))) {
	  char *cmd = get_server_string(0);
d482 1
a482 1
static void wait_for_daemon() {
@


1.59
log
@Release-2.0.8-pre3
@
text
@d63 1
a63 1
  char *sockname, *cfg_sockname=EXT_GLOBAL(cfg)->sockname, *cfg_logFile=EXT_GLOBAL(cfg)->logFile;
d94 1
d96 4
a99 1
	strcpy(p, s); strcat(p, ext); strcat(p, bridge);
d135 1
a135 1
  char *p;
d142 1
a142 1
  char *sockname, *cfg_sockname=EXT_GLOBAL(cfg)->sockname, *cfg_logFile=EXT_GLOBAL(cfg)->logFile;
d150 5
a154 1
  strcpy(p, home); strcat(p, executable);
d332 1
a332 1
	return strdup(EXT_GLOBAL(cfg)->sockname);
@


1.58
log
@Release-2.0.8-preview
@
text
@d300 1
a300 1
char* EXT_GLOBAL(test_server)(int *_socket, short *local) {
d371 1
d421 1
a421 1
  if(can_fork() && !(test_server=EXT_GLOBAL(test_server)(0, 0)) && pipe(p)!=-1) {
d452 1
a452 1
	if(can_fork() && !(test_server=EXT_GLOBAL(test_server)(0, 0))) {
@


1.57
log
@Release-2.0.8(pre)
@
text
@d45 1
d57 1
d76 6
d90 10
a99 2
  p=malloc(strlen(s)+strlen(cp)+1);
  strcpy(p, s); strcat(p, cp);
d130 1
a130 2
  const char executable[] = "/MonoBridge.exe";
  const char ext_dir[] = "extension_dir";
d150 1
d188 6
a193 1
char*EXT_GLOBAL(get_server_string)() {
d201 1
a201 1
  EXT_GLOBAL(get_server_args)(env, args, 1);
d204 1
a204 1

d209 1
d220 1
d226 1
d233 1
a233 1
	if(!strlen(args[i])) strcat(s,"'");
d235 1
a235 1
	if(!strlen(args[i])) strcat(s,"'");
d242 3
d379 1
a381 1
  int count=15, sock;
d391 7
a399 3
#else
  return SUCCESS;
#endif
d404 1
a406 1
#ifndef __MINGW32__
d408 6
a414 1
}
d449 16
a464 1
  } else
d466 4
a469 4
	{
	  EXT_GLOBAL(cfg)->cid=EXT_GLOBAL(cfg)->err=0;
	  free(test_server);
	}
d499 3
@


1.56
log
@PR1243638: Running php and jsp side by side
@
text
@d340 1
@


1.55
log
@gtk, swing and swt examples added
@
text
@d64 1
a64 1
  if(for_display && !(EXT_GLOBAL(ini_last_updated)&U_SOCKNAME)) {
d125 1
a125 1
  if(!(EXT_GLOBAL(ini_last_updated)&U_JAVA_HOME)) {	/* look into extension_dir then */
d134 1
a134 1
  if(for_display && !(EXT_GLOBAL(ini_last_updated)&U_SOCKNAME)) {
d263 4
a266 1
  return EXT_GLOBAL(cfg)->can_fork;
d276 6
a281 1
  short socketname_set = (EXT_GLOBAL(ini_last_updated)&U_SOCKNAME);
@


1.54
log
@Release-2.0.7
@
text
@d64 1
a64 1
  if(for_display && !(java_ini_last_updated&U_SOCKNAME)) {
d134 14
a147 14
/*   if(for_display && !(java_ini_last_updated&U_SOCKNAME)) { */
/* 	cfg_sockname="0"; */
/* 	s_prefix=inet_socket_prefix; */
/* 	cfg_logFile=""; */
/*   } */
  /* send a prefix so that the server does not select a different
   protocol */
/*   sockname = malloc(strlen(s_prefix)+strlen(cfg_sockname)+1); */
/*   strcpy(sockname, s_prefix); */
/*   strcat(sockname, cfg_sockname); */
/*   args[2] = sockname; */
  args[2] = strdup(EXT_GLOBAL(cfg)->logLevel);
  args[3] = strdup(cfg_logFile);
  args[4] = NULL;
@


1.53
log
@Release-2.0.7(pre)
@
text
@a28 1
#include <assert.h>
d43 1
a43 1
const static char inet_socket_prefix[]="INET:";
d114 3
d124 5
a128 1

d130 3
a132 1
  args[1] = strdup(EXTENSION_DIR/**/"/MonoBridge.exe");
@


1.52
log
@compiles with jdk1.5 + gnu java
@
text
@d49 1
a49 1
static void EXT_GLOBAL(get_server_args)(char*env[N_SENV], char*args[N_SARGS]) {
d64 6
d114 1
a114 1
static void EXT_GLOBAL(get_server_args)(char*env[N_SENV], char*args[N_SARGS]) {
d125 6
d172 1
a172 1
  EXT_GLOBAL(get_server_args)(env, args);
d226 1
a226 1
  EXT_GLOBAL(get_server_args)(env, args);
@


1.51
log
@Release-2.0.7pre
@
text
@d252 1
a252 1
  short called_from_init = !(local && _socket);
@


1.50
log
@Release-2.0.7-pre
@
text
@d239 5
a243 13
static int test_server(int port) {
  int sock, n;
  struct sockaddr_in saddr;

  sock = socket (PF_INET, SOCK_STREAM, 0);
  if(sock==-1) return -1;
  memset(&saddr, 0, sizeof saddr);
  saddr.sin_family = AF_INET;
  saddr.sin_port = htons(port);
  saddr.sin_addr.s_addr=htonl(INADDR_ANY);  
  n = connect(sock,(struct sockaddr*)&saddr, sizeof saddr);
  if(n==-1) { close(sock); return -1; }
  return sock;
d248 1
a248 4
 * if _socket!=NULL.  Spec is either M ono or J ava.  As a special
 * case it is called with (I)nit when the bridge starts; so that we
 * can avoid certain checks. If all ckecks fail a local backend is
 * started.
d250 13
a262 8
char* EXT_GLOBAL(test_server)(int *_socket, unsigned char spec) {
  int sock, port;
  time_t current_time = time(0);
  unsigned char backend = spec=='I'?0:spec; // Mono or Java backend

  /* local server, either started by the user before (I)nit or started by the bridge */
  if (((spec == 'I' && (EXT_GLOBAL(ini_updated)&U_SOCKNAME)) && (-1!=(sock=test_local_server())))
      || (spec != 'I' && (-1!=(sock=test_local_server())))) {
d268 1
a341 6
/*
  return 0 if user has hard-coded the socketname
*/
static short can_fork() {
  return EXT_GLOBAL(cfg)->can_fork;
}
d353 1
a353 1
  char *test_server;
d355 9
a363 23
  if(!(test_server=EXT_GLOBAL(test_server)(0, 'I'))) {
	if(can_fork()) {
	  if(pipe(p)!=-1) {
		if(!(pid=fork())) {		/* daemon */
		  close(p[0]);
		  if(!fork()) {			/* guard */
			if(!(pid=fork())) {	/* java */
			  setsid();
			  close(p[1]);
			  exec_vm(); 
			  exit(105);
			}
			/* protect guard */
			signal(SIGHUP, SIG_IGN); 
			s_pid=pid; signal(SIGINT, s_kill); 
			signal(SIGTERM, SIG_IGN);
			
			write(p[1], &pid, sizeof pid);
			waitpid(pid, &err, 0);
			write(p[1], &err, sizeof err);
			exit(0);
		  } 
		  exit(0);
d365 11
a375 4
		close(p[1]);
		wait(&err);
		if((read(p[0], &pid, sizeof pid))!=(sizeof pid)) pid=0;
	  }
d377 4
@


1.49
log
@Tomcat 5 support / multicasts removed
@
text
@d47 3
a49 2
static void java_get_server_args(char*env[N_SENV], char*args[N_SARGS]) {
  extern int java_ini_last_updated;
d52 3
a54 3
  char*program=cfg->java;
  char*cp=cfg->classpath;
  char*lib_path=cfg->ld_library_path;
d56 1
a56 1
  char*home=cfg->java_home;
d62 1
a62 1
  char *sockname, *cfg_sockname=cfg->sockname, *cfg_logFile=cfg->logFile;
d90 1
a90 1
  args[6] = strdup(cfg->logLevel);
d106 10
d117 14
a130 1
static const char* const wrapper = EXTENSION_DIR/**/"/RunJavaBridge";
d152 1
a152 1
char*java_get_server_string() {
d160 1
a160 1
  java_get_server_args(env, args);
d201 1
a201 1
  extern int java_bridge_main(int argc, char**argv) ;
d204 6
a209 4
  java_get_server_args(env, args, 0);
  putenv(env[0]);
  putenv(env[1]);
  java_bridge_main(N_SARGS, args);
d214 5
a218 3
  java_get_server_args(env, args);
  putenv(env[0]);
  putenv(env[1]);
d234 1
a234 1
  n = connect(sock,(struct sockaddr*)&cfg->saddr, sizeof cfg->saddr);
d261 1
a261 1
char* java_test_server(int *_socket, unsigned char spec) {
d267 1
a267 1
  if (((spec == 'I' && (java_ini_updated&U_SOCKNAME)) && (-1!=(sock=test_local_server())))
d274 1
a274 1
	return strdup(cfg->sockname);
d278 2
a279 2
  if(cfg->hosts && strlen(cfg->hosts)) {
	char *host, *hosts = strdup(cfg->hosts);
d329 1
a329 1
  struct pollfd pollfd[1] = {{cfg->err, POLLIN, 0}};
d333 2
a334 2
  while(cfg->cid && -1==(sock=test_local_server()) && --count) {
	if(cfg->err && poll(pollfd, 1, 0)) 
d336 1
a336 1
	php_error(E_NOTICE, "php_mod_java(%d): waiting for server another %d seconds",57, count);
d341 1
a341 1
  return (cfg->cid && count)?SUCCESS:FAILURE;
d351 1
a351 1
  return cfg->can_fork;
d362 1
a362 1
void java_start_server() {
d366 1
a366 1
  if(!(test_server=java_test_server(0, 'I'))) {
d395 2
a396 2
	cfg->cid=pid;
	cfg->err=p[0];
d401 1
a401 1
	  cfg->cid=cfg->err=0;
d408 1
a408 1
  struct pollfd pollfd[1] = {{cfg->err, POLLIN, 0}};
d411 2
a412 2
  assert(cfg->err);
  assert(cfg->cid);
d416 2
a417 2
  for(c=3; c>0 && cfg->cid; c--) {
	if (!(!cfg->err || (cfg->err && !(err=poll(pollfd, 1, 0))))) break;
d419 1
a419 1
	  kill(cfg->cid, SIGTERM);
d421 1
a421 1
	  if (!(!cfg->err || (cfg->err && !(err=poll(pollfd, 1, 0))))) break;
d424 1
a424 1
	  kill(cfg->cid, SIGKILL);
d427 2
a428 2
  if(cfg->err) {
	if((read(cfg->err, &err, sizeof err))!=sizeof err) err=0;
d430 2
a431 2
	close(cfg->err);
	cfg->err=0;
d436 1
a436 1
void php_java_shutdown_library() 
d438 1
a438 1
  if(cfg->cid) wait_for_daemon();
@


1.48
log
@Version 2.0.6 (windows)
@
text
@a38 1
#include "multicast.h"
a43 2
ZEND_EXTERN_MODULE_GLOBALS(java) /* HACK: pass down a struct to the multicaster */

d47 1
a47 1
static void java_get_server_args(char*env[N_SENV], char*args[N_SARGS], short for_display) {
a62 7
  /* if socketname is off, show the user how to start a multicast
	 backend */
  if(for_display && !(java_ini_last_updated&U_SOCKNAME)) {
	cfg_sockname="0";
	s_prefix=inet_socket_prefix;
	cfg_logFile="";
  }
d136 1
a136 1
  java_get_server_args(env, args, 1);
d188 1
a188 1
  java_get_server_args(env, args, 0);
d234 1
a234 2
  int sock, port, mc_socket;
  short mcount = 0;
a237 4
  if(cfg->have_mc_backends) {
	if(spec=='I') return strdup(GROUP_ADDR);
	mc_socket = php_java_init_multicast();
  }
a248 164
  /* multicast */
  if(cfg->have_mc_backends) {
	while(1) {//FIXME: stop busy waiting after some time
	  do {
		php_java_send_multicast(mc_socket, backend, current_time);
		port = php_java_recv_multicast(mc_socket, backend, current_time);
		if(-1!=port) {
		  if(-1!=(sock=test_server(port))) {
			if(_socket) {
			  *_socket=sock;
			} else {
			  close(sock);
			}
			close(mc_socket);
			return strdup(GROUP_ADDR);
		  }
		}
		php_java_sleep_ms(MAX_PENALTY);
	  } while(mcount++<MAX_TRIES);
	  php_error(E_WARNING, "php_mod_java(%d): waiting for backend another second. Please start more backends.",17);
	  sleep(1);
	}
  }

  /* host list */
  if(cfg->hosts && strlen(cfg->hosts)) {
	char *host, *hosts = strdup(cfg->hosts);
	
	assert(hosts); if(!hosts) return 0;
	for(host=strtok(hosts, ";"); host; host=strtok(0, ";")) {
	  struct sockaddr_in saddr;
	  char *_port = strrchr(host, ':'), *ret;
	  int port = 0;
	  
	  if(_port) { 
		*_port++=0;
		if(strlen(_port)) port=atoi(_port);
	  }
	  if(!port) port=atoi(DEFAULT_PORT);
	  memset(&saddr, 0, sizeof saddr);
	  saddr.sin_family = AF_INET;
	  saddr.sin_port=htons(port);
#ifndef __MINGW32__
	  if(!isdigit(*host)) {
		struct hostent *hostent = gethostbyname(host);
		if(hostent) {
		  memcpy(&saddr.sin_addr,hostent->h_addr,sizeof(struct in_addr));
		} else {
		  inet_aton(host, &saddr.sin_addr);
		}
	  } else {
		inet_aton(host, &saddr.sin_addr);
	  }
#else
	  saddr.sin_addr.s_addr = inet_addr(host);
#endif

	  sock = socket (PF_INET, SOCK_STREAM, 0);
	  if(-1==sock) continue;
	  if (-1==connect(sock,(struct sockaddr*)&saddr, sizeof (struct sockaddr))) {
		close(sock);
		continue;
	  }
	  if(_socket) *_socket=sock;
	  if(_port) _port[-1]=':';
	  ret = strdup(host);
	  free(hosts);
	  return ret;
	}
	free(hosts);
  }
  return 0;
}

char* java_test_server_no_multicast(int *_socket, unsigned char spec TSRMLS_DC) {
  int sock, port = -1, err, mc_socket;
  short mcount = 0;
  time_t current_time = time(0);
  unsigned char backend;
  zval **tmp_port, *new_port;

  assert(spec!='I');

#if HAVE_PHP_SESSION
  if (PS(session_status) == php_session_active) {
	/* Find the backend */
	if (zend_hash_find(Z_ARRVAL_P(PS(http_session_vars)), "_php_java_session_name", sizeof("_php_java_session_name"), (void **) &tmp_port) == SUCCESS &&
		Z_TYPE_PP(tmp_port) == IS_LONG) {
	  port = Z_LVAL_PP(tmp_port);
	}

  /* backend pool.  retrieve the backend from the session var */
	if(-1!=port) {
	  if(-1!=(sock=test_server(port))) {
		if(_socket) {
		  *_socket=sock;
		} else {
		  close(sock);
		}
		//fprintf(stderr, "got session. Use port :%ld\n", (long)port); //FIXME remove debug code
		return strdup(GROUP_ADDR);
	  } else {
		php_error(E_WARNING, "php_mod_java(%d): Session data lost.",16);
		zend_hash_del(Z_ARRVAL_P(PS(http_session_vars)), "_php_java_session_name", sizeof("_php_java_session_name"));
	  }
	}
		
#endif
	/* session lost or no session yet */

	/* local server */
	assert(port==-1);
	if ((-1!=(sock=test_local_server()))) {
	  if(_socket) {
	  *_socket=sock;
	  } else {
		close(sock);
	  }
	  return strdup(cfg->sockname);
	}

	/* no local server, select backend */
#if HAVE_PHP_SESSION
	//fprintf(stderr, "new session. send out mc\n"); //FIXME remove debug code
	assert(port==-1);
	/* no specific backend yet, select one */
	if(spec=='j') backend='J'; else backend='M';

	if(cfg->have_mc_backends) {
	  mc_socket = php_java_init_multicast();
	  while (1) {//FIXME: stop busy waiting after some time	  
		do {
		  php_java_send_multicast(mc_socket, backend, current_time);
		  port = php_java_recv_multicast(mc_socket, backend, current_time);
		  if(-1!=port) {
			if(-1!=(sock=test_server(port))) {
			  if(_socket) {
				*_socket=sock;
			  } else {
				close(sock);
			  }
			  close(mc_socket);
			  MAKE_STD_ZVAL(new_port);
			  Z_TYPE_P(new_port)=IS_LONG;
			  Z_LVAL_P(new_port)=port;
			  err = zend_hash_update(Z_ARRVAL_P(PS(http_session_vars)), "_php_java_session_name", sizeof("_php_java_session_name"), &new_port, sizeof(zval *), NULL);
			  assert(err==SUCCESS);
			  if(err==SUCCESS) {
				//fprintf(stderr, "new session (%d) on port: %ld\n", err, port); //FIXME remove debug code
				JG(session_is_new)=1;
				return strdup(GROUP_ADDR);
			  }
			}
		  }
		  php_java_sleep_ms(MAX_PENALTY);
		} while(mcount++<MAX_TRIES);
		php_error(E_WARNING, "php_mod_java(%d): waiting for backend another second. Please start more backends.",18);
		sleep(1);
	  }
	}
  }
#endif

  assert(-1==port);
@


1.47
log
@Release-2.0.6
@
text
@d227 1
d303 1
d443 1
@


1.46
log
@load balancer rewrite part#2 and loop problem fixed
@
text
@a351 10
#endif
  /* local server */
  if ((-1==port) && (-1!=(sock=test_local_server()))) {
	if(_socket) {
	  *_socket=sock;
	} else {
	  close(sock);
	}
	return strdup(cfg->sockname);
  }
a352 1
#if HAVE_PHP_SESSION
d363 16
d380 1
d382 3
a384 1
	
@


1.45
log
@load balancer rewrite
@
text
@d239 2
a240 4
 * can avoid checking the backend when there's no .ini entry in which
 * case we have to start the backend outselfs if multicast or the host
 * list fail.  Once the local backend is started, it is treated as if
 * it were started by the user.
d249 1
a250 1
	php_java_send_multicast(mc_socket, backend, current_time);
d265 13
a277 8
	do {
	  port = php_java_recv_multicast(mc_socket, backend, current_time);
	  if(-1!=port) {
		if(-1!=(sock=test_server(port))) {
		  if(_socket) {
			*_socket=sock;
		  } else {
			close(sock);
a278 2
		  close(mc_socket);
		  return strdup(GROUP_ADDR);
d280 5
a284 4
	  }
	  php_java_sleep_ms(MAX_PENALTY);
	  php_java_send_multicast(mc_socket, backend, current_time);
	} while(mcount++<MAX_TRIES);
d382 25
a406 21
	mc_socket = php_java_init_multicast();
	php_java_send_multicast(mc_socket, backend, current_time);
	do {
	  port = php_java_recv_multicast(mc_socket, backend, current_time);
	  if(-1!=port) {
		if(-1!=(sock=test_server(port))) {
		  if(_socket) {
			*_socket=sock;
		  } else {
			close(sock);
		  }
		  close(mc_socket);
		  MAKE_STD_ZVAL(new_port);
		  Z_TYPE_P(new_port)=IS_LONG;
		  Z_LVAL_P(new_port)=port;
		  err = zend_hash_update(Z_ARRVAL_P(PS(http_session_vars)), "_php_java_session_name", sizeof("_php_java_session_name"), &new_port, sizeof(zval *), NULL);
		  assert(err==SUCCESS);
		  if(err==SUCCESS) {
			//fprintf(stderr, "new session (%d) on port: %ld\n", err, port); //FIXME remove debug code
			JG(session_is_new)=1;
			return strdup(GROUP_ADDR);
d408 4
a411 1
		}
d413 1
a413 3
	  php_java_sleep_ms(MAX_PENALTY);
	  php_java_send_multicast(mc_socket, backend, current_time);
	} while(mcount++<MAX_TRIES);
@


1.44
log
@fixed typo
@
text
@d245 2
a246 1
  int sock, port;
d250 4
a253 2
  php_java_send_multicast(cfg->mc_socket, backend, current_time);

d266 13
a278 7
  port = php_java_recv_multicast(cfg->mc_socket, backend, current_time);
  if(-1!=port) {
	if(-1!=(sock=test_server(port))) {
	  if(_socket) {
		*_socket=sock;
	  } else {
		close(sock);
d280 3
a282 2
	  return strdup(GROUP_ADDR);
	}
d335 2
a336 1
  int sock, port = -1;
d379 23
a401 19
	php_java_send_multicast(cfg->mc_socket, backend, current_time);
	port = php_java_recv_multicast(cfg->mc_socket, backend, current_time);
	if(-1!=port) {
	  int err;
	  if(-1!=(sock=test_server(port))) {
		if(_socket) {
		  *_socket=sock;
		} else {
		  close(sock);
		}
		MAKE_STD_ZVAL(new_port);
		Z_TYPE_P(new_port)=IS_LONG;
		Z_LVAL_P(new_port)=port;
		err = zend_hash_update(Z_ARRVAL_P(PS(http_session_vars)), "_php_java_session_name", sizeof("_php_java_session_name"), &new_port, sizeof(zval *), NULL);
		assert(err==SUCCESS);
		if(err==SUCCESS) {
		//fprintf(stderr, "new session (%d) on port: %ld\n", err, port); //FIXME remove debug code
		  JG(session_is_new)=1;
		  return strdup(GROUP_ADDR);
d404 3
a406 1
	}
@


1.43
log
@Release-2.0.6pre
@
text
@d51 1
d68 1
a68 1
  if(for_display && !(java_ini_updated&U_SOCKNAME)) {
@


1.42
log
@if socketname is off, show command to start multicast node
@
text
@d324 1
a324 1
  int sock, port;
d330 9
d340 1
a340 1
  if (-1!=(sock=test_local_server())) {
d349 1
a350 8
#if HAVE_PHP_SESSION
  if (PS(session_status) == php_session_active) {
	/* Find the backend */
	port = -1;
	if (zend_hash_find(Z_ARRVAL_P(PS(http_session_vars)), "_php_java_session_name", sizeof("_php_java_session_name"), (void **) &tmp_port) == SUCCESS &&
		Z_TYPE_PP(tmp_port) == IS_LONG) {
	  port = Z_LVAL_PP(tmp_port);
	}
d358 1
a358 1
		fprintf(stderr, "got session. Use port :%ld\n", (long)port); //FIXME remove debug code
d363 1
a363 1
	fprintf(stderr, "new session. send out mc\n"); //FIXME remove debug code
d382 5
a386 5
		if(err!=SUCCESS) exit(5); fputs("new session success", stderr);

		fprintf(stderr, "new session (%d) on port: %ld\n", err, port); //FIXME remove debug code
		JG(session_is_new)=1;
		return strdup(GROUP_ADDR);
d392 1
a392 1

@


1.41
log
@java_get_session with load balancer
@
text
@d47 4
a50 1
static void java_get_server_args(char*env[N_SENV], char*args[N_SARGS]) {
d59 1
a59 1
  static char socket_prefix[]="INET:";
d61 1
a61 1
  static char socket_prefix[]="LOCAL:";
d63 14
a76 10
  char *sockname;
  if(cfg->can_fork) {			/* send a prefix so that the server
								   does not select a different
								   protocol */
	sockname = malloc((sizeof socket_prefix)+strlen(cfg->sockname));
	strcpy(sockname, socket_prefix);
	strcat(sockname, cfg->sockname);
  } else {
	sockname=strdup(cfg->sockname);
  }
d99 1
a99 1
  args[7] = strdup(cfg->logFile);
d134 3
d145 1
a145 1
  java_get_server_args(env, args);
d189 1
a189 1
  java_get_server_args(env, args);
d197 1
a197 1
  java_get_server_args(env, args);
@


1.40
log
@java_get_session with load balancer
@
text
@d45 2
@


1.39
log
@PR1174918: first start bug with charset
@
text
@d330 16
a345 17
  if (PS(session_status) != php_session_active &&
	  PS(session_status) != php_session_disabled) {
	php_session_start(TSRMLS_C);
  }

  /* Find the backend */
  port = -1;
  if (zend_hash_find(Z_ARRVAL_P(PS(http_session_vars)), "_bogus_session_name", sizeof("_bogus_session_name"), (void **) &tmp_port) == SUCCESS &&
	  Z_TYPE_PP(tmp_port) == IS_LONG) {
	port = Z_LVAL_PP(tmp_port);
  }
  if(-1!=port) {
	if(-1!=(sock=test_server(port))) {
	  if(_socket) {
		*_socket=sock;
	  } else {
		close(sock);
a346 1
	  return strdup(GROUP_ADDR);
d348 25
a372 14
  }

  assert(port==-1);
  /* no specific backend yet, select one */
  if(spec=='j') backend='J'; else backend='M';
  php_java_send_multicast(cfg->mc_socket, backend, current_time);
  port = php_java_recv_multicast(cfg->mc_socket, backend, current_time);
  if(-1!=port) {
	int err;
	if(-1!=(sock=test_server(port))) {
	  if(_socket) {
		*_socket=sock;
	  } else {
		close(sock);
a373 6
	  MAKE_STD_ZVAL(new_port);
	  Z_TYPE_P(new_port)=IS_LONG;
	  Z_LVAL_P(new_port)=port;
	  err = zend_hash_update(Z_ARRVAL_P(PS(http_session_vars)), "_bogus_session_name", sizeof("_bogus_session_name"), &new_port, sizeof(zval *), NULL);
	  assert(err==SUCCESS);
	  return strdup(GROUP_ADDR);
@


1.38
log
@PR1187636 ] java_get_session support
@
text
@d311 1
a311 1
char* java_test_server_no_multicast(int *_socket, unsigned char spec) {
a314 1
  short is_new=1;
@


1.37
log
@make multicasts 32 bit clean
@
text
@d36 1
d311 115
d447 1
a447 1
 return 0 if user has hard-coded the socketname
@


1.36
log
@multicast: ignore outdated packets
@
text
@d232 1
a232 1
  int current_time = 0xFFFFFFFF&time(0);
@


1.35
log
@mono
@
text
@d31 1
d221 9
d232 15
d249 1
a249 3
  php_java_send_multicast(cfg->mc_socket, spec);
  port = php_java_recv_multicast(cfg->mc_socket, spec);

a260 10
  /* local server */
  if(-1!=(sock=test_local_server())) {
	if(_socket) {
	  *_socket=sock;
	} else {
	  close(sock);
	}
	return strdup(cfg->sockname);
  }

d349 1
a349 1
  if(!(test_server=java_test_server(0, 0))) {
@


1.34
log
@windows fixes
@
text
@d37 1
d206 41
a246 2
char* java_test_server(int *_socket) {
  int sock;
d248 1
a293 9

  if(-1!=(sock=test_local_server())) {
	if(_socket) {
	  *_socket=sock;
	} else {
	  close(sock);
	}
	return strdup(cfg->sockname);
  }
d336 1
a336 1
  if(!(test_server=java_test_server(0))) {
@


1.33
log
@Release-2.0.1
@
text
@a207 1
#ifndef __MINGW32__
d224 1
d235 4
a238 1
	  
a252 1
#endif	  
@


1.32
log
@Release 2.0
@
text
@d232 2
@


1.31
log
@do not change the channel if server was forked by the httpd
@
text
@d108 1
d117 1
d208 1
d248 1
d262 1
d276 3
d291 1
d293 1
d299 1
d332 6
a337 4
  } else {
	cfg->cid=cfg->err=0;
	free(test_server);
  }
d341 1
d367 1
@


1.30
log
@Release-2.0-beta
@
text
@d50 16
a65 1

d84 2
a85 1
  args[5] = strdup(cfg->sockname);
d277 1
a277 1
  return (java_ini_updated&U_SOCKNAME)==0;
@


1.29
log
@Protocol update
@
text
@d302 3
d306 1
a307 1
	return;
a308 3
  cfg->cid=pid;
  cfg->err=p[0];
  wait_server();
@


1.28
log
@Replaced JNI with XML protocol
@
text
@d68 1
a68 1
  args[4] = strdup("JavaBridge");
d172 3
a174 4
int java_test_server() {
  char term=0;
  int sock;
  int n, c, e;
d181 1
a181 1
  if(sock==-1) return FAILURE;
d183 45
a227 4
  if(n!=-1) {
	char ob;
	c = write(sock, &term, sizeof term);
	c = (c==sizeof ob) ? read(sock, &ob, sizeof ob) : 0;
a228 1
  e = close(sock);
d230 9
a238 1
  return (n!=-1 && e!=-1 && c==1)?SUCCESS:FAILURE;
d241 1
a241 1
static int java_wait_server() {
d243 2
a244 2
  int count=15;

d246 1
a246 1
  while(cfg->cid && (java_test_server()==FAILURE) && --count) {
d253 1
d272 4
a275 3
  if(java_test_server() == FAILURE) {
	if(pipe(p)!=-1) {
	  if(can_fork()) {
d302 3
d308 1
a308 1
  java_wait_server();
a310 1

@


1.27
log
@Replaced JNI with XML protocol
@
text
@d186 2
a187 2
	c = read(sock, &ob, sizeof ob);
	c = (c==sizeof ob) ? write(sock, &term, sizeof term) : 0;
@


1.26
log
@*** empty log message ***
@
text
@a175 1
  jobject ob;
d185 1
@


1.25
log
@Release-1.0.8
@
text
@d51 1
a51 1
  if(!lib_path) sys_libpath="";
@


1.24
log
@Release-1.0.8
@
text
@d51 1
a51 1
  if(!sys_libpath) sys_libpath="";
@


1.23
log
@Release-1.0.8
@
text
@d51 1
a51 1
  if(!sys libpath) sys_libpath="";
@


1.22
log
@Release-1.0.8
@
text
@d51 1
a51 1
  if(!sys_lib_path) sys_libpath="";
@


1.21
log
@Release-1.0.8
@
text
@d51 1
a51 1
  if(!lib_path) sys_libpath="";
@


1.20
log
@ZTS
@
text
@d7 3
d38 6
a43 1
void java_get_server_args(char*env[N_SENV], char*args[N_SARGS]) {
d48 1
d51 1
d80 3
a82 2
  p=malloc(strlen(s)+strlen(lib_path)+1);
  strcpy(p, s); strcat(p, lib_path);
d86 65
d152 2
d159 10
a168 7
#ifdef CFG_JAVA_INPROCESS
 {
   extern int java_bridge_main(int argc, char**argv) ;
   java_bridge_main(N_SARGS, args);
 }
#else 
 execv(args[0], args);
@


1.19
log
@ZTS
@
text
@d137 1
a137 1
void s_kill(int sig) {
@


1.18
log
@ZTS
@
text
@a171 1
	java_wait_server();
d175 1
@


1.17
log
@secure mode
@
text
@d35 1
a35 1
void java_get_server_args(struct cfg*cfg, char*env[N_SENV], char*args[N_SARGS]) {
d75 1
a75 1
static void exec_vm(struct cfg*cfg) {
d78 1
a78 1
  java_get_server_args(cfg, env, args);
d91 37
d141 1
a141 1
void java_start_server(struct cfg*cfg TSRMLS_DC) {
d143 22
a164 19
  if(pipe(p)!=-1) {
	if(can_fork()) {
	  if(!(pid=fork())) {		/* daemon */
		close(p[0]);
		if(!fork()) {			/* guard */
		  if(!(pid=fork())) {	/* java */
			setsid();
			close(p[1]);
			exec_vm(cfg); 
			exit(105);
		  }
		  /* protect guard */
		  signal(SIGHUP, SIG_IGN); 
		  s_pid=pid; signal(SIGINT, s_kill); 
		  signal(SIGTERM, SIG_IGN);

		  write(p[1], &pid, sizeof pid);
		  waitpid(pid, &err, 0);
		  write(p[1], &err, sizeof err);
d166 4
a169 2
		} 
		exit(0);
a170 3
	  close(p[1]);
	  wait(&err);
	  if((read(p[0], &pid, sizeof pid))!=(sizeof pid)) pid=0;
d172 1
d179 1
a179 1
static void wait_for_daemon(struct cfg*cfg TSRMLS_DC) {
d207 1
a207 1
void php_java_shutdown_library(struct cfg*cfg TSRMLS_DC) 
d209 1
a209 1
  if(cfg->cid) wait_for_daemon(cfg TSRMLS_CC);
@


1.16
log
@release 1.0.7
@
text
@a94 1
#ifndef CFG_JAVA_SOCKET_ANON
a95 5
#else
  return 1;						/* ignore the already running JVM and
								   start a new JVM with the anonymous
								   socket */
#endif
@


1.15
log
@release 1.0.7
@
text
@d146 1
a146 1
  struct pollfd pollfd[1] = {cfg->err, POLLIN, 0};
d151 13
a163 3
  for(c=10; c>0 && cfg->cid && (!cfg->err || (cfg->err && !(err=poll(pollfd, 1, 0)))); c--) {
	kill(cfg->cid, SIGTERM);
	sleep(1);
a164 1
  if(!c) kill(cfg->cid, SIGKILL);
@


1.14
log
@trampoline
@
text
@d168 5
@


1.13
log
@trampoline
@
text
@d30 1
a30 1
#include "php.h"
@


1.12
log
@php 4/5
@
text
@d21 3
d110 2
a111 2
void java_start_server(struct cfg*cfg) {
  int pid=0, err=0, p[2], p1[2];
@


1.11
log
@PHP 5 support
@
text
@d101 6
d122 1
a122 1
		  signal(SIGINT, SIG_IGN); 
@


1.10
log
@Release-1.0.6
@
text
@d18 3
d135 24
@


1.9
log
@The client receives the bridge instance as the first element.  This fixes the classpath bug.
@
text
@d15 3
d111 5
@


1.8
log
@anon socket: create a guard process
@
text
@d43 11
a53 9
  s="-Djava.home=";
  p=malloc(strlen(s)+strlen(home)+1);
  strcpy(p, s); strcat(p, home);
  args[4] = p;					/* java home */
  args[5] = strdup("JavaBridge");
  args[6] = strdup(cfg->sockname);
  args[7] = strdup(cfg->logLevel);
  args[8] = strdup(cfg->logFile);
  args[9] = NULL;
@


1.7
log
@anon socket: create a guard process
@
text
@a42 1
  args[4] = strdup("JavaBridge");
d46 2
a47 1
  args[5] = p;					/* java home */
@


1.6
log
@The server now tracks resources
@
text
@d7 3
d26 1
a26 1
void java_get_server_args(struct cfg*cfg, char*env[2], char*args[9]) {
d37 1
a37 1
  args[1] = p;	/* library path */
d41 1
a41 1
  args[2] = p; 	/* user classes */
d44 8
a51 4
  args[5] = strdup(cfg->sockname);
  args[6] = strdup(cfg->logLevel);
  args[7] = strdup(cfg->logFile);
  args[8] = NULL;
d54 5
d60 3
a62 3
  strcpy(p, s); strcat(p, home);
  env[0] = p;	/* java home */
  env[1] = NULL;
a63 1

d65 2
a66 2
  static char*env[2];
  static char*args[9];
d69 9
a77 1
  execv(args[0], args);
d84 1
d86 5
a90 13
}

static int readpid(int fd) {
  int pid=0, c, err;

  for(c=0; c<sizeof pid; c+=err) {
	if((err=read(fd,((char*)&pid)+c, (sizeof pid)-c))<=0) {
	  php_error(E_WARNING, "php_mod_java(%d): %s",93, "Could not read pid, child lost");
	  pid=0;
	  break;
	}
  }
  return pid;
d94 1
a94 2
  int pid=0, p[2];

d97 1
a97 1
	  if(!fork()) {
d99 12
a110 6
		if(!(pid=fork())) {
		  exec_vm(cfg); 
		  exit(errno&255);
		}
		write(p[1], &pid, sizeof pid); 
		close(p[1]); 
d114 2
a115 2
	  pid=readpid(p[0]);
	  close(p[0]);
d119 1
@


1.5
log
@Close the socket in rshutdown
@
text
@a83 5
  {
	struct stat buf;
	unlink(cfg->sockname);
	assert(stat(cfg->sockname, &buf));
  }
@


1.4
log
@Start java in a separate process and give pval's a proper reference count.
@
text
@a56 1

d68 13
d82 22
a103 5
  int pid=0;
  if(can_fork()) {
	if(!(pid=fork())) {
	  exec_vm(cfg);
	  exit(errno&255);
@


1.3
log
@Do not fork() if the user has hard-coded the socketname
@
text
@d63 1
a63 1
 return 1 if user has hard-coded the socketname
d65 2
a66 2
static short cant_fork() {
  return (java_ini_updated&U_SOCKNAME)!=0;
d70 6
a75 4
  int pid;
  if(!(pid=(cant_fork() || fork()))) {
	exec_vm(cfg);
	exit(errno&255);
@


1.2
log
@pass modified user's environment to the child process
@
text
@d62 6
d71 1
a71 1
  if(!(pid=fork())) {
@


1.1
log
@Initial revision
@
text
@d57 3
a59 1
  execve(args[0], args, env);
@


1.1.1.1
log
@Initial
@
text
@@
